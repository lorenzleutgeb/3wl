s\documentclass{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{fixltx2e}   % Provides fixes for several errors in LaTeX2e.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amsthm}
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage{enumitem}   % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last.
\usepackage{lmodern}% http://ctan.org/pkg/lmodern
\usepackage{xspace}
\usepackage{marvosym}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{shapes.multipart,calc}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}

% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Lorenz Leutgeb} % The author name without titles.
\newcommand{\thesistitle}{Efficient propagation for lazy-grounding Answer Set solving} % The title of the thesis. The English version should be used, if it exists.

\hypersetup{
    pdfpagelayout   = TwoPageRight,
    linkbordercolor = {1 0.8 0.8}, %TODO change this to Melon when finished.
    pdfauthor       = {\authorname},
    pdftitle        = {\thesistitle},
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {asp, solver, propagation, nogood}
}

\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Prof.~Dr.}{Thomas Eiter}{}{male}

% For bachelor and master theses:
\setfirstassistant{Dr.}{Antonius Weinzierl}{}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

\setaddress{Engilgasse 3a, 1160 Wien}
\setregnumber{1127842}
\setdate{31}{10}{2016} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{Efficient propagation for lazy-grounding Answer Set solving} % Sets English and German version of the title (both can be English or German).
%\setsubtitle{Optional Subtitle of the Thesis}{Optionaler Untertitel der Arbeit} % Sets English and German version of the subtitle (both can be English or German).

\setthesis{bachelor}

\setcurriculum{Software \& Information Engineering}{Software \& Information Engineering} % Sets the English and German name of the curriculum.

% Define convenience macros.
\newcommand{\todo}[1]{{\color{red}\textbf{TODO: {#1}}}} % Comment for the final version, to raise errors.

\theoremstyle{example}
\newtheorem{example}{Example}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}[section]

\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}[theorem]

\theoremstyle{corollary}
\newtheorem{corollary}{Corollary}[theorem]

\newtheorem*{remark}{Remark}

\newcommand{\mbt}{must-be-true}
\newcommand{\negstrong}[1]{\overline{#1}^s}
\newcommand{\negweak}[1]{\overline{#1}^w}

% Function B transforming an assignment into a boolean assignment.
\newcommand{\bass}{\mathcal{B}}

% An assignment A.
\newcommand{\ass}{A}

% Herbrand Base function of some logic program.
\newcommand{\hb}{\textit{HB}}

\newcommand{\bT}{\mathbf{T}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\fabef}{\ass_{i}}
\newcommand{\faaf}{\ass_{i + 1}}
\newcommand{\abef}{\fabef{k + i}}
\newcommand{\aaf}{\faaf^{k + i + 1}}
\newcommand{\dbef}{\Delta_{i}}
\newcommand{\daf}{\Delta_{i+1}}
\newcommand{\contradiction}{\Lightning}
\newcommand{\cdpm}{C_\pm}
\newcommand{\cdal}{C_\alpha}
\newcommand{\dpm}{\Delta^\pm}
\newcommand{\dal}{\Delta^\alpha}

\newcommand{\righta}[1]{\ass_{#1}[{#1}, |\ass_{#1}|]}
\newcommand{\lefta}[1]{\ass_{#1}[0, {#1-1}]}

\newcommand{\welf}{well formed\xspace}
\newcommand{\upinv}{silent\xspace}
\newcommand{\lowinv}{watches\xspace}
\newcommand{\stbl}{stable\xspace}

\newcommand{\headf}{\mathrm{head}}
\newcommand{\bodyf}{\mathrm{body}}


\newcommand{\sgl}{\mu}
\newcommand{\bsgl}{\sigma}

\newcommand{\thrice}{{\{\bT, \bM, \bF \}}}

\newcommand{\wkn}{\textit{weaken}}

\usepackage{csquotes}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian}
\addtitlepage{english}
\addstatementpage

\begin{danksagung*}
\todo{Ihr Text hier.}
\end{danksagung*}

\begin{acknowledgements*}
I would like to thank Antonius Weinzierl for his consistent and continuous efforts in supporting me writing this thesis through numerous meetings, openness in discussion and acceptance of my contributions to the Alpha system and finding the right balance between pushing me to finish and letting me slack off to think freely.
\end{acknowledgements*}

\begin{kurzfassung}
\todo{Ihr Text hier.}
\end{kurzfassung}

\begin{abstract}
\todo{Enter your text here.}
\end{abstract}

\selectlanguage{english}

\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}

Since the inception of computer programming, different ways of encoding algorithms, structuring data and modeling the real world in computer programs have led to the development of various, conceptually diverse, programming languages. Families of programming languages that share some of the above properties are usually referred to abide a so called \enquote{programming paradigm}.
Such paradigms describe the common, most important concepts and lay a stylistic framework for a family of languages.

While the most widely used languages follow the \enquote{imperative} programming paradigm (some more strict, some less), this work focuses on Answer Set Programming (ASP), a declarative programming language that roots in Nonmonotonic Reasoning.

\section{Motivation}

\section{Problem Statement}

\section{Aim of the Work}

\section{Methodological Approach}

\section{Structure of the Work} % 3 sentences

Chapter \ref{chap:preliminaries} equips the reader with formal foundations (syntax and semantics) of ASP and stable models. Also, a selection of state-of-the-art ASP systems is discussed.

In chapter \ref{chap:prop} efficient propagation for lazy-grounding Answer Set solving is presented.

\todo{Expand to include later chapters.}

\chapter{Preliminaries}
\label{chap:preliminaries}

This chapter revisits definitions of syntax and semantics of answer set programs. Models and answer sets of such programs are defined.

Apart from these formal foundations, a brief overview of state-of-the-art ASP systems is given and systems that implement grounding-on-the-fly are observed in detail.

Basic knowledge in theoretical computer science are assumed.

\section{Answer Set Programming}

\todo{Introduction to ASP and its semantics.}

\subsection{Programs}

\begin{definition}[{\cite[p.~12]{DBLP:conf/rweb/EiterIK09}}]
A \emph{normal logic program} is a set of clauses having the form $$a \leftarrow b_1, \ldots , b_m, \text{not } c_1, \ldots , \text{not } c_n \qquad (n, m \geq 0)$$ where all $a, b_i$ and $c_j$ ($1 \leq i \leq n$ and $a \leq j \leq m$) are atoms of a first order language $L$. Expressions $\text{not } c_1, \ldots , \text{not } c_n$ are called the \emph{(default) negated literals} and consist of atoms $c_j$ preceded by the negation modifier $\text{not}$. Accordingly the atoms $a_i$ are called \emph{positive literals}.
\end{definition}

\section{State of the Art in ASP Solving}

\todo{Two Watched Literals?}

\subsection{Approaches based on Pre-Grounding}

\todo{Explain how a solver works and what has been done already (grounding on the fly, omiga, asperix).}
\todo{What is a nogood? What is propagation?}

\todo{Everything that later sections build up on. Quote a lot. This chapter can be long. Show understanding of the matter in own words (i.e. what is an answer set incl. example?).}

\subsection{Approaches based on Lazy Grounding}

\section{Analysis}

\section{Comparison and Summary of Existing Approaches}

\chapter{Propagation for lazy-grounding Answer Set solving}
\label{chap:prop}

This chapter contextualizes propagation by providing definitions extending chapter \ref{chap:preliminaries}. It then presents and thoroughly explains the algorithms and data structures involved in propagation and concludes in a proof of soundness and completeness thereof.

\section{Definitions}

% Signed literal vs. boolean signed literal.

Following definitions lay out the vocabulary and concepts towards an explanation of unit propagation. Most of them fundamentally depend on \emph{atoms} (usually denoted $v$) but do not refer to neither a set of atoms nor their domain. This is because all definitions are bound to a logic program $P$ to be solved (i.e.~to find answer sets for). The set of ground atoms wrt.~$P$, effectively its Herbrand Base $\textit{HB}(P)$, is obtained by the grounding process, which is not detailed in this work. What might seem to be lacking from the definitions therefore is the context of the input program $P$ and therefore the domain of atoms. $P$ and its context is omitted in the following.

\subsection{Literals}

% TODO: Where does v come from? Should be in some HB(P)?
%\begin{definition}
%A \emph{ground atom} (or simply \emph{atom}) wrt.~a logic program $P$ is an element of $\textit{HB}(P)$, usually denoted $v$.
%\end{definition}

\begin{definition}
A \emph{boolean signed literal} $\bsgl$ of the form $\bT v$ or $\bF v$ where $v$ is an atom and  $\bT v$ expresses that $v$ is \emph{true}, and $\bF v$ that it is \emph{false}.
\end{definition}

\begin{definition}
A generalization of boolean signed literal, called a \emph{signed literal} $\sgl$ is of the form $\bT v$, $\bF v$, or $\bM v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, $\bF v$ that it is \emph{false} (equivalent to the semantics of boolean signed literals) and $\bM v$ that it \emph{must be true}.
\end{definition}

%\begin{definition}
%The function $\wkn(\bsgl)$ takes a boolean signed literal $\bsgl$ and transforms it into a signed literal referred to as its \emph{weak form}, meaning that while \emph{false} stays \emph{false}, e.g.~$\wkn(\bF v) = \bF v$, \emph{true} is mapped to \emph{\mbt}, e.g.~$\wkn(\bT v) = \bM v$.
%\end{definition}

% TODO: Remark on boolean signed literal vs. signed literal with context of clasp?

\begin{definition}
Strong complement, denoted by $\negstrong{\sgl}$, and weak complement, $\negweak{\sgl}$, mapping $\bF v$ to $\bT v$ and $\bF v$ to $\bM v$ respectively, of a signed literal are defined by the following truth table:%equalities: $\negstrong{\bT v} = \bF v$, $\negstrong{\bM v} = \bF v$ and  $\negstrong{\bF v} = \bT v$, while $\negweak{\bT v} = \bF v$, $\negweak{\bM v} = \bF v$ and $\negweak{\bF v} = \bM v$.
% "andere Richtung auch erklären"

\begin{center}
\begin{tabular}{|c|cc|}
\hline
$\sgl$&$\negstrong{\sgl}$&$\negweak{\sgl}$\\
\hline
\hline
$\bT v$&$\bF v$&$\bF v$\\
$\bM v$&$\bF v$&$\bF v$\\
$\bF v$&$\bT v$&$\bM v$\\
\hline
\end{tabular}
\end{center}
\end{definition}

\begin{definition}
Two literals $\sgl_1, \sgl_2$ are said to \emph{conflict} in case $\sgl_1 = \negweak{\sgl_2}$ or $\negweak{\sgl_1} = \sgl_2$.
\end{definition}

Occasionally the notation $\sgl = \bX v$ will be used to express that $\sgl$ is a literal of $v$ where $\bX \in \thrice$, i.e.~$\sgl$ is \enquote{bound} to $v$, but the sign is not important.

\subsection{Assignments}

Similar to \cite[section 2, p.~3]{DBLP:journals/ai/GebserKS12} we define assignments. However, here assignments contain not only boolean signed literals, but also signed literals and the notation for expressing a partial assignment differs.

\begin{definition}
An \emph{assignment} $\ass$ is a sequence $(\sgl_1, \ldots, \sgl_n)$ of signed literals $\sgl_i = \bX v_i$, or \emph{conflict}.
\end{definition}

%\begin{remark}
Below, assignments are sometimes also used as sets, in which case the set represented by some assignment is simply the set of all signed literals contained in the sequence.
%\end{remark}

The number of elements in an assignment $|\ass|$ is intuitive, with $|\emph{conflict}| = 0$.

A partial assignment is a sub-sequence constructed from an assignment denoted as $\ass[i,j] = (\sgl_i, \ldots, \sgl_j)$ where $\ass = (\sgl_1, \ldots, \sgl_i, \ldots, \sgl_j, \ldots, \sgl_n)$ and $1 \leq i < j \leq n$.

A single literal is referenced using $A[i] = \sgl_i$ for $1 \leq i \leq |A|$.

The assignment obtained by appending the literal $\sgl$ to $\ass = (\sgl_1, \ldots, \sgl_n)$ is denoted by $$\ass \circ \sgl = \left\{\begin{array}{ll}
        
        \emph{conflict} & \text{if } \{ \negstrong{\sgl}, \negweak{\sgl} \} \cap \ass \not = \emptyset \text{ or } \ass = \emph{conflict}\\
        %(\sgl_1, \ldots, \sgl_{n-1}, \sgl) & \text{if } \sgl = \bT v \text{ and } \bM v \in \ass \text{, i.e. appending } \bT v \text{ removes } \bM v\\
        (\sgl_1, \ldots, \sgl_{n}, \sgl) & \text{otherwise} \\
        \end{array}\right.$$

%Appending preserves that for any atom $v$ there is at most one literal in the assignment: With $\sgl = \bT v$ and $\bM v \in \ass$, for $\ass' = \ass \circ \sgl$ it holds that $\bM v \not \in \ass'$ (and $|\ass'| = |\ass|$).

%Furthermore $\emph{conflict} \circ \sgl = \emph{conflict}$ for any $\sgl$. 

\begin{definition}
For every assignment, a respective \emph{boolean assignment}, denoted $\bass(\ass)$ can be constructed by collapsing all atoms that \emph{must be true} to being \emph{true}:$$\bass(\ass) = \{ \sgl \in \ass \ | \ \sgl = \bT v \textrm{ or } \sgl = \bF v \} \cup \{ \bT v \ | \ \bM v \in \ass \}$$
\end{definition}

\begin{definition}
An atom $v$ is \emph{assigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} \not = \emptyset$$
\end{definition}

%\begin{definition}
%An atom $v$ is \emph{unassigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} = \emptyset$$
%\end{definition}

\begin{definition}
A signed literal $\bX v$ is \emph{assigned} under $\ass$ iff $v$ is assigned under $\ass$.
\end{definition}

Intuitively, atoms and literals are \emph{unassigned} under $\ass$ iff the are not assigned under $\ass$.

\begin{definition}
A literal $\sgl_1$ is said to conflict with $\ass$ in case it conflicts with any $\sgl_2 \in \ass$.
\end{definition}

\subsection{Nogoods}

\begin{definition}
A \emph{nogood} reflects a partial assignment that cannot be extended to a solution. Here, a \emph{nogood} is a set $\{ \bsgl_1, \ldots, \bsgl_n \}$ of boolean signed literals.
\end{definition}

\begin{definition}
At most one of the boolean signed literals inside a nogood might be qualified as head. The head literal $\bsgl$ of $\delta$ denoted $\headf(\delta) = \bsgl$.
\end{definition}

Note that $\headf(\delta)$ is always of the form $\bF v$. % TODO why?

\begin{definition}
Any literal in a nogood $\delta$ that is not it's head is element of the so called \emph{body} of the nogood: $\bodyf(\delta) = \{ \bsgl \in \delta \ | \ \bsgl \not = \headf(\delta) \}$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{weakly unit} under an assignment $\ass$ iff $\delta \setminus \bass(\ass) = \{ \bsgl \}$
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{strongly unit} under an assignment $\ass$ iff $\delta \setminus \ass = \{ \headf(\delta) \}$
\end{definition}

Note that, as the names suggest, any nogood that is strongly unit under some assignment is also weakly unit, but not the other way round. Below, nogoods are sometimes referred to be \emph{unit} which amounts to stating that they are weakly unit. Also, when clear from context, reference to a particular assignment is omitted.

\begin{definition}
\label{def:vio}
A nogood $\delta$ is \emph{violated} under an assignment $\ass$ iff $\delta \subseteq \bass(\ass)$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{satisfied} under an assignment $\ass$ iff there is no $\ass' \supseteq \ass$ s.t.~$\delta$ is violated under $\ass'$.
\end{definition}

For the purpose of unit propagation, it is important to see that because a satisfied nogood will never be unit, therefore never yield a new assignment using unit propagation.

\begin{definition}
A nogood $\delta$ is \emph{\upinv} under some assignment $\ass$ iff $\delta$ is not violated by $\ass$ and $\delta$ is not unit wrt.~$\ass$.
\end{definition}

Note the difference between some $\delta$ being \upinv vs.~satisfied under an assignment: With $\delta$ being \upinv under $\ass_1$, there might well be some $\ass_1' \supset \ass_1$ under which $\delta$ is unit or violated. However $\delta$ satisfied under $\ass_2$ is stronger and implies that there is no \enquote{larger} assignment $\ass_2' \supset \ass_2$ such that $\delta$ is not satisfied under $\ass_2'$ by definition. It follows that $\delta$ can neither be unit nor violated under $\ass_2'$.

When implementing propagation, na{\"i}vely obtaining checking a large set of nogoods that represents an ASP program for unity is infeasible. Sophisticated data structures are needed to make propagation sufficiently fast.

\subsection{Watch structures}

\begin{definition}
% ASK: Why not define watch structure as a function/relation mapping from atom to watch sets? Structure is irrelevant, and mapping function is closer to a map in code.
% ASK: How to omit irrelevant elements of a tuple?
A \emph{watch structure} is a function that maps atoms $v$ to triples containing sets of nogoods, the so called \emph{watch sets} of $v$: $$\Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

%For any watch set $W$ in $\Delta(v)$ and nogood $\delta \in W$ it follows that $\bX v \in \delta$.

For some signed literal $\sgl = \bX v$ let $$\dpm(\sgl) = \left\{\begin{array}{ll}
        W^+ & \text{if } \sgl = \bT v \ \text{or } \sgl = \bM v\\
        W^- & \text{if } \sgl = \bF v \\
        \end{array}\right\} \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

For some signed literal $\sgl = \bX v$ or an atom $v$ let $$\dal(\sgl) = \dal(v) = W_i^\alpha \ \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$
\end{definition}

Interpretation as a set $\Delta = \{(v_i, (W_i^+, W_i^-, W_i^\alpha)\}$ for $1 \leq i \leq n$ where $i \not = j \to v_i \not = v_j$ for $1 \leq j \leq n$ reveals how such a mapping can be stored or visualized (see figure~\ref{fig:watches}).

\begin{figure}[h]
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]
\node(s)[stack=4]  {
                 Atom     % text
\nodepart{two}   $v_1$     % two
\nodepart{three} $v_2$      % three
\nodepart{four}  \vdots % four
};

\node(v1t)[stack=3, rectangle split horizontal, above right=2cm and 3cm of s.two] {
$\delta_1$     % two
\nodepart{two} $\delta_2$      % three
\nodepart{three}  \ldots % four
};

\node(v1m)[stack=3, rectangle split horizontal, above right=1cm and 3.5cm of s.two] {
$\delta_3$     % two
\nodepart{two} $\delta_4$      % three
\nodepart{three}  \ldots % four
};

\node(v1f)[stack=3, rectangle split horizontal, above right=0cm and 4cm of s.two] {
$\delta_5$     % two
\nodepart{two} $\delta_6$      % three
\nodepart{three}  \ldots % four
};

\path (s.two east)
edge [out=east,in=west, left] node {$+$} (v1t)
edge [out=east,in=west, above] node {$-$} (v1m)
edge [out=east,in=west, above] node {$\alpha$} (v1f)
;

\end{tikzpicture}
  \caption{Example layout of a \emph{watch structure}.}
  \label{fig:watches} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

\begin{definition}
The \emph{candidate sets} of a nogood $\delta$ under an assignment $A$ are subsets of the nogood  and defined as follows:

$$\cdpm(\delta, A) = \{\bsgl \in \delta \ | \ \bsgl \not \in \bass(\ass)\}$$

$$\cdal(\delta, A) = \{ \bT v \in \bodyf(\delta) \ | \ \bT v \not \in \ass \}$$

Intuitively, $C_\alpha(\delta, A)$ is the set of positive body literals in $\delta$ that are not assigned to be $\emph{true}$.
\end{definition}

\begin{definition}

A watch structure $\Delta$ \emph{\lowinv} an assignment $\ass$ iff for every nogood $\delta \in \Delta$ holds:

\begin{enumerate}
\item $|\cdpm(\delta, A)| \geq 2$ implies there exist $\bsgl_1, \bsgl_2 \in \cdpm(\delta, A)$ such that $\bsgl_1 \not = \bsgl_2$ and $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$, and
%Older version: \item If $\delta$ is not satisfied under $\ass$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ unassigned under $\ass$, then $\delta$ is contained in exactly two distinct watch sets, e.g. $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$ with $\bsgl_1 \not = \bsgl_2$.
\item $\cdal(\delta, A) \not = \emptyset$ implies that there is exactly one $\bsgl \in \cdal(\delta, A)$ with $\delta \in \dal(\bsgl)$.
\end{enumerate}
\end{definition}

Using watch structures that watch assignments, propagation can be implemented efficiently: Given $\Delta$ watching $\ass$ and a new assignment for some atom $\sgl = \bX v$ the nogoods that are candidates for propagation are those in $\dpm(\sgl)$ (in case $\sgl \not \in A$, thus $\sgl$ changes from \emph{unassigned} to \emph{true}, \emph{\mbt} or \emph{false}) and $\dal(\sgl)$ (in case $\sgl \in A$, thus $\sgl$ changes from \emph{\mbt} to \emph{true}).

However, with $\Delta$ watching $\ass$ and extending the assignment $\ass' = \ass \circ \sgl$, now $\Delta$ does not trivially watch $\ass'$.

\begin{definition}
A watch structure $\Delta$ is said to be \welf under some assignment $\ass$ in case all nogoods $\delta \in \Delta$ are \upinv under $\ass$ and $\Delta$ \lowinv $\ass$.
\end{definition}

In the next section, a closer look at propagation will reveal that when transitioning from an assignment to the next one, watch sets can be altered efficiently to obtain a well formed watch structure for the extended assignment.

\section{Unit Propagation}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		a~signed~literal~$\sgl$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation with literal $A[j]$ and $\Delta$ with updated watches.}
  $\langle \ass_1, \Delta_1 \rangle \leftarrow \langle \ass \circ \sgl, \Delta \rangle$ \label{alg:up:circ}\\
  $i \leftarrow 1$ \label{alg:up:i}\\
  \While{$|\ass_i| \geq |A| + i$\label{alg:up:loop:begin}}{
  $\langle \ass_{i+1}, \Delta_{i+1} \rangle \leftarrow$ \textsc{UnitPropagate}($\ass_{i}$, $\Delta_{i}$, $|A| + i$) \label{alg:up:loop:prop}\\
    $i \leftarrow i + 1$ \label{alg:up:loop:incr}
  } \label{alg:up:loop:end}
  \Return{$\langle \ass_i, \Delta_i \rangle$} \label{alg:up:ret}
  \caption{\textsc{UnitPropagateAll}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:up}
\end{algorithm}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		an~index~$j$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation and $\Delta$ with updated watches.}
%  \If{$|A| < j$}{\Return{$\langle \ass, \Delta \rangle$}}
  $\sgl \leftarrow \ass[j]$ \label{alg:up:loop:lit}\\
  $\langle \ass', \Delta' \rangle \leftarrow$ \textsc{UnitPropagationUnassigned}($\ass$, $\Delta$, $\sgl$)\\
  \If{$\sgl$ is of form $\bT v$}
  {
    $\langle \ass'', \Delta'' \rangle \leftarrow$ \textsc{UnitPropagationAssigned}($\ass'$, $\Delta'$, $\sgl_i$)\\
    \Return{$\langle \ass'', \Delta'' \rangle$}
  }
  \Return{$\langle \ass', \Delta' \rangle$}
  \caption{\textsc{UnitPropagate}($\ass$, $\Delta$, $j$)}
  \label{alg:upsingle}
\end{algorithm}

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~set~of~watched~nogoods~$\Delta$,~and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation and $\Delta$ with updated watches.}
%  \ForEach{$\delta \in w_{=2}(\Delta, \sigma)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned in $\mathbf{A}$}
%    {
%      $\mathbf{A} \leftarrow \mathbf{A} \circ \negweak{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dpm(\sgl)$ \label{alg:upu:it}}
  {
    \uIf{$\delta$ is violated \label{alg:upu:vio}}
    {
      \Return{$\langle \emph{conflict}, \Delta \rangle$ \label{alg:upu:conflict}}
    }
    \uElseIf{$\delta$ is strongly unit \label{alg:upu:su}}
    {
      $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upu:su:circ}
    }
    \uElseIf{$\delta$ is weakly unit with $\bsgl$ unassigned \label{alg:upu:wu}}
    {
      $\ass \leftarrow \ass \circ \negweak{\bsgl}$ \label{alg:upu:wu:circ}
    }
    \Else%If{there is some unassigned $\sigma' \in \delta$}
    { \label{alg:upu:else}
      \ForEach{$\bsgl \in \delta$}
      {
      	$\dpm(\bsgl) \leftarrow \dpm(\bsgl) \setminus \{ \delta \}$ \label{alg:upu:rm}
 	  }\label{alg:upu:move:start}
      Let $\bsgl_1, \bsgl_2 \in C_\pm(\delta, A)$ be arbitrary\\
      $\dpm(\bsgl_1) \leftarrow \dpm(\bsgl_1) \cup \{ \delta \}$\\
      $\dpm(\bsgl_2) \leftarrow \dpm(\bsgl_2) \cup \{ \delta \}$ \label{alg:upu:move:end}\\
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateUnassigned}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upu}
\end{algorithm}

Algorithm \ref{alg:upu} exhibits how unit propagation is used to infer assignments (of either false or \mbt) from watched nogoods. 
In line 1, the input literal $\sgl$ is transformed to its weak form as lookups in $\Delta$ are always made against the set of nogoods that might propagate in case the literal \mbt, even if $\sgl$ is of $\bT x$. % Why?
In the loop spanning from line 2-13 all nogoods that are to be checked for propagation according to $\Delta$ are iterated. For any such nogood one of the following three cases holds true
\begin{enumerate}
\item it is violated, leading to the algorithm immediately returning the conflicting assignment, or
\item it is weakly unit, in which case a new assignment can be inferred from the nogood, or
\item in any other case, there must be at least two unassigned literals in $\delta$, which are to be watched for changes in assignments.
% TODO: Does not (1.) and not (2.) guarantee that there are two unassigned literals?! Nogood could be satisfied.
\end{enumerate}

In case (3.), $\Delta$ is modified in lines 8-11. As $\sgl$ is now assigned, it should not be watched for changes anymore. This is achieved by removing $\delta$ from the set of watches $\Delta(\sgl)$ and instead adding it to the set of watches for two unassigned literals in $\delta$.

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~watch~structure~$\Delta$, and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation.}
%  \ForEach{nogood $\delta \in w_{=2}(\Delta)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned}
%    {
%      $\mathbf{A} \circ \negstrong{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dal(\sgl)$}
  {
	\uIf{$\delta$ is strongly unit}
	{
	  $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upa:su:circ}
	}
    \ElseIf{$C_\alpha(\delta, A) \not = \emptyset$}
    {
      $\dal(\sgl) \leftarrow \dal(\sgl) \setminus \{ \delta \}$\\
      % Choose $\bsgl \in L$ s.t.~there is no $\bsgl' \in L$ with $\ass = (\ldots, \bsgl, \ldots, \bsgl', \ldots)$.\\
      Let $\sigma \in C_\alpha(\delta, A)$ be arbitrary\\
      $\dal(\bsgl) \leftarrow \dal(\bsgl) \cup \{ \delta \}$\\
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateAssigned}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upa}
\end{algorithm}

%In order to implement efficient propagation, a data

% No Unfounded Set checks -> MBT.

% Explain 2WL with MBT, propagation with MBT (pseudocode of propagation algorithm).

% Invariant
For every nogood $\delta \in \Delta$, if $\delta$ contains at least two atoms unassigned under $\ass$, then $\delta$ is contained in exactly two watch lists.
%TODO define watch list!

\begin{theorem}
Algorithm \ref{alg:up} is sound, i.e.~given an assignment $\ass$, a watch structure $\Delta$, a literal $\sgl$, and the following preconditions, it results in a new assignment $\ass'$ and a new watch structure $\Delta'$ such that all following postconditions hold:

\begin{enumerate}[label={\normalfont (\textsc{Pre}\arabic*)},ref=(\textsc{Pre}\arabic*)]
\item $\Delta$ \lowinv $A$. \label{up:sound:pre2}
\item All nogoods $\delta \in \Delta$ are silent under $\ass$. \label{up:sound:pre1}
\end{enumerate}

\begin{enumerate}[label={\normalfont (\textsc{Post}\arabic*)},ref=(\textsc{Post}\arabic*)]
\item If $\sgl$ does not conflict with $\ass$ and there are assignments that can be inferred by means of unit propagation, then: \label{up:sound:post2}
\begin{enumerate}[label={\normalfont (\alph*)},ref=\theenumi(\alph*)]
\item $\Delta'$ \lowinv $\ass'$. \label{up:sound:post2b}
\item All nogoods $\delta \in \Delta'$ are silent under $\ass'$. \label{up:sound:post2a}
\end{enumerate}
\item If a literal inferred from $\Delta$ and $\ass \circ \sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$. \label{up:sound:post3}
\item If $\sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$ and $\Delta' = \Delta$. \label{up:sound:post1}% Trivial case.
\end{enumerate}
\end{theorem}

\begin{proof}
%We show that:

%\begin{enumerate}
%\item in case $\sgl$ conflicts with $\ass$, the algorithm will return the assignment \emph{conflict} and $\Delta$ is not guaranteed to be well formed,
%\item otherwise, the resulting watch structure $\Delta$ will be well formed wrt. the resulting assignment $\ass$.
%\end{enumerate}

%In line 1 of algorithm \ref{alg:up}, $\ass$ is altered by appending the given signed literal $\sgl$. Now, $\Delta$ might not be well formed wrt.~the altered assignment $\ass'$ anymore, because there might be some nogood $\delta \in \dpm(\sgl)$. By executing algorithm \ref{alg:upu}, $\Delta$ is transformed into a well formed watch structure $\Delta'$.

Before establishing a proof for \ref{up:sound:post2} and \ref{up:sound:post3} observe the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} of Algorithm \ref{alg:up} closely:

\begin{description}
\item[Initialization] Construct $A_1$ by appending $\sgl$ to $\ass$ (ln.~\ref{alg:up:circ}). Initialize some loop counter $i = 1$ (ln.~\ref{alg:up:i}). It points at the next literal on which propagation should be performed, i.e.~initially $\sgl = \ass_1[|\ass| + 1]$. 

\item[Iteration] Let the pair $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle = \textsc{UnitPropagate}(\ass_i, \Delta_i, \ass_i[|A| + i])$ (ln.~\ref{alg:up:loop:prop}) denote the output of the $i$-th iteration which performs propagation on assignment $\ass_i$, watch structure $\Delta_i$ and literal $\ass_i[|A| + i]$ (ln.~\ref{alg:up:loop:lit}). Conversely $S_i$ can be interpreted as the input for the $i$-th iteration. Analysis of the difference between $\Delta_{i}$ and $\Delta_{i+1}$ is what resembles soundness below.

\item[Termination] Because the number of literals in all nogoods $\delta \in \Delta$ is finite, for some $i = k$ the loop invariant (ln.~\ref{alg:up:loop:begin}) is violated, i.e.~$|A| + i > |\ass_{i}|$. Intuitively, this is the case if no new assignment can be inferred ($S_{k-1} = \langle \ass_{k-1}, \Delta_{k-1} \rangle$ and $S_k = \langle \ass_k, \Delta_k \rangle$ with $\ass_{k-1} = \ass_k$) or a conflict is reached ($\ass_k = \emph{conflict}$). When the loop terminates, $\langle \ass', \Delta' \rangle = S_k$ is returned (ln.~\ref{alg:up:ret}).
\end{description}

Towards showing \ref{up:sound:post2} and \ref{up:sound:post3} by induction, assume that $\sgl$ does not conflict with $\ass$ and let $\mathcal{P}(n) = \textrm{\ref{up:sound:ind:noconflict}} \vee \textrm{\ref{up:sound:ind:conflict}}$ where

\begin{enumerate}[label=(\Roman*)]
	\item Let $\ass_n^L = \ass_n[1, |A| + n - 1], \ass_n^R = \ass_n[|A| + n, |\ass_n|]$. For each $\delta$ in $\Delta$: \label{up:sound:ind:noconflict}
		\begin{enumerate}[label=(\alph*),ref=\theenumi(\alph*)]
			\item $\Delta_n$ watches $\ass^L_n$. \label{up:sound:ind:watches} % Or watches \ass^L_n?
			\item If $\delta$ is weakly unit under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:wu}
			\item If $\delta$ is strongly unit under $\ass_n$, then $\exists {\bT v_1} \in A_n^R : \delta \in \Delta_n^\alpha(v_1)$ or $\exists {\bF v_2} \in A_n^R : \delta \in \Delta_n^\pm({\bF v_2})$. \label{up:sound:ind:su}
			\item If $\delta$ is violated under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:vio}
		\end{enumerate}
	\item $\ass_n = \emph{conflict}$ \label{up:sound:ind:conflict}
\end{enumerate}

\paragraph{Base Case} Concerning the input assignment $\ass_0 = \ass$ and $\Delta_0 = \Delta$, $\mathcal{P}(0)$ directly follows, because \ref{up:sound:ind:watches} amounts to \ref{up:sound:pre2}, and \ref{up:sound:pre1} implies that the antecedents of \ref{up:sound:ind:wu}, \ref{up:sound:ind:su}, \ref{up:sound:ind:vio} are false.

%The induction step now consists of observing that the loop in lines 3-10 \enquote{preserves} properties (1.) and (2.) of soundness, i.e.~it argues the transitivity of those properties for iteration steps $S_{i}$ to $S_{i+1}$.

%We show that every nogood $\delta \in \Delta'$ is \welf wrt.~$\Delta'$ and $\ass'$, i.e.~$\Delta'$ is \welf wrt.~$\ass'$, by using that $\Delta$ is \welf wrt.~$\ass$ and the definition of the algorithm.

\paragraph{Induction Step} For two consecutive iteration steps $S_{i} = \langle \ass_{i}, \Delta_{i} \rangle$ and $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle$, assume $\mathcal{P}(i)$. For readability, let $j = |A| + i$, $\ass_i^L = \ass_i[1, j - 1]$, $\ass_i^R = \ass_i[j, |\ass_i|]$, $\ass_{i+1}^L = \ass_i[1, j]$, $\ass_{i+1}^R = \ass_i[j + 1,|\ass_{i+1}|]$, $\sgl_i = A_i[j]$, $\sgl_{i+1} = A_{i+1}[j+1]$. Then show $\mathcal{P}(i) \to \mathcal{P}(i + 1)$ as follows:

\paragraph{Intuition} Note that $\sgl_i \not \in \ass_i^L$, $\sgl_i \in \ass_i^R$ and $\sgl_i \in \ass_{i+1}^L$, $\sgl_i \not \in \ass_{i+1}^R$, intuitively in the $i$-th iteration, $\sgl_i$ \enquote{moves} from the \enquote{right} subsequence of the assignment to its \enquote{left} subsequence. As expected, the two subsequences united add up to the full sequence $A_i = A_i^L \cup A_i^R$. Further the \enquote{right} subsequence \enquote{grows} (with the exception of $\sgl_i$), i.e.~$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$. Also, $\ass_{i+1}^L = \ass_{i}^L \cup \{ \sgl_i \}$ is useful.

\todo{$\Delta$ as the set of all nogoods in the program?}

\begin{enumerate}
\item \todo{Show \ref{up:sound:ind:watches}}
\item To show \ref{up:sound:ind:wu}, let $\delta \in \Delta$ and assume $\delta$ is weakly unit under $\ass_{i+1}$ (else, \ref{up:sound:ind:wu} trivially holds):
\begin{enumerate}
	\item Assume $\delta$ is weakly unit under $\ass_i$. \label{pr:corr:wu:wu}
	
	Then $\exists \sgl \in \ass_i^R : \delta \in \Delta_i^\pm(\sgl)$ by the induction hypothesis. 
	
	Assume towards contradiction that $\sgl = \sgl_i$. As $\delta \in \dpm_i(\sgl)$, the weak complement of $\sgl$ is appended to the assignment (Algorithm \ref{alg:upu}, line \ref{alg:upu:wu:circ}), thus $\negweak{\sgl} \in A_{i+1}$. Then $\delta$ is not weakly unit under $A_{i+1}$ contradicting our assumption.
	
	Therefore, $\sgl \not = \sgl_i$. From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$. Further $\delta \in \dpm_{i}(\sgl)$ implies $\delta \in \Delta_{i+1}^\pm(\sgl)$ follows from $\sgl \not = \sgl_i$ and $\delta$ weakly unit under $\ass_i$ (see Algorithm \ref{alg:upu}, line \ref{alg:upu:it} iterating over $\sgl_i$). Thus we have $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:wu} holds.
%\end{enumerate}
	\item Assume $\delta$ is not weakly unit under $A_i$.
	
	Then $\cdpm(\delta, \ass_{i}) \geq 2$ and because $\Delta_i$ watches $A_i$ (ind.~hyp.), we have $\exists \bsgl_1, \bsgl_2 \in \delta : \bsgl_1 \not = \bsgl_2 \wedge \delta \in \Delta_i^\pm(\bsgl_1) \wedge \delta \in \Delta_i^\pm(\bsgl_2)$. We distinguish on whether $\sgl_i$ coincides with one of the watched literals:

	\begin{enumerate}
		%\item Assume $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$ towards a contradiction. As $\bsgl_1, \bsgl_2 \in \cdpm(\delta, \ass_i)$, both $\bsgl_1, \bsgl_2$ are unassigned under $\ass_i$ by definition of $\cdpm$. For $\delta$ to be weakly unit under $\ass_{i+1}$, there must be exactly one $\bsgl' \in \delta$ unassigned under $\ass_{i+1}$.
		\item Case $\sgl_i \not = \bsgl_1 \wedge \sgl_i \not = \bsgl_2$.
		
		$\Delta_i^\pm(\bsgl_1) = \Delta_{i+1}^\pm(\bsgl_1)$ and $\Delta_i^\pm(\bsgl_2) = \Delta_{i+1}^\pm(\bsgl_2)$, as watch sets are only modified in case $\bsgl_1 = \sgl_i$ and respectively $\bsgl_2 = \sgl_i$ (see Algorithm \ref{alg:upu}: only nogoods that are being iterated over in line \ref{alg:upu:it} are being removed from any watch sets in line \ref{alg:upu:rm}). Both $\bsgl_1$ and $\bsgl_2$ are in $A_{i+1}^R$, because $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, thus we have \ref{up:sound:ind:wu}.
		
		\item Case either $\sgl_i = \bsgl_1$ or $\sgl_i = \bsgl_2$.
		\label{sigmaprimes}		
		
		Without loss of generality ($\bsgl_1$ and $\bsgl_2$ arbitrary in $\cdpm(\delta, \ass_i)$), let $\sgl_i = \bsgl_1$. Therefore, $\bsgl_1 \not \in A_{i+1}^R$ and $\bsgl_2 \in A_{i+1}^R$. While processing $\delta$, in Algorithm \ref{alg:upu} the branch in line \ref{alg:upu:else} is taken (otherwise $\delta$ cannot be unit under $\ass_{i+1}$. All candidates $\cdpm(\delta, \ass_i)$ except $\bsgl_1$, and therefore any literals $\bsgl_1', \bsgl_2'$ (arbitrarily) chosen in the algorithm, are either unassigned under $\ass_{i+1}$ or in $\ass_{i+1}^R$. As $\delta$ is unit under $\ass_{i+1}$, exactly one of these must be unassigned.
		Assume (w.l.o.g., symmetric) $\bsgl_1'$ unassigned under $A_{i+1}$ and $\bsgl_2' \in \ass_{i+1}^R$. Then \ref{up:sound:ind:wu} holds for $\bsgl_2'$.
		
		\item Case $\bsgl_1 = \sgl_i \wedge \bsgl_2 = \sgl_i$ is impossible because $\bsgl_1 \not = \bsgl_2$.
		\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:su}, let $\delta \in \Delta$ and assume $\delta$ is strongly unit (and therefore also weakly unit or $\headf(\delta) = \bM v$) under $\ass_{i+1}$ (else, \ref{up:sound:ind:su} trivially holds):
\begin{enumerate}
	\item Case $\delta$ is strongly unit under $\ass_i$. Then $\exists {\bT v_1} \in \ass_i^R : \delta \in \dal_i(v_1)$ or $\exists {\bF v_2} \in \ass_i^R : \delta \in \dpm_i({\bF v_2})$ via induction hypothesis.
	\begin{enumerate}
		\item Case $\sgl_i = {\bT v_1}$. Then Algorithm \ref{alg:upa} appends the strong complement of the head (line \ref{alg:upa:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
		\item Case $\sgl_i = {\bF v_2}$. Then Algorithm \ref{alg:upu} appends the strong complement of the head (line \ref{alg:upu:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
			%\item Case $\sgl_i = {\bT v_1} \wedge \sgl_i = {\bF v_2}$ is contradictory. \contradiction % Amounts to the case where $\sgl_i = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$ because algorithm \ref{alg:upu} is executed before algorithm \ref{alg:upa}, which degrades to a no-operation, because $\delta$ is neither strongly unit, nor is $C_\alpha(\delta, A)$ (where $A$ is defined in the scope of the algorithm, a hybrid state between $A_i$ and $A_{i+1}$) non-empty when it is executed.
		\item Case $\sgl_i \not = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$.
		From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that if ${\bT v_1}, {\bF v_2}$ exist, they are in $\ass_{i+1}^R$. Also, $\delta \in \dal_i(v_1)$ implies $\delta \in \dal_{i+1}(v_1)$ and $\delta \in  \dpm_i({\bF v_2})$ implies $\delta \in \dpm_{i+1}({\bF v_2})$ because $\delta$ is strongly unit and $\sgl_i \not \in \delta$. So we have $\exists {\bT v_1} \in \ass_{i+1}^R : \delta \in \dal_{i+1}(v_1)$ or $\exists {\bF v_2} \in \ass_{i+1}^R : \delta \in \dpm_{i+1}({\bF v_2})$, i.e.~\ref{up:sound:ind:su}. % TODO: \sgl might actually change (pointer move) which is not mentioned here. If this does not get mentioned in the watches section of the proof, add a remark here explaining that \sgl might change in the course of algorithm 3.3 but only in a way that fulfills above criteria.
	\end{enumerate}
	
	
	\item Case $\delta$ is not strongly unit under $A_i$. Then, $\bodyf(\delta) \setminus A_i \not = \emptyset$.


	\begin{enumerate}
		\item Case ${\bT v} \in \bodyf(\delta) \setminus A_i$.
		
		Then, $C^\alpha(\delta, A_{i}) \not = \emptyset$. Because $\Delta_i$ watches $\ass_i$ it follows that $\exists \bsgl \in C_\alpha(\delta, A_i): \delta \in \dal(\sigma)$.
		
		\begin{enumerate}
			\item Case $\sgl_i = \bsgl$.
			
			leads to a contradiction ($\delta$ not strongly unit under $A_{i+1}$)
			
			\item Case $\sgl_i \not = \bsgl$.
			
			$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, we have $\bsgl \in \ass_{i+1}^R$, thus $\exists \bsgl \in \ass_{i+1}^R : \delta \in \dal_{i+1}(\bsgl)$, i.e.~\ref{up:sound:ind:su}. \todo{Why $\delta \in \dal_{i+1}(\bsgl)$?}
		\end{enumerate}			
			
		\item Case ${\bT v} \not \in \bodyf(\delta) \setminus A_i$.
			\begin{enumerate}
				\item Case $\negweak{\headf(\delta)} \not \in A_{i} \wedge \negstrong{\headf(\delta)} \not \in A_{i}$, i.e.~the head is unassigned. Then there are at least two literals in $\delta$ unassigned under $A_i$ (one in the body and the head). From \ref{up:sound:ind:watches} we have $\bsgl_1, \bsgl $
				\item Case $\negweak{\headf(\delta)} \in A_{i}$.
				If $|\bodyf(\delta) \setminus A_i| \geq 2$, then there are at least two unassigned literals. Else if $\bodyf(\delta) \setminus A_i = \{ {\bF v} \}$, then $\delta$ is weakly unit.
			\end{enumerate}
	\end{enumerate}


%	\begin{enumerate}
%		\item Case $\bT v \in \bodyf(\delta) \setminus A_i$. If $\headf(\delta) \not \in A_i$ then there are at least two distinct literals $\bsgl_1, \bsgl_2 \in \delta$ (one in the body, and the head) that are unassigned unter  $A_i$ and \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$. Else, i.e.~$\headf(\delta) \in A_i$, then $|\bodyf(\delta) \setminus A_i| \geq 2$, thus \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$.
%		\item Case $\bodyf(\delta) \setminus A_i = \{ \bF v' \}$, i.e.~$\delta$ is weakly unit under $A_i$, then according to \ref{up:sound:ind:wu}, $\exists \ \bsgl \in \bass(A_i^R) : \delta \in \Delta_i^\pm(\bsgl)$. From $A_i^R \cap \delta \subseteq \{ \bF v' \}$ follows that $v = v'$ and thus \ref{up:sound:ind:su}.
%	\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:vio}, let $\delta \in \Delta$ and assume $\delta$ is violated under $A_{i+1}$ (else \ref{up:sound:ind:vio} trivially holds).
\begin{enumerate}
\item Assume $\delta$ is violated under $A_i$.

Then $\exists \sgl \in \ass_i^R : \delta \in \dpm_i(\sgl)$ via induction hypothesis.
\begin{enumerate}
\item Case $\sgl = \sgl_i$.

Then, according to Algorithm \ref{alg:upu} (line \ref{alg:upu:conflict}) $A_{i+1} = \emph{conflict}$, so \ref{up:sound:ind:conflict} holds.

\item Case $\sgl \not = \sgl_i$.

Then, from $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$, thus $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$. Also $\delta \in \dpm_i(\sgl)$ implies $\delta \in \dpm_{i+1}(\sgl)$, as watch sets are only modified for nogoods that are watched by $\sgl_i$. So we have $\exists \sgl \in \ass_i^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:vio} holds.
\end{enumerate}
\item Assume $\delta$ is not violated under $A_i$. Then $|\bass(A_i) \setminus \delta| \geq 1$  holds by Definition \ref{def:vio}.

\begin{enumerate}
\item Assume $|\bass(A_i) \setminus \delta| \geq 2$. Then because $\Delta_i$ watches $A_i$ it follows that $\exists \bsgl_1, \bsgl_2 : \delta \in \Delta_i^\pm(\bsgl_1), \Delta_i^\pm(\bsgl_2)$. Further $\bsgl_1 \not = \sgl_i$ or $\bsgl_2 \not = \sgl_i$, so w.l.o.g.~$\bsgl_1 \not = \sgl_i$, so $\exists \ {\bX v} \in X : \delta \in \Delta_{i+1}^\pm(v)$ with a reasoning similar to \ref{sigmaprimes}.

\item Assume $|\bass(A_i) \setminus \delta| = 1$. Then $\delta$ is weakly unit under $A_i$, thus this case amounts to \ref{pr:corr:wu:wu}.
\end{enumerate}

\end{enumerate}

\end{enumerate}

\begin{comment}
\begin{enumerate}
\item If $\sgl_i \not \in \delta$, then: % A nogood only contains boolean signed literals, so dies this even make sense? \sgl is a signed literal, not a boolean signed literal, so how can it be element of delta? Needs clarification.
\begin{enumerate}
\item $\delta$ is not violated under $\abef$ (inv1). Therefore, $\delta$ is not violated under $\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item $\delta$ is not unit wrt.~$\abef$ (inv2). Therefore, $\delta$ is not unit wrt.~$\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned wrt.~$\aaf$. Then $\bsgl_1$ and $\bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied under $\abef$, because $\abef \subset \aaf = \abef \circ \sgl_i$ and $\sgl_i \not \in \delta$. Therefore, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ must hold (inv3). For the same two literals, $\delta \in \daf^\pm(\bsgl_1)$ and $\delta \in \daf^\pm(\bsgl_2)$ holds. % Needs clarification. Reference the loop that the nogood is certainly not part of.
\item Analogous to (c), if $\delta$ has any triggers, their assignment does not change, as $\sgl_i \not \in \delta$, and no watches $\delta \in \dbef^\alpha(\bsgl)$ are changed. The same $\bsgl$ will satisfy $\delta \in \dbef^\alpha(\bsgl)$ for $\abef$ and $\aaf$.
\end{enumerate}
\item Else ($\sgl_i \in \delta$):
\begin{enumerate}
\item If $\delta \not \in \dbef^\pm(\sgl_i)$, i.e.~$\delta$ was not watched on $\sgl_i$, then
\begin{enumerate}
\item To show that $\delta$ is not violated by $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not violated under $\aaf$ as $\delta$ is not violated by $\abef$ (inv1) and $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals in $\delta$ unassigned wrt.~$\abef$ as $\delta$ is not unit wrt.~$\abef$ (inv2). From $|\aaf| = |\abef| + 1$ if follows that there must be at least one literal in $\delta$ which is unassigned wrt.~$\aaf$, therefore $\delta$ cannot be violated under $\aaf$.
\end{enumerate}
\item To show that $\delta$ is not unit under $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not unit under $\aaf$ because $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ that are unassigned wrt.~$\abef$, as $\delta$ is not unit under $\abef$ (inv2). Further, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ (inv3). From $\delta \not \in \dbef^\pm(\sgl_i)$ it follows that $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$. % How are binary signed literals and signed literals compared?
Therefore $\delta$ is not unit, because $\bsgl_1, \bsgl_2 \in \delta$ are unassigned wrt.~$\aaf$.
\end{enumerate}
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned under $\aaf$. Then $\bsgl_1, \bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied wrt.~$\abef$ because $\abef \subset \aaf$ and $\delta \not \in \dbef^\pm(\sgl_i)$ and $\delta$ is not unit wrt.~$\abef$.
\item Same as 1.d ...
\end{enumerate}
\item Else ($\delta \in \dbef^\pm(\sgl_i)$), i.e.~$\delta$ was watched on $\sgl_i$.
\begin{enumerate}
\item If $\delta$ is weakly unit under $\aaf$ with $\bsgl$ unassigned, then the algorithm generates the assignment $\negweak{\bsgl}$.
\item Else
\item If there are two unassigned pointer move $\to$ two unassigned literals
\item pointer move $\to$ two unassigned literals
\item violated $\to$ conflict
\item weakly unit $\to$ satisfied
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{comment}

Above induction step serves as an explanation on how execution of the loop affects the assignment and especially the watch structure. By using induction, $\mathcal{P}(i)$ was shown for any $i \geq 0$, and therefore for any iteration of the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} as well. Specifically $\mathcal{P}(i)$ holds for the last iteration $i = k$ represented by $S_k = \langle \ass_k, \Delta_k \rangle$.

For cases without conflict and the loop terminating at $S_k$, \ref{up:sound:post2b} is obvious from \ref{up:sound:ind:watches} as $\ass' = \ass_k$ and $\Delta' = \Delta_k$. From termination follows $A_k^R = \emptyset$, i.e.~there are no nogoods $\delta \in \Delta'$ that are weakly unit, strongly unit or violated under $\ass'$, thus all $\delta$ are silent under $\ass'$ which amounts to \ref{up:sound:post2a}.

Cases in the induction step leading to show \ref{up:sound:ind:conflict} map to \ref{up:sound:post3}.

To show \ref{up:sound:post1} rather trivially: Assume $\sgl$ conflicts with $\ass$. Then, on line~\ref{alg:up:circ} of the algorithm $\ass$ will be assigned \emph{conflict}. Consequently, the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} is not executed as $|\emph{conflict}| = 0$ and $i$ must be at least 1, as it is assigned 1 on line \ref{alg:up:i}. $\langle \ass, \Delta \rangle$ is returned.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is complete.
\end{theorem}

\begin{proof}
Indirect proof, showing that if there is an assignment that results from propagation it will be generated.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is sound and complete.
\end{theorem}

\begin{proof}

\end{proof}

\chapter{Implementation}

\section{Benchmarks}

\chapter{Conclusion}

\section{Related Work}

\section{Conclusion}

\subsection{Related Work}

\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
\printglossaries

% Add a bibliography.
\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
