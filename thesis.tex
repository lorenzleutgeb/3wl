\documentclass{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{fixltx2e}   % Provides fixes for several errors in LaTeX2e.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amsthm}
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage{enumitem}   % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last.
\usepackage{lmodern}% http://ctan.org/pkg/lmodern
\usepackage{xspace}
\usepackage{marvosym}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{shapes.multipart,calc}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}

% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Lorenz Leutgeb} % The author name without titles.
\newcommand{\thesistitle}{Efficient propagation for lazy-grounding Answer Set solving} % The title of the thesis. The English version should be used, if it exists.

\hypersetup{
    pdfpagelayout   = TwoPageRight,
    linkbordercolor = {1 0.8 0.8}, %TODO change this to Melon when finished.
    pdfauthor       = {\authorname},
    pdftitle        = {\thesistitle},
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {asp, solver, propagation, nogood}
}

\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Prof.~Dr.}{Thomas Eiter}{}{male}

% For bachelor and master theses:
\setfirstassistant{Dr.}{Antonius Weinzierl}{}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

\setaddress{Engilgasse 3a, 1160 Wien}
\setregnumber{1127842}
\setdate{31}{10}{2016} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{Efficient propagation for lazy-grounding Answer Set solving} % Sets English and German version of the title (both can be English or German).
%\setsubtitle{Optional Subtitle of the Thesis}{Optionaler Untertitel der Arbeit} % Sets English and German version of the subtitle (both can be English or German).

\setthesis{bachelor}

\setcurriculum{Software \& Information Engineering}{Software \& Information Engineering} % Sets the English and German name of the curriculum.

% Define convenience macros.
\newcommand{\todo}[1]{{\color{red}\textbf{TODO: {#1}}}} % Comment for the final version, to raise errors.

\theoremstyle{example}
\newtheorem{example}{Example}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}[section]

\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}[theorem]

\theoremstyle{corollary}
\newtheorem{corollary}{Corollary}[theorem]

\newtheorem*{remark}{Remark}

\newcommand{\mbt}{must-be-true}
\newcommand{\negstrong}[1]{\overline{#1}^s}
\newcommand{\negweak}[1]{\overline{#1}^w}

% Function B transforming an assignment into a boolean assignment.
\newcommand{\bass}{\mathcal{B}}

% An assignment A.
\newcommand{\ass}{A}

% Herbrand Base function of some logic program.
\newcommand{\hb}{\textit{HB}}

\newcommand{\bT}{\mathbf{T}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\fabef}{\ass_{i}}
\newcommand{\faaf}{\ass_{i + 1}}
\newcommand{\abef}{\fabef{k + i}}
\newcommand{\aaf}{\faaf^{k + i + 1}}
\newcommand{\dbef}{\Delta_{i}}
\newcommand{\daf}{\Delta_{i+1}}
\newcommand{\contradiction}{\Lightning}
\newcommand{\cdpm}{C_\pm}
\newcommand{\cdal}{C_\alpha}
\newcommand{\dpm}{\Delta^\pm}
\newcommand{\dal}{\Delta^\alpha}

\newcommand{\righta}[1]{\ass_{#1}[{#1}, |\ass_{#1}|]}
\newcommand{\lefta}[1]{\ass_{#1}[0, {#1-1}]}

\newcommand{\welf}{well formed\xspace}
\newcommand{\upinv}{silent\xspace}
\newcommand{\lowinv}{watches\xspace}
\newcommand{\stbl}{stable\xspace}

\newcommand{\headf}{\mathrm{head}}
\newcommand{\bodyf}{\mathrm{body}}

\newcommand{\fail}{\mathrm{not } \ \xspace}
%\newcommand{\from}{\mathrm{\ \xspace :- \ \xspace}}
\newcommand{\from}{\ensuremath{\leftarrow}}
\newcommand{\problem}{\ensuremath{\mathscr{P}}}

\newcommand{\entails}{\models}

% Least model (of a Horn program).
\newcommand{\lm}{\mathrm{lm}}

% Set of stable models (of a program).
\newcommand{\stm}{\mathrm{STM}}
\newcommand{\sol}{\mathrm{Sol}}
\newcommand{\compl}{\mathrm{Co}}
\newcommand{\groundext}{\mathrm{Gr}}
\newcommand{\defense}{\mathrm{Def}_F}

% Entails according to well founded semantics.
\newcommand{\wf}{\ensuremath{\entails_{wf}}}

% Entails according to stable model semantics using brave reasoning
\newcommand{\brave}{\ensuremath{\entails_{st}^b}}

% Entails according to stable model semantics using cautious reasoning
\newcommand{\caut}{\ensuremath{\entails_{st}^c}}

% Selective Linear Definite-clause with Negation as Failure
\newcommand{\sldnf}{\ensuremath{\vdash_{NF}}}

\newcommand{\universe}{\mathcal{U}}
\newcommand{\afs}{\mathcal{F}}
\newcommand{\attacks}{\rightsquigarrow}

\newcommand{\sgl}{\mu}
\newcommand{\bsgl}{\sigma}

\newcommand{\thrice}{{\{\bT, \bM, \bF \}}}

\newcommand{\wkn}{\textit{weaken}}

\newcommand{\asperix}{{\texttt{ASPeRiX}\xspace}}
\newcommand{\clasp}{\texttt{clasp}\xspace}
\newcommand{\dlv}{\texttt{DLV}\xspace}
\newcommand{\omiga}{\texttt{OMiGA}\xspace}

\usepackage{csquotes}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian}
\addtitlepage{english}
\addstatementpage

\begin{danksagung*}
\todo{Ihr Text hier.}
\end{danksagung*}

\begin{acknowledgements*}
I would like to thank Antonius Weinzierl for his consistent and continuous efforts in supporting me writing this thesis through numerous meetings, openness in discussion, acceptance of my contributions to the Alpha system and finding the right balance between pushing me to finish and letting me slack off to think freely.
\end{acknowledgements*}

\begin{kurzfassung}
Answer Set Programming (ASP) ist eine deklarative Programmiersprache in Anlehnung an Prädikatenlogik erster Stufe, welche üblicherweise durch ASP-Systeme evaluiert wird. Wir präsentieren das \emph{grounding bottleneck}, um die Limitationen aktueller ASP-Systeme aufzuzeigen und diskutieren mögliche Lösungsansätze mit einem Fokus auf \emph{lazy-grounding} wie im Alpha System.

Der Komppromiss zwischen Speicherverbrauch und vollständiger Verfügbarkeit des grundierten Programms resultiert in neuen Restriktionen für Algorithmen und Datenstrukturen in ASP-Systemen. Der Hauptteil der Arbeit beschreibt wie \emph{Unit Propagation} basierend auf \emph{two-watched-literals} auf drei Literale erweitert werden kann, sodass Berechnungen mit einem teilweise grundierten Programm ausgeführt werden können.
\end{kurzfassung}

\begin{abstract}
Answer Set Programming (ASP) is a declarative programming language rooted in first order logic that is commonly evaluated using ASP systems. We present the \emph{grounding bottleneck}, which is exhibits limitations of state-of-the-art ASP systems and discuss possible approaches, with a focus on \emph{lazy-grounding} as implemented in the Alpha system.

Trading off memory consumption for complete availability of the ground program poses new design constraints on algorithms and data structures in ASP systems. The main part of the work describes how \emph{unit propagation} based on \emph{two-watched-literals} can be extended to three watched literals in order to account for a lazily grounded program.
\end{abstract}

\selectlanguage{english}

\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}
\label{chap:intro}

Since the inception of computer programming, different ways of encoding algorithms, structuring data and modeling the real world in computer programs have led to the development of various conceptually diverse programming languages. Families of programming languages that share some of the above properties are usually thought to bide to a so called \enquote{programming paradigm}.
Such paradigms describe the common, most important concepts and lay a stylistic framework for a family of languages.

The most widely used languages follow the \enquote{imperative} programming paradigm (some more strict, some less), which revolves around \enquote{commanding} the computer. In this work, in contrast to mainstream software engineering, the main focus is Answer Set Programming (ASP), a declarative programming language that roots in first order logic.

Without going into details about how ASP works, consider the following example for an intuition.

\begin{example}
\label{ex:garments}
Suppose one needs to decide what to wear. The following program narrows down the selection of garments (a winter jacket, a pair of jeans, a t-shirt and shorts, see lines 1.1 to 1.4) in the wardrobe by checking whether specific pieces are designed to be worn in the current season (lines 1.7 and 1.8). Also, the program expresses that it can't be both summer and winter at the same time in line 1.9.
%rule with two vars
%allowdisplaybreaks?
\begin{flalign}
&garment(winterjacket).\\
&garment(jeans).\\
&garment(tshirt).\\
&garment(shorts).\\
&warm(winterjacket).\\
&light(shorts).\\
inseason(G) \from& \ winter, garment(G), \fail light(G).\\
inseason(G) \from& \ summer, garment(G), \fail warm(G).\\
wear(G) \from& \ garment(G), inseason(G).\\
\from winter, summer.
\end{flalign}

$winter$ and $summer$ are propositions that will need to be provided, as the program cannot figure out whether it is currently summer or winter. The knowledge whether a garment is \emph{in season} is represented as a rule that considers whether a piece is not light (resp.~not warm) which means it should be worn in winter (resp.~summer).
\end{example}

The evaluation of an ASP program is done by an ASP system, which may be comprised of further components. For \enquote{user} and programmer, it largely acts as a black box. Given an input program (and sometimes a few options on which algorithms or data structures to employ) it computes the answer sets.

% benuetzen gleiche techniken, es hat sich gezeigt, dass techniken aus dem sat bereich effizient sind

Many ASP system implementations use solving algorithms closely related to those found in SAT solvers to search for answer sets. Adapting SAT solvers turned out to be highly effective for solving ASP. Because there are no variables in SAT, variables such as \emph{G} in the above example must be removed from the program. The process of substituting variables with constants, e.g. substituting \emph{G} with one of the four concrete garments, is referred to as \emph{grounding} and the resulting variable-free is said to be \emph{ground}.

Naively substituting each occurrence of \emph{G} in the example yields eight instances of the \emph{inseason} rule (two per garment), and four of the \emph{wear} rule (one per garment). With rules that use two garments, the number of instances would multiply by the number of garments once more. We see that, in general, while the program with variables can be rather terse, the corresponding ground program might be exponentially larger.

State-of-the-art ASP systems feature two components: The \emph{grounder} takes care of substituting all variables, i.e.~generating the ground program, while the \emph{solver} takes this ground program as input and computes answer sets. Traditionally, the grounder is invoked first, and only after it has output the ground program, the solver starts execution. This two-phased mode of operation is referred to as \emph{ground-and-solve}. With the ground program being exponentially larger than the original input program with variables, these systems are prone to what we call the \emph{grounding bottleneck}: When the ground program is so large that it does not fit into memory, the search for answer sets is impossible in practice. For more examples that exhibit the grounding bottleneck, refer to \cite{asperix}[Section 1].

\section{Motivation}
\label{sec:motivation}
% propagation als teil des solvers
% leitet information her
% anhand des beispiels beispiel für propagation
% vergleich mit g-s übersetzen in sat klauseln bzw. nogoods (2wl)

The goal of solver components in ASP systems is determining which propositions (such as $wear(winterjacket)$, for example) are \emph{true} and \emph{false} respectively. A structure encoding which propositions are \emph{true} (resp.~\emph{false}) is called an \emph{assignment}. It allows for statements such as \enquote{$wear(winterjacket)$ is \emph{true}}. Assignments conflicting with rules of the program are considered invalid. In our example, any assignment that allows stating both \enquote{$summer$ is \emph{true}} and \enquote{$winter$ is \emph{true}} at the same time, must be avoided as it cannot represent an answer set.

Through the combination of truth values and information about conflicting truth values of propositions, both encoded in the input program, solvers can infer truth values of other propositions. One method to extend an assignment this way is called \emph{unit propagation}: Consider again the above example. Line 1.9 can be written as a clause $winter \wedge summer$ that must not evaluate to true, or simply as a set $\delta = \{ summer, winter \}$ of the two propositions that cannot conform with the assignment at the same time. Generally, such sets of propositions and their negations are called \emph{nogoods}. From their property that not all corresponding truth values in the assignment may conform with the nogood at the same time, it follows that when all but one elements of the nogood conform with the assignment (we say the nogood is \emph{unit}), the truth value of the remaining proposition can be inferred and added to the assignment. In the example, an assignment saying that \enquote{$summer$ is \emph{true}} in combination with $\delta$ implies a new truth value, namely that \enquote{$winter$ is \emph{false}}. Note that in case we know \enquote{$summer$ is \emph{false}} we may not infer the truth value of $winter$.

In order to perform unit propagation, ground-and-solve systems commonly translate the input program into nogoods, and even more advanced algorithms have been devised to dynamically \enquote{learn} new nogoods in the process of searching for answer sets.

For solvers to be efficient, it is crucial to quickly identify which nogoods are unit, even when the assignment under which the nogoods might individually be unit changes very frequently. Modern solvers implement the so called \emph{two-watched-literals} (2WL) strategy \cite{effsat,questsat}, which describes both an algorithm and a data structure to track nogoods and propagate as soon as they become unit.

However, translation of the input program into nogoods in its entirety requires the input program to be ground, because truth values can only be inferred for concrete propositions. \todo{Is this the correct reason why 2WL does not work for lazy grounding?} The approach is therefore subject to the grounding bottleneck.

The motivation of this work is finding a way to adapt 2WL, which was shown to be successfully in SAT solvers as well as ground-and-solve ASP systems, such that it can be employed in lazy-grounding ASP systems.

\section{Problem Statement}
\label{sec:problem}
% 2wl works for sat and ground asp. how to adapt it for lazy grounding?

2WL is an efficient technique for implementing propagation in SAT solvers \cite{effsat,questsat} and ground-and-solve ASP systems \cite[Sec.~5.3]{clasp}. However, it cannot be directly used in lazy-grounding ASP systems, because its prerequisite of a ground program is in conflict with the principle of lazy grounding. The problem to be solved therefore is finding a way to adapt the known procedure in a way that is compatible with lazy-grounding.

\section{Aim of the Work}
\label{sec:aim}
% enahnce 2wl st it has properties for lazy g
% -> 3wl works for lazy grounding

\section{Methodological Approach}
% design algorithms and datastructures
% analyze and proof soundness/completeness
% implementation
% benchmarks

After an analysis of 2WL, algorithms and data structures that account for lazy-grounding were devised and their soundness and completeness was shown. An implementation was contributed to the Alpha system, which in turn was compared against a naive approach in form of a benchmark.

\section{Structure of the Work} % 3 sentences

In Chapter \ref{chap:prelim} we formally capture logic programs such as the one in the above example (syntax and semantics) of ASP and stable models. Also, a selection of state-of-the-art ASP systems is discussed.

In chapter \ref{chap:prop} efficient propagation for lazy-grounding Answer Set solving is presented.

\todo{Expand to include later chapters.}

\chapter{Preliminaries}
\label{chap:prelim}

\todo{Everything that later sections build up on. Quote a lot. This chapter can be long. Show understanding of the matter in own words (i.e. what is an answer set incl. example?).}

This chapter revisits definitions of syntax and semantics of answer set programs. Interpretations and answer sets of such programs are defined.

Apart from these formal foundations, a brief overview of state-of-the-art ASP systems is given and systems that implement lazy-grounding are observed in detail.

\section{Answer Set Programming}

In Section \ref{chap:intro} we presented an example program with an intuitive description. In this section we formally define syntactic structure and variants of logic programs, and their semantics under ASP. For a thorough introduction to ASP refer to \cite{DBLP:conf/rweb/EiterIK09}.

\subsection{Syntax}

%set of PS
%set of Consts
%set of Vars

Given a finite set of constants $\mathcal{C}$, a set of variables $\mathcal{V}$ and a finite set $\mathcal{P}$ of predicate symbols, with $\mathcal{C}$, $\mathcal{V}$, $\mathcal{P}$ pairwise disjoint, we define one of the core building blocks of ASP programs:

\begin{definition}
An \emph{atom} is an expression of the form $p(t_1, \ldots , t_n)$ where $p \in \mathcal{P}$ is a predicate symbol of arity $n \geq 0$ and $\{ t_1, \ldots , t_n \} \subseteq \mathcal{V} \cup \mathcal{C}$ are terms.
\end{definition}

Note that for atoms of arity zero, parentheses usually are omitted and that this definition of atoms does not account for function symbols as terms. Grounding the program as briefly mentioned in Section \ref{chap:intro}, we formally define the class of ground atoms, for which terms must be constants.

\begin{definition}
An atom $p(t_1, \ldots , t_n)$ is called \emph{ground} iff $\{ t_1, \ldots , t_n \} \subseteq \mathcal{C}$
\end{definition}

Atoms can be negated as usual.

\begin{definition}
A \emph{literal} is an atom $q$ or its negation $\neg q$. The symbol $\neg$ is called \emph{classical negation} or \emph{strong negation}.
\end{definition}

Programs consist of rules, which in turn can be divided into head and body. The body of a rule can again be divided into positive and negative body.

\begin{definition}
	A \emph{rule} $r$ is an expression of the form $$a \from b_1, \ldots, b_m, \fail b_{m+1}, \ldots, \fail b_n.$$ where $a, b_1, \ldots, b_n$ are literals, $\mathrm{not}$ is \emph{negation as failure} (or \emph{default negation}), $a$ is the \emph{head}, $\{ b_1, \ldots, b_m \}$ is the \emph{positive body}, denoted $\bodyf^+(r)$, and $\{ \fail b_{m+1}, \ldots, \fail b_n \}$ is the \emph{negative body} of $r$, denoted $\bodyf^-(r)$. Positive and negative body together are simply the \emph{body} of $r$, $\bodyf(r) = \bodyf^+(r)\cup \bodyf^-(r)$.
\end{definition}

Finally, we arrive at the notion of a logic program.

\begin{definition}
A \emph{(logic) program} $P$ is a finite set of rules.
\end{definition}

% disjunction, aggregates, choice rules
% easier to model programs
% beyond scope

For the scope of this work, above definition of rules is sufficient. Programs consisting only of rules of this form are called \emph{normal} programs. For example, more generally, rules with disjunctive heads $a_1 \vee \cdots \vee a_k \from \ldots$ also have interesting properties.

In practice, more syntactic constructs are used to ease modelling programs: Arithmetic expressions, aggregates allowing statements about sets (counting how many elements match some criteria, summation of numeric values, \ldots) and choice rules that encode sets of atoms for which only a given number should be in an answer set. All of these higher level concepts map to rules as defined above. For a widely accepted standard among ASP systems consider \cite{calimeri2015asp}.

%\begin{definition}[{\cite[p.~12]{DBLP:conf/rweb/EiterIK09}}]
%A \emph{normal logic program} is a set of clauses having the form $$a \leftarrow b_1, \ldots , b_m, \text{not } c_1, \ldots , \text{not } c_n \qquad (n, m \geq 0)$$ where all $a, b_i$ and $c_j$ ($1 \leq i \leq n$ and $a \leq j \leq m$) are atoms of a first order language $L$. Expressions $\text{not } c_1, \ldots , \text{not } c_n$ are called the \emph{(default) negated literals} and consist of atoms $c_j$ preceded by the negation modifier $\text{not}$. Accordingly the atoms $a_i$ are called \emph{positive literals}.
%\end{definition}

\subsection{Semantics}

An atom in the sense of ASP is a proposition with no deeper structure. It might represent some external state of affairs, e.g.~$rainy$ to indicate whether the weather is not nice or $handsome(yue)$ a statement about Yue being handsome. Their granularity or level of abstraction directly affects how detailed the world is modelled by a program, because atoms are treated as internally consistent statements and they cannot be split further.
In order to reason about the truth values of atoms in a program, we define an interpretation.

\begin{definition}
An \emph{interpretation} is a set of ground literals $I$.
\end{definition}

For the remainder of the work we assume that an interpretation $I$ is \emph{consistent}, i.e.~there is no atom $p$ with $\{p, \neg p\} \subseteq I$.

%Observe that $I$ is a set of \emph{ground} literals, i.e.~we only define an interpretation for ground atoms and a na\ddot{i}ve implementation will therefore first ground the input program. This is the root of the bottleneck.

Considering Example \ref{example}, note that $I_1 = \{ wear(G) \}$ is not an interpretation, because the atom it contains is not ground. However $I_2 = \{ wear(winterjacket) \}$ is an interpretation, because $winterjacket$ is a constant.

With this, the truth value of an atom is defined against an interpretation, which in turn is simply the set of atoms that are considered \emph{true}. Further, an interpretation also defines how default negation as failure is to be handled.

\begin{definition}
A literal $l$ is \emph{true} under an interpretation $I$ iff $l \in I$. Otherwise it is \emph{false} under $I$.% A default negated literal $\fail l$ is \emph{true} under $I$ iff $l \not \in I$, otherwise it is \emph{false}.
\end{definition}

From the truth value of individual atoms we expand to models of rules.

\begin{definition}
%positive body is positive in I and negative body is negatively in I
An interpretation $I$ is a \emph{(classical) model} of a rule $r$ iff when $\bodyf^+(r) \subseteq I$ and $\{ \neg b \mid \fail b \in \bodyf^-(r) \} \subseteq I$ then $\headf(r) \in I$, i.e.~whenever the body of $r$ is satisfied, then the head of $r$ is satisfied as well.
\end{definition}

The definition of a model generalizes to programs.

\begin{definition}
A \emph{(classical) model} of a program is an interpretation that is a model of all rules in the program.
\end{definition}

We use the Gelfond-Lifschitz reduct towards a definition of answer sets.

\begin{definition}[see {\cite[Section 2]{DBLP:conf/iclp/GelfondL88}}]
	Given a ground program $P$ and an interpretation $I$, the \emph{Gelfond-Lifschitz reduct} (or just \emph{reduct} in short) of $P$ with respect to $I$, denoted $P^I$ is defined as follows:
\begin{multline*}
P^I = \Bigl\{ a \from b_1, \ldots , b_m \mid a \from b_1, \ldots, b_m, \fail b_{m+1}, \ldots, \fail b_n \in P\\ \text{ and } \{ \neg b_{m+1} , \ldots , \neg b_n \} \subseteq I \Bigr\}
\end{multline*}
\end{definition}

With this we close with the definition of an answer set as the minimal model of the reduct.

\begin{definition}
An interpretation $I$ is an \emph{answer set} iff it is a $\subset$-minimal model of $P^I$, i.e. there is no $J \subset I$ which is also a model of $P^I$.
\end{definition}

Note that we are only interested in the particular semantics of stable models which characterizes ASP and falls into the category of \emph{multiple} model semantics. There exist other semantics, such as the \emph{perfect model} semantics in \cite{DBLP:books/mk/minker88/Przymusinski88}.

\section{State of the Art in ASP Solving}

\todo{Two Watched Literals?}

\subsection{Ground-And-Solve Approaches}

\subsubsection{\texttt{clingo}}

\texttt{clingo}\footnote{\url{https://potassco.org/clingo/}} is a ground-and-solve ASP system which combines the grounder \texttt{gringo} and the solver \texttt{clasp}. \clasp uses the 2WL strategy to implement propagation \cite[Sec.~5.3]{clasp}.

\subsection{Approaches based on Lazy Grounding}

There are two important ASP systems that implement lazy grounding, which we present for comparison.

\subsubsection{\texttt{\asperix}}
\label{sec:asperix}.

\asperix is one of the first ASP systems that were designed to avoid the grounding bottleneck. It was first prototyped in 2008\footnote{According to the project's website \url{http://www.info.univ-angers.fr/pub/claire/asperix/\#download}} and published in \ref{asperixfirst}, with a more elaborate elaborate explanation in \ref{asperix}.

In the process of finding a solution, it extends a partial interpretation \cite[Def.~4]{asperix} in form of a pair $\langle IN, OUT \rangle$ of disjoint atom sets, where the atoms in $IN$ belong to the answer set that is currently searched and the atoms in $OUT$ do not. Further, the system tracks the set of ground rules, $R$, which is lazily extended by grounding the input program. Rules of the program $r$ relate to a partial interpretation and are called \emph{supported} ($\bodyf^+(r) \subseteq IN$), \emph{blocked} ($\bodyf^-(r) \cap IN \not = \emptyset$), \emph{unblocked} ($\bodyf^-(r) \subseteq OUT$), and \emph{applicable} (supported and not blocked) \cite[Def.~5]{asperix}. 

The main concept in this ASP system is an \asperix \emph{computation} \cite[Def.~7]{asperix}: It is a sequence of pairs $\langle R_i, I_i$ that captures ground rules and a partial interpretation $I_i = \langle IN, OUT \rangle$. The computation starts with $\langle \emptyset, \langle \emptyset, \{ \bot \} \rangle \rangle$ and is inductively defined through the rules \emph{propagation} (monotonic; a new rule $r_i \not \in R_{i-1}$ can be ground from the program such that it \enquote{fires}, i.e.~its head is added to $IN$), \emph{choice} (non-monotonic; there are no rules that propagate, but the solver guesses whether an applicable rule fires, i.e. forces or prohibits ist instantiation) and \emph{stability} (no rules for propagation or choice left). Through inductive definition of computations, it is guaranteed that the sequence converges to an answer set iff there exists one \cite[Thm.~2]{asperix}.

The most important take-away from \asperix for this work, however is the introduction of a third truth value which allows for more efficient convergence of above computation: The truth value \mbt indicates that an atom that is not in already in $IN$ must be in $IN$ (cannot be in $OU$) in order to find an answer set. It allows to mark certain atoms for which a \enquote{proof}, i.e. a firing rule with the atom as its head, has not yet fired, but must, at some point in the computation, fire.

\begin{example}[{\cite[Example 7}]
Let $\bot \from \fail b$ be a constraint whose body contains only one literal $\fail b$ with $b \not \in IN \cup OUT$. In order to have an answer set, $b$ must be in $IN$ so that the constraint is not applicable but $b$ is not yet proved (it is not in the head of a fired rule). Thus, one can only conclude that $b$ must be true.
\end{example}

This leads to more a reduction of the search space in propagation \cite[Ex.~8]{asperix} and also decreases the size set of non-monotonic candidate rules for choice \cite[Ex.~9]{asperix}. Partial interpretation and computation are modified to consider \mbt in \cite[Def.~8]{asperix} and \cite[Def.~11]{asperix} accordingly. Again, there is a correspondence to answer sets \cite[Thm.~3]{asperix}.

\asperix show how lazy grounding ASP systems can leverage \mbt as a third truth value. How unit propagation is affected by \mbt is a central topic in Chapter \ref{chap:prop}.

\subsubsection{\texttt{\omiga}}

\section{Analysis}
\todo{What is this section about?}

\section{Comparison and Summary of Existing Approaches}

\chapter{Propagation for lazy-grounding Answer Set solving}
\label{chap:prop}

The central idea of propagation is to infer (\emph{propagate}) new truth values from known truth values and nogood clauses, derived from the input program, as briefly explained in \ref{sec:motivation}. 

In this chapter, we present algorithms and data structures involved in the propagation step of solving ASP programs. We adapt 2WL, a common strategy for propagation in SAT solves, and account for the truth value \mbt as motivated in \ref{sec:asperix}.

\section{Definitions}

% Signed literal vs. boolean signed literal.

Following definitions lay out the vocabulary and concepts towards an explanation of unit propagation. Most of them fundamentally depend on \emph{atoms} (usually denoted $v$) but do not refer to neither a set of atoms nor their domain. This is because all definitions are bound to a logic program $P$ to be solved (i.e.~to find answer sets for). The set of ground atoms wrt.~$P$, effectively its Herbrand Base $\textit{HB}(P)$, is obtained by the grounding process, which is not detailed in this work. What might seem to be lacking from the definitions therefore is the context of the input program $P$ and the domain of atoms. $P$ and its context is omitted in the following.

\subsection{Literals}

% TODO: Where does v come from? Should be in some HB(P)?
%\begin{definition}
%A \emph{ground atom} (or simply \emph{atom}) wrt.~a logic program $P$ is an element of $\textit{HB}(P)$, usually denoted $v$.
%\end{definition}

\begin{definition}
A \emph{boolean signed literal} $\bsgl$ of the form $\bT v$ or $\bF v$ where $v$ is an atom and  $\bT v$ expresses that $v$ is \emph{true}, and $\bF v$ that it is \emph{false}.
\end{definition}

\begin{definition}
A generalization of boolean signed literal, called a \emph{signed literal} $\sgl$ is of the form $\bT v$, $\bF v$, or $\bM v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, $\bF v$ that it is \emph{false} (equivalent to the semantics of boolean signed literals) and $\bM v$ that it \emph{must be true}.
\end{definition}

%\begin{definition}
%The function $\wkn(\bsgl)$ takes a boolean signed literal $\bsgl$ and transforms it into a signed literal referred to as its \emph{weak form}, meaning that while \emph{false} stays \emph{false}, e.g.~$\wkn(\bF v) = \bF v$, \emph{true} is mapped to \emph{\mbt}, e.g.~$\wkn(\bT v) = \bM v$.
%\end{definition}

% TODO: Remark on boolean signed literal vs. signed literal with context of clasp?

\begin{definition}
Strong complement, denoted by $\negstrong{\sgl}$, and weak complement, $\negweak{\sgl}$, mapping $\bF v$ to $\bT v$ and $\bF v$ to $\bM v$ respectively, of a signed literal are defined by the following truth table:%equalities: $\negstrong{\bT v} = \bF v$, $\negstrong{\bM v} = \bF v$ and  $\negstrong{\bF v} = \bT v$, while $\negweak{\bT v} = \bF v$, $\negweak{\bM v} = \bF v$ and $\negweak{\bF v} = \bM v$.
% "andere Richtung auch erklären"

\begin{center}
\begin{tabular}{|c|cc|}
\hline
$\sgl$&$\negstrong{\sgl}$&$\negweak{\sgl}$\\
\hline
\hline
$\bT v$&$\bF v$&$\bF v$\\
$\bM v$&$\bF v$&$\bF v$\\
$\bF v$&$\bT v$&$\bM v$\\
\hline
\end{tabular}
\end{center}
\end{definition}

\begin{definition}
Two literals $\sgl_1, \sgl_2$ are said to \emph{conflict} in case $\sgl_1 = \negweak{\sgl_2}$ or $\negweak{\sgl_1} = \sgl_2$.
\end{definition}

Occasionally the notation $\sgl = \bX v$ will be used to express that $\sgl$ is a literal of $v$ where $\bX \in \thrice$, i.e.~$\sgl$ is \enquote{bound} to $v$, but the sign is not important.

\subsection{Assignments}

Similar to \cite[section 2, p.~3]{clasp} we define assignments. However, here assignments contain not only boolean signed literals, but also signed literals and the notation for expressing a partial assignment differs.

\begin{definition}
An \emph{assignment} $\ass$ is a sequence $(\sgl_1, \ldots, \sgl_n)$ of signed literals $\sgl_i = \bX v_i$, or \emph{conflict}.
\end{definition}

%\begin{remark}
Below, assignments are sometimes also used as sets, in which case the set represented by some assignment is simply the set of all signed literals contained in the sequence.
%\end{remark}

The number of elements in an assignment $|\ass|$ is intuitive, with $|\emph{conflict}| = 0$.

A partial assignment is a sub-sequence constructed from an assignment denoted as $\ass[i,j] = (\sgl_i, \ldots, \sgl_j)$ where $\ass = (\sgl_1, \ldots, \sgl_i, \ldots, \sgl_j, \ldots, \sgl_n)$ and $1 \leq i < j \leq n$.

A single literal is referenced using $A[i] = \sgl_i$ for $1 \leq i \leq |A|$.

The assignment obtained by appending the literal $\sgl$ to $\ass = (\sgl_1, \ldots, \sgl_n)$ is denoted by $$\ass \circ \sgl = \left\{\begin{array}{ll}
        
        \emph{conflict} & \text{if } \{ \negstrong{\sgl}, \negweak{\sgl} \} \cap \ass \not = \emptyset \text{ or } \ass = \emph{conflict}\\
        %(\sgl_1, \ldots, \sgl_{n-1}, \sgl) & \text{if } \sgl = \bT v \text{ and } \bM v \in \ass \text{, i.e. appending } \bT v \text{ removes } \bM v\\
        (\sgl_1, \ldots, \sgl_{n}, \sgl) & \text{otherwise} \\
        \end{array}\right.$$

%Appending preserves that for any atom $v$ there is at most one literal in the assignment: With $\sgl = \bT v$ and $\bM v \in \ass$, for $\ass' = \ass \circ \sgl$ it holds that $\bM v \not \in \ass'$ (and $|\ass'| = |\ass|$).

%Furthermore $\emph{conflict} \circ \sgl = \emph{conflict}$ for any $\sgl$. 

\begin{definition}
For every assignment, a respective \emph{boolean assignment}, denoted $\bass(\ass)$ can be constructed by collapsing all atoms that \emph{must be true} to being \emph{true}:$$\bass(\ass) = \{ \sgl \in \ass \ | \ \sgl = \bT v \textrm{ or } \sgl = \bF v \} \cup \{ \bT v \ | \ \bM v \in \ass \}$$
\end{definition}

\begin{definition}
An atom $v$ is \emph{assigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} \not = \emptyset$$
\end{definition}

%\begin{definition}
%An atom $v$ is \emph{unassigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} = \emptyset$$
%\end{definition}

\begin{definition}
A signed literal $\bX v$ is \emph{assigned} under $\ass$ iff $v$ is assigned under $\ass$.
\end{definition}

Intuitively, atoms and literals are \emph{unassigned} under $\ass$ iff the are not assigned under $\ass$.

\begin{definition}
A literal $\sgl_1$ is said to conflict with $\ass$ in case it conflicts with any $\sgl_2 \in \ass$.
\end{definition}

\subsection{Nogoods}

\begin{definition}
A \emph{nogood} reflects a partial assignment that cannot be extended to a solution. Here, a \emph{nogood} is a set $\{ \bsgl_1, \ldots, \bsgl_n \}$ of boolean signed literals.
\end{definition}

\begin{definition}
At most one of the boolean signed literals inside a nogood might be qualified as head. The head literal $\bsgl$ of $\delta$ denoted $\headf(\delta) = \bsgl$.
\end{definition}

Note that $\headf(\delta)$ is always of the form $\bF v$. % TODO why?

\begin{definition}
Any literal in a nogood $\delta$ that is not it's head is element of the so called \emph{body} of the nogood: $\bodyf(\delta) = \{ \bsgl \in \delta \ | \ \bsgl \not = \headf(\delta) \}$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{weakly unit} under an assignment $\ass$ iff $\delta \setminus \bass(\ass) = \{ \bsgl \}$
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{strongly unit} under an assignment $\ass$ iff $\delta \setminus \ass = \{ \headf(\delta) \}$
\end{definition}

Note that, as the names suggest, any nogood that is strongly unit under some assignment is also weakly unit, but not the other way round. Below, nogoods are sometimes referred to be \emph{unit} which amounts to stating that they are weakly unit. Also, when clear from context, reference to a particular assignment is omitted.

\begin{definition}
\label{def:vio}
A nogood $\delta$ is \emph{violated} under an assignment $\ass$ iff $\delta \subseteq \bass(\ass)$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{satisfied} under an assignment $\ass$ iff there is no $\ass' \supseteq \ass$ s.t.~$\delta$ is violated under $\ass'$.
\end{definition}

For the purpose of unit propagation, it is important to see that because a satisfied nogood will never be unit, therefore never yield a new assignment using unit propagation.

\begin{definition}
A nogood $\delta$ is \emph{\upinv} under some assignment $\ass$ iff $\delta$ is not violated by $\ass$ and $\delta$ is not unit wrt.~$\ass$.
\end{definition}

Note the difference between some $\delta$ being \upinv vs.~satisfied under an assignment: With $\delta$ being \upinv under $\ass_1$, there might well be some $\ass_1' \supset \ass_1$ under which $\delta$ is unit or violated. However $\delta$ satisfied under $\ass_2$ is stronger and implies that there is no \enquote{larger} assignment $\ass_2' \supset \ass_2$ such that $\delta$ is not satisfied under $\ass_2'$ by definition. It follows that $\delta$ can neither be unit nor violated under $\ass_2'$.

When implementing propagation, na{\"i}vely obtaining checking a large set of nogoods that represents an ASP program for unity is infeasible. Sophisticated data structures are needed to make propagation sufficiently fast.

\subsection{Watch structures}

\begin{definition}
% ASK: Why not define watch structure as a function/relation mapping from atom to watch sets? Structure is irrelevant, and mapping function is closer to a map in code.
% ASK: How to omit irrelevant elements of a tuple?
A \emph{watch structure} is a function that maps atoms $v$ to triples containing sets of nogoods, the so called \emph{watch sets} of $v$: $$\Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

%For any watch set $W$ in $\Delta(v)$ and nogood $\delta \in W$ it follows that $\bX v \in \delta$.

For some signed literal $\sgl = \bX v$ let $$\dpm(\sgl) = \left\{\begin{array}{ll}
        W^+ & \text{if } \sgl = \bT v \ \text{or } \sgl = \bM v\\
        W^- & \text{if } \sgl = \bF v \\
        \end{array}\right\} \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

For some signed literal $\sgl = \bX v$ or an atom $v$ let $$\dal(\sgl) = \dal(v) = W_i^\alpha \ \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$
\end{definition}

Interpretation as a set $\Delta = \{(v_i, (W_i^+, W_i^-, W_i^\alpha)\}$ for $1 \leq i \leq n$ where $i \not = j \to v_i \not = v_j$ for $1 \leq j \leq n$ reveals how such a mapping can be stored or visualized (see figure~\ref{fig:watches}).

\begin{figure}[h]
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]
\node(s)[stack=4]  {
                 Atom     % text
\nodepart{two}   $v_1$     % two
\nodepart{three} $v_2$      % three
\nodepart{four}  \vdots % four
};

\node(v1t)[stack=3, rectangle split horizontal, above right=2cm and 3cm of s.two] {
$\delta_1$     % two
\nodepart{two} $\delta_2$      % three
\nodepart{three}  \ldots % four
};

\node(v1m)[stack=3, rectangle split horizontal, above right=1cm and 3.5cm of s.two] {
$\delta_3$     % two
\nodepart{two} $\delta_4$      % three
\nodepart{three}  \ldots % four
};

\node(v1f)[stack=3, rectangle split horizontal, above right=0cm and 4cm of s.two] {
$\delta_5$     % two
\nodepart{two} $\delta_6$      % three
\nodepart{three}  \ldots % four
};

\path (s.two east)
edge [out=east,in=west, left] node {$+$} (v1t)
edge [out=east,in=west, above] node {$-$} (v1m)
edge [out=east,in=west, above] node {$\alpha$} (v1f)
;

\end{tikzpicture}
  \caption{Example layout of a \emph{watch structure}.}
  \label{fig:watches} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

\begin{definition}
The \emph{candidate sets} of a nogood $\delta$ under an assignment $A$ are subsets of the nogood  and defined as follows:

$$\cdpm(\delta, A) = \{\bsgl \in \delta \ | \ \bsgl \not \in \bass(\ass)\}$$

$$\cdal(\delta, A) = \{ \bT v \in \bodyf(\delta) \ | \ \bT v \not \in \ass \}$$

Intuitively, $C_\alpha(\delta, A)$ is the set of positive body literals in $\delta$ that are not assigned to be $\emph{true}$.
\end{definition}

\begin{definition}

A watch structure $\Delta$ \emph{\lowinv} an assignment $\ass$ iff for every nogood $\delta \in \Delta$ holds:

\begin{enumerate}
\item $|\cdpm(\delta, A)| \geq 2$ implies there exist $\bsgl_1, \bsgl_2 \in \cdpm(\delta, A)$ such that $\bsgl_1 \not = \bsgl_2$ and $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$, and
%Older version: \item If $\delta$ is not satisfied under $\ass$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ unassigned under $\ass$, then $\delta$ is contained in exactly two distinct watch sets, e.g. $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$ with $\bsgl_1 \not = \bsgl_2$.
\item $\cdal(\delta, A) \not = \emptyset$ implies that there is exactly one $\bsgl \in \cdal(\delta, A)$ with $\delta \in \dal(\bsgl)$.
\end{enumerate}
\end{definition}

Using watch structures that watch assignments, propagation can be implemented efficiently: Given $\Delta$ watching $\ass$ and a new assignment for some atom $\sgl = \bX v$ the nogoods that are candidates for propagation are those in $\dpm(\sgl)$ (in case $\sgl \not \in A$, thus $\sgl$ changes from \emph{unassigned} to \emph{true}, \emph{\mbt} or \emph{false}) and $\dal(\sgl)$ (in case $\sgl \in A$, thus $\sgl$ changes from \emph{\mbt} to \emph{true}).

However, with $\Delta$ watching $\ass$ and extending the assignment $\ass' = \ass \circ \sgl$, now $\Delta$ does not trivially watch $\ass'$.

\begin{definition}
A watch structure $\Delta$ is said to be \welf under some assignment $\ass$ in case all nogoods $\delta \in \Delta$ are \upinv under $\ass$ and $\Delta$ \lowinv $\ass$.
\end{definition}

In the next section, a closer look at propagation will reveal that when transitioning from an assignment to the next one, watch sets can be altered efficiently to obtain a well formed watch structure for the extended assignment.

\section{Unit Propagation}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		a~signed~literal~$\sgl$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation with literal $A[j]$ and $\Delta$ with updated watches.}
  $\langle \ass_1, \Delta_1 \rangle \leftarrow \langle \ass \circ \sgl, \Delta \rangle$ \label{alg:up:circ}\\
  $i \leftarrow 1$ \label{alg:up:i}\\
  \While{$|\ass_i| \geq |A| + i$\label{alg:up:loop:begin}}{
  $\langle \ass_{i+1}, \Delta_{i+1} \rangle \leftarrow$ \textsc{UnitPropagate}($\ass_{i}$, $\Delta_{i}$, $|A| + i$) \label{alg:up:loop:prop}\\
    $i \leftarrow i + 1$ \label{alg:up:loop:incr}
  } \label{alg:up:loop:end}
  \Return{$\langle \ass_i, \Delta_i \rangle$} \label{alg:up:ret}
  \caption{\textsc{UnitPropagateAll}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:up}
\end{algorithm}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		an~index~$j$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation and $\Delta$ with updated watches.}
%  \If{$|A| < j$}{\Return{$\langle \ass, \Delta \rangle$}}
  $\sgl \leftarrow \ass[j]$ \label{alg:up:loop:lit}\\
  $\langle \ass', \Delta' \rangle \leftarrow$ \textsc{UnitPropagationUnassigned}($\ass$, $\Delta$, $\sgl$)\\
  \If{$\sgl$ is of form $\bT v$}
  {
    $\langle \ass'', \Delta'' \rangle \leftarrow$ \textsc{UnitPropagationAssigned}($\ass'$, $\Delta'$, $\sgl_i$)\\
    \Return{$\langle \ass'', \Delta'' \rangle$}
  }
  \Return{$\langle \ass', \Delta' \rangle$}
  \caption{\textsc{UnitPropagate}($\ass$, $\Delta$, $j$)}
  \label{alg:upsingle}
\end{algorithm}

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~set~of~watched~nogoods~$\Delta$,~and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation and $\Delta$ with updated watches.}
%  \ForEach{$\delta \in w_{=2}(\Delta, \sigma)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned in $\mathbf{A}$}
%    {
%      $\mathbf{A} \leftarrow \mathbf{A} \circ \negweak{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dpm(\sgl)$ \label{alg:upu:it}}
  {
    \uIf{$\delta$ is violated \label{alg:upu:vio}}
    {
      \Return{$\langle \emph{conflict}, \Delta \rangle$ \label{alg:upu:conflict}}
    }
    \uElseIf{$\delta$ is strongly unit \label{alg:upu:su}}
    {
      $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upu:su:circ}
    }
    \uElseIf{$\delta$ is weakly unit with $\bsgl$ unassigned \label{alg:upu:wu}}
    {
      $\ass \leftarrow \ass \circ \negweak{\bsgl}$ \label{alg:upu:wu:circ}
    }
    \Else%If{there is some unassigned $\sigma' \in \delta$}
    { \label{alg:upu:else}
      \ForEach{$\bsgl \in \delta$}
      {
      	$\dpm(\bsgl) \leftarrow \dpm(\bsgl) \setminus \{ \delta \}$ \label{alg:upu:rm}
 	  }\label{alg:upu:move:start}
      Let $\bsgl_1, \bsgl_2 \in C_\pm(\delta, A)$ be arbitrary\\
      $\dpm(\bsgl_1) \leftarrow \dpm(\bsgl_1) \cup \{ \delta \}$\\
      $\dpm(\bsgl_2) \leftarrow \dpm(\bsgl_2) \cup \{ \delta \}$ \label{alg:upu:move:end}\\
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateUnassigned}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upu}
\end{algorithm}

Algorithm \ref{alg:upu} exhibits how unit propagation is used to infer assignments (of either false or \mbt) from watched nogoods. 
In line 1, the input literal $\sgl$ is transformed to its weak form as lookups in $\Delta$ are always made against the set of nogoods that might propagate in case the literal \mbt, even if $\sgl$ is of $\bT x$. % Why?
In the loop spanning from line 2-13 all nogoods that are to be checked for propagation according to $\Delta$ are iterated. For any such nogood one of the following three cases holds true
\begin{enumerate}
\item it is violated, leading to the algorithm immediately returning the conflicting assignment, or
\item it is weakly unit, in which case a new assignment can be inferred from the nogood, or
\item in any other case, there must be at least two unassigned literals in $\delta$, which are to be watched for changes in assignments.
% TODO: Does not (1.) and not (2.) guarantee that there are two unassigned literals?! Nogood could be satisfied.
\end{enumerate}

In case (3.), $\Delta$ is modified in lines 8-11. As $\sgl$ is now assigned, it should not be watched for changes anymore. This is achieved by removing $\delta$ from the set of watches $\Delta(\sgl)$ and instead adding it to the set of watches for two unassigned literals in $\delta$.

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~watch~structure~$\Delta$, and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation.}
%  \ForEach{nogood $\delta \in w_{=2}(\Delta)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned}
%    {
%      $\mathbf{A} \circ \negstrong{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dal(\sgl)$}
  {
	\uIf{$\delta$ is strongly unit}
	{
	  $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upa:su:circ}
	}
    \ElseIf{$C_\alpha(\delta, A) \not = \emptyset$}
    {
      \label{alg:upa:move:start}
      $\dal(\sgl) \leftarrow \dal(\sgl) \setminus \{ \delta \}$\\
      % Choose $\bsgl \in L$ s.t.~there is no $\bsgl' \in L$ with $\ass = (\ldots, \bsgl, \ldots, \bsgl', \ldots)$.\\
      Let $\sigma \in C_\alpha(\delta, A)$ be arbitrary\\
      $\dal(\bsgl) \leftarrow \dal(\bsgl) \cup \{ \delta \}$\\
      \label{alg:upa:move:end}
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateAssigned}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upa}
\end{algorithm}

%In order to implement efficient propagation, a data

% No Unfounded Set checks -> MBT.

% Explain 2WL with MBT, propagation with MBT (pseudocode of propagation algorithm).

% Invariant
For every nogood $\delta \in \Delta$, if $\delta$ contains at least two atoms unassigned under $\ass$, then $\delta$ is contained in exactly two watch lists.
%TODO define watch list!

\begin{theorem}
Algorithm \ref{alg:up} is sound, i.e.~given an assignment $\ass$, a watch structure $\Delta$, a literal $\sgl$, and the following preconditions, it results in a new assignment $\ass'$ and a new watch structure $\Delta'$ such that all following postconditions hold:

\begin{enumerate}[label={\normalfont (\textsc{Pre}\arabic*)},ref=(\textsc{Pre}\arabic*)]
\item $\Delta$ \lowinv $A$. \label{up:sound:pre2}
\item All nogoods $\delta \in \Delta$ are silent under $\ass$. \label{up:sound:pre1}
\end{enumerate}

\begin{enumerate}[label={\normalfont (\textsc{Post}\arabic*)},ref=(\textsc{Post}\arabic*)]
\item If $\sgl$ does not conflict with $\ass$ and there are assignments that can be inferred by means of unit propagation, then: \label{up:sound:post2}
\begin{enumerate}[label={\normalfont (\alph*)},ref=\theenumi(\alph*)]
\item $\Delta'$ \lowinv $\ass'$. \label{up:sound:post2b}
\item All nogoods $\delta \in \Delta'$ are silent under $\ass'$. \label{up:sound:post2a}
\end{enumerate}
\item If a literal inferred from $\Delta$ and $\ass \circ \sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$. \label{up:sound:post3}
\item If $\sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$ and $\Delta' = \Delta$. \label{up:sound:post1}% Trivial case.
\end{enumerate}
\end{theorem}

\begin{proof}
%We show that:

%\begin{enumerate}
%\item in case $\sgl$ conflicts with $\ass$, the algorithm will return the assignment \emph{conflict} and $\Delta$ is not guaranteed to be well formed,
%\item otherwise, the resulting watch structure $\Delta$ will be well formed wrt. the resulting assignment $\ass$.
%\end{enumerate}

%In line 1 of algorithm \ref{alg:up}, $\ass$ is altered by appending the given signed literal $\sgl$. Now, $\Delta$ might not be well formed wrt.~the altered assignment $\ass'$ anymore, because there might be some nogood $\delta \in \dpm(\sgl)$. By executing algorithm \ref{alg:upu}, $\Delta$ is transformed into a well formed watch structure $\Delta'$.

Before establishing a proof for \ref{up:sound:post2} and \ref{up:sound:post3} observe the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} of Algorithm \ref{alg:up} closely:

\begin{description}
\item[Initialization] Construct $A_1$ by appending $\sgl$ to $\ass$ (ln.~\ref{alg:up:circ}). Initialize some loop counter $i = 1$ (ln.~\ref{alg:up:i}). It points at the next literal on which propagation should be performed, i.e.~initially $\sgl = \ass_1[|\ass| + 1]$. 

\item[Iteration] Let the pair $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle = \textsc{UnitPropagate}(\ass_i, \Delta_i, \ass_i[|A| + i])$ (ln.~\ref{alg:up:loop:prop}) denote the output of the $i$-th iteration which performs propagation on assignment $\ass_i$, watch structure $\Delta_i$ and literal $\ass_i[|A| + i]$ (ln.~\ref{alg:up:loop:lit}). Conversely $S_i$ can be interpreted as the input for the $i$-th iteration. Analysis of the difference between $\Delta_{i}$ and $\Delta_{i+1}$ is what resembles soundness below.

\item[Termination] Because the number of literals in all nogoods $\delta \in \Delta$ is finite, for some $i = k$ the loop invariant (ln.~\ref{alg:up:loop:begin}) is violated, i.e.~$|A| + i > |\ass_{i}|$. Intuitively, this is the case if no new assignment can be inferred ($S_{k-1} = \langle \ass_{k-1}, \Delta_{k-1} \rangle$ and $S_k = \langle \ass_k, \Delta_k \rangle$ with $\ass_{k-1} = \ass_k$) or a conflict is reached ($\ass_k = \emph{conflict}$). When the loop terminates, $\langle \ass', \Delta' \rangle = S_k$ is returned (ln.~\ref{alg:up:ret}).
\end{description}

Towards showing \ref{up:sound:post2} and \ref{up:sound:post3} by induction, assume that $\sgl$ does not conflict with $\ass$ and let $\mathcal{P}(n) = \textrm{\ref{up:sound:ind:noconflict}} \vee \textrm{\ref{up:sound:ind:conflict}}$ where

\begin{enumerate}[label=(\Roman*)]
	\item Let $\ass_n^L = \ass_n[1, |A| + n - 1], \ass_n^R = \ass_n[|A| + n, |\ass_n|]$. For each $\delta$ in $\Delta$: \label{up:sound:ind:noconflict}
		\begin{enumerate}[label=(\alph*),ref=\theenumi(\alph*)]
			\item $\Delta_n$ watches $\ass^L_n$. \label{up:sound:ind:watches} % Or watches \ass^L_n?
			\item If $\delta$ is weakly unit under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:wu}
			\item If $\delta$ is strongly unit under $\ass_n$, then $\exists {\bT v_1} \in A_n^R : \delta \in \Delta_n^\alpha(v_1)$ or $\exists {\bF v_2} \in A_n^R : \delta \in \Delta_n^\pm({\bF v_2})$. \label{up:sound:ind:su}
			\item If $\delta$ is violated under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:vio}
		\end{enumerate}
	\item $\ass_n = \emph{conflict}$ \label{up:sound:ind:conflict}
\end{enumerate}

\paragraph{Base Case} Concerning the input assignment $\ass_0 = \ass$ and $\Delta_0 = \Delta$, $\mathcal{P}(0)$ directly follows, because \ref{up:sound:ind:watches} amounts to \ref{up:sound:pre2}, and \ref{up:sound:pre1} implies that the antecedents of \ref{up:sound:ind:wu}, \ref{up:sound:ind:su}, \ref{up:sound:ind:vio} are false.

%The induction step now consists of observing that the loop in lines 3-10 \enquote{preserves} properties (1.) and (2.) of soundness, i.e.~it argues the transitivity of those properties for iteration steps $S_{i}$ to $S_{i+1}$.

%We show that every nogood $\delta \in \Delta'$ is \welf wrt.~$\Delta'$ and $\ass'$, i.e.~$\Delta'$ is \welf wrt.~$\ass'$, by using that $\Delta$ is \welf wrt.~$\ass$ and the definition of the algorithm.

\paragraph{Induction Hypothesis} $\mathcal{P}(i)$ holds for some $i$.

\paragraph{Induction Step} For two consecutive iteration steps $S_{i} = \langle \ass_{i}, \Delta_{i} \rangle$ and $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle$, assume $\mathcal{P}(i)$. For readability, let $j = |A| + i$, $\ass_i^L = \ass_i[1, j - 1]$, $\ass_i^R = \ass_i[j, |\ass_i|]$, $\ass_{i+1}^L = \ass_i[1, j]$, $\ass_{i+1}^R = \ass_i[j + 1,|\ass_{i+1}|]$, $\sgl_i = A_i[j]$. Then show $\mathcal{P}(i) \to \mathcal{P}(i + 1)$ as follows:

\paragraph{Intuition} $\ass_i^R$ is the \enquote{right} subsequence of the assignment, which contains all assignments that already are processed and will not cause propagation. Conversely, $\ass_i^L$ is the \enquote{left} subsequence, and contains all the literals that might still cause unit propagation. Note that $\sgl_i \not \in \ass_i^L$, $\sgl_i \in \ass_i^R$ and $\sgl_i \in \ass_{i+1}^L$, $\sgl_i \not \in \ass_{i+1}^R$, intuitively in the $i$-th iteration, $\sgl_i$ \enquote{moves} from the \enquote{right} subsequence of the assignment to its \enquote{left} subsequence. As expected, the two subsequences united add up to the full sequence $A_i = A_i^L \cup A_i^R$. Further the \enquote{right} subsequence \enquote{grows} (with the exception of $\sgl_i$), i.e.~$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$. Also, $\ass_{i+1}^L = \ass_{i}^L \cup \{ \sgl_i \}$ is useful.

\todo{$\Delta$ as the set of all nogoods in the program?}

\begin{enumerate}
\item To show \ref{up:sound:ind:watches}: $A_i^L$ differs from $A_{i+i}^L$ only by $\sgl_i$, which is processed by Algorithm \ref{alg:up}. Note that for two watches $\Delta_{i}$ and $\Delta_{i+1}$ containing the same nogoos $\Delta$, the size of candidate sets (bot $\cdpm$ and $\cdal$) for all nogoods in $\Delta$ monotonically decreases as the size of the assignment $A_i^L$ respectively $A_{i+i}^L$ increases. This follows from the definition of candidate sets.
\begin{enumerate}
	\item Assume $\sgl_i \not = \bT v$. Then Algorithm \ref{alg:upu} is invoked and processes all nogoods $\delta \in \dpm(\sgl)$. For any $\delta$, if $|\cdpm(\delta, A)| \geq 2$, then $\delta$ is inserted into the watches for exactly two candidates in lines \ref{alg:upu:move:start}-\ref{alg:upu:move:end}.
	\item Assume $\sgl_i = \bT v$. Then Algorithm \ref{alg:upa} is invoked and processes all nogoods $\delta \in \dal(\sgl)$. For any $\delta$, if $|\cdal(\delta, A)| \not = \emptyset$, then $\delta$ is inserted into the watches for exactly one candidate in lines \ref{alg:upa:move:start}-\ref{alg:upa:move:end}. 
\end{enumerate}

If $\sgl_i \in \Delta$ then the premises of the \enquote{watch} property regarding candidate sets are false, or pointers were moved such that $\sgl_i$ does not watch $\delta$ anymore.

\item To show \ref{up:sound:ind:wu}, let $\delta \in \Delta$ and assume $\delta$ is weakly unit under $\ass_{i+1}$ (else, \ref{up:sound:ind:wu} trivially holds):
\begin{enumerate}
	\item Assume $\delta$ is weakly unit under $\ass_i$. \label{pr:corr:wu:wu}
	
	Then $\exists \sgl \in \ass_i^R : \delta \in \Delta_i^\pm(\sgl)$ by the induction hypothesis. 
	
	Assume towards contradiction that $\sgl = \sgl_i$. As $\delta \in \dpm_i(\sgl)$, the weak complement of $\sgl$ is appended to the assignment (Algorithm \ref{alg:upu}, line \ref{alg:upu:wu:circ}), thus $\negweak{\sgl} \in A_{i+1}$. Then $\delta$ is not weakly unit under $A_{i+1}$ contradicting our assumption.
	
	Therefore, $\sgl \not = \sgl_i$. From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$. Further, we see that $\delta \in \dpm_{i}(\sgl)$ implies $\delta \in \Delta_{i+1}^\pm(\sgl)$ because of the behavior of Algorithm \ref{alg:upu} in case $\sgl \not = \sgl_i$ and $\delta$ being weakly unit: The set of nogoods that are considered for processing is indicated in line \ref{alg:upu:it} and consists of exactly those nogoods that are element of $\dpm_{i}(\sgl)$. From $\sgl \not = \sgl_i$ we know that the algorithm will not consider $\delta$ an specifically not add or remove it from any watch set $\dpm$. Thus we have $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:wu} holds.
%\end{enumerate}
	\item Assume $\delta$ is not weakly unit under $A_i$.
	
	Then $\cdpm(\delta, \ass_{i}) \geq 2$ and because $\Delta_i$ watches $A_i$ (ind.~hyp.), we have $\exists \bsgl_1, \bsgl_2 \in \delta : \bsgl_1 \not = \bsgl_2 \wedge \delta \in \Delta_i^\pm(\bsgl_1) \wedge \delta \in \Delta_i^\pm(\bsgl_2)$. We distinguish on whether $\sgl_i$ coincides with one of the watched literals:

	\begin{enumerate}
		%\item Assume $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$ towards a contradiction. As $\bsgl_1, \bsgl_2 \in \cdpm(\delta, \ass_i)$, both $\bsgl_1, \bsgl_2$ are unassigned under $\ass_i$ by definition of $\cdpm$. For $\delta$ to be weakly unit under $\ass_{i+1}$, there must be exactly one $\bsgl' \in \delta$ unassigned under $\ass_{i+1}$.
		\item Case $\sgl_i \not = \bsgl_1 \wedge \sgl_i \not = \bsgl_2$.
		
		$\Delta_i^\pm(\bsgl_1) = \Delta_{i+1}^\pm(\bsgl_1)$ and $\Delta_i^\pm(\bsgl_2) = \Delta_{i+1}^\pm(\bsgl_2)$, as watch sets are only modified in case $\bsgl_1 = \sgl_i$ and respectively $\bsgl_2 = \sgl_i$ (see Algorithm \ref{alg:upu}: only nogoods that are being iterated over in line \ref{alg:upu:it} are being removed from any watch sets in line \ref{alg:upu:rm}). Both $\bsgl_1$ and $\bsgl_2$ are in $A_{i+1}^R$, because $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, thus we have \ref{up:sound:ind:wu}.
		
		\item Case either $\sgl_i = \bsgl_1$ or $\sgl_i = \bsgl_2$.
		\label{sigmaprimes}		
		
		Without loss of generality ($\bsgl_1$ and $\bsgl_2$ arbitrary in $\cdpm(\delta, \ass_i)$), let $\sgl_i = \bsgl_1$. Therefore, $\bsgl_1 \not \in A_{i+1}^R$ and $\bsgl_2 \in A_{i+1}^R$. While processing $\delta$, in Algorithm \ref{alg:upu} the branch in line \ref{alg:upu:else} is taken (otherwise $\delta$ cannot be unit under $\ass_{i+1}$. All candidates $\cdpm(\delta, \ass_i)$ except $\bsgl_1$, and therefore any literals $\bsgl_1', \bsgl_2'$ (arbitrarily) chosen in the algorithm, are either unassigned under $\ass_{i+1}$ or in $\ass_{i+1}^R$. As $\delta$ is unit under $\ass_{i+1}$, exactly one of these must be unassigned.
		Assume (w.l.o.g., symmetric) $\bsgl_1'$ unassigned under $A_{i+1}$ and $\bsgl_2' \in \ass_{i+1}^R$. Then \ref{up:sound:ind:wu} holds for $\bsgl_2'$.
		
		\item Case $\bsgl_1 = \sgl_i \wedge \bsgl_2 = \sgl_i$ is impossible because $\bsgl_1 \not = \bsgl_2$.
		\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:su}, let $\delta \in \Delta$ and assume $\delta$ is strongly unit (and therefore also weakly unit or $\headf(\delta) = \bM v$) under $\ass_{i+1}$ (else, \ref{up:sound:ind:su} trivially holds):
\begin{enumerate}
	\item Case $\delta$ is strongly unit under $\ass_i$. Then $\exists {\bT v_1} \in \ass_i^R : \delta \in \dal_i(v_1)$ or $\exists {\bF v_2} \in \ass_i^R : \delta \in \dpm_i({\bF v_2})$ via induction hypothesis.
	\begin{enumerate}
		\item Case $\sgl_i = {\bT v_1}$. Then Algorithm \ref{alg:upa} appends the strong complement of the head (line \ref{alg:upa:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
		\item Case $\sgl_i = {\bF v_2}$. Then Algorithm \ref{alg:upu} appends the strong complement of the head (line \ref{alg:upu:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
			%\item Case $\sgl_i = {\bT v_1} \wedge \sgl_i = {\bF v_2}$ is contradictory. \contradiction % Amounts to the case where $\sgl_i = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$ because algorithm \ref{alg:upu} is executed before algorithm \ref{alg:upa}, which degrades to a no-operation, because $\delta$ is neither strongly unit, nor is $C_\alpha(\delta, A)$ (where $A$ is defined in the scope of the algorithm, a hybrid state between $A_i$ and $A_{i+1}$) non-empty when it is executed.
		\item Case $\sgl_i \not = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$.
		From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that if ${\bT v_1}, {\bF v_2}$ exist, they are in $\ass_{i+1}^R$. Also, $\delta \in \dal_i(v_1)$ implies $\delta \in \dal_{i+1}(v_1)$ and $\delta \in \dpm_i({\bF v_2})$ implies $\delta \in \dpm_{i+1}({\bF v_2})$ because $\delta$ is strongly unit and $\sgl_i \not \in \delta$. So we have $\exists {\bT v_1} \in \ass_{i+1}^R : \delta \in \dal_{i+1}(v_1)$ or $\exists {\bF v_2} \in \ass_{i+1}^R : \delta \in \dpm_{i+1}({\bF v_2})$, i.e.~\ref{up:sound:ind:su}. % TODO: \sgl might actually change (pointer move) which is not mentioned here. If this does not get mentioned in the watches section of the proof, add a remark here explaining that \sgl might change in the course of algorithm 3.3 but only in a way that fulfills above criteria.
	\end{enumerate}
	
	
	\item Case $\delta$ is not strongly unit under $A_i$. Then, $\bodyf(\delta) \setminus A_i \not = \emptyset$.


	\begin{enumerate}
		\item Case ${\bT v} \in \bodyf(\delta) \setminus A_i$.
		
		Then, $C^\alpha(\delta, A_{i}) \not = \emptyset$. Because $\Delta_i$ watches $\ass_i$ it follows that $\exists \bsgl \in C_\alpha(\delta, A_i): \delta \in \dal(\sigma)$.
		
		\begin{enumerate}
			\item Case $\sgl_i = \bsgl$.
			
			leads to a contradiction ($\delta$ not strongly unit under $A_{i+1}$)
			
			\item Case $\sgl_i \not = \bsgl$.
			
			$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, we have $\bsgl \in \ass_{i+1}^R$, thus $\exists \bsgl \in \ass_{i+1}^R : \delta \in \dal_{i+1}(\bsgl)$, i.e.~\ref{up:sound:ind:su}. \todo{Why $\delta \in \dal_{i+1}(\bsgl)$?}
		\end{enumerate}			
			
		\item Case ${\bT v} \not \in \bodyf(\delta) \setminus A_i$.
			\begin{enumerate}
				\item Case $\negweak{\headf(\delta)} \not \in A_{i} \wedge \negstrong{\headf(\delta)} \not \in A_{i}$, i.e.~the head is unassigned. Then there are at least two literals in $\delta$ unassigned under $A_i$ (one in the body and the head). From \ref{up:sound:ind:watches} we have $\bsgl_1, \bsgl $
				\item Case $\negweak{\headf(\delta)} \in A_{i}$.
				If $|\bodyf(\delta) \setminus A_i| \geq 2$, then there are at least two unassigned literals. Else if $\bodyf(\delta) \setminus A_i = \{ {\bF v} \}$, then $\delta$ is weakly unit.
			\end{enumerate}
	\end{enumerate}


%	\begin{enumerate}
%		\item Case $\bT v \in \bodyf(\delta) \setminus A_i$. If $\headf(\delta) \not \in A_i$ then there are at least two distinct literals $\bsgl_1, \bsgl_2 \in \delta$ (one in the body, and the head) that are unassigned unter  $A_i$ and \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$. Else, i.e.~$\headf(\delta) \in A_i$, then $|\bodyf(\delta) \setminus A_i| \geq 2$, thus \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$.
%		\item Case $\bodyf(\delta) \setminus A_i = \{ \bF v' \}$, i.e.~$\delta$ is weakly unit under $A_i$, then according to \ref{up:sound:ind:wu}, $\exists \ \bsgl \in \bass(A_i^R) : \delta \in \Delta_i^\pm(\bsgl)$. From $A_i^R \cap \delta \subseteq \{ \bF v' \}$ follows that $v = v'$ and thus \ref{up:sound:ind:su}.
%	\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:vio}, let $\delta \in \Delta$ and assume $\delta$ is violated under $A_{i+1}$ (else \ref{up:sound:ind:vio} trivially holds).
\begin{enumerate}
\item Assume $\delta$ is violated under $A_i$.

Then $\exists \sgl \in \ass_i^R : \delta \in \dpm_i(\sgl)$ via induction hypothesis.
\begin{enumerate}
\item Case $\sgl = \sgl_i$.

Then, according to Algorithm \ref{alg:upu} (line \ref{alg:upu:conflict}) $A_{i+1} = \emph{conflict}$, so \ref{up:sound:ind:conflict} holds.

\item Case $\sgl \not = \sgl_i$.

Then, from $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$, thus $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$. Also $\delta \in \dpm_i(\sgl)$ implies $\delta \in \dpm_{i+1}(\sgl)$, as watch sets are only modified for nogoods that are watched by $\sgl_i$. So we have $\exists \sgl \in \ass_i^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:vio} holds.
\end{enumerate}
\item Assume $\delta$ is not violated under $A_i$. Then $|\bass(A_i) \setminus \delta| \geq 1$  holds by Definition \ref{def:vio}.

\begin{enumerate}
\item Assume $|\bass(A_i) \setminus \delta| \geq 2$. Then because $\Delta_i$ watches $A_i$ it follows that $\exists \bsgl_1, \bsgl_2 : \delta \in \Delta_i^\pm(\bsgl_1), \Delta_i^\pm(\bsgl_2)$. Further $\bsgl_1 \not = \sgl_i$ or $\bsgl_2 \not = \sgl_i$, so w.l.o.g.~$\bsgl_1 \not = \sgl_i$, so $\exists \ {\bX v} \in X : \delta \in \Delta_{i+1}^\pm(v)$ with a reasoning similar to \ref{sigmaprimes}.

\item Assume $|\bass(A_i) \setminus \delta| = 1$. Then $\delta$ is weakly unit under $A_i$, thus this case amounts to \ref{pr:corr:wu:wu}.
\end{enumerate}

\end{enumerate}

\end{enumerate}

\begin{comment}
\begin{enumerate}
\item If $\sgl_i \not \in \delta$, then: % A nogood only contains boolean signed literals, so dies this even make sense? \sgl is a signed literal, not a boolean signed literal, so how can it be element of delta? Needs clarification.
\begin{enumerate}
\item $\delta$ is not violated under $\abef$ (inv1). Therefore, $\delta$ is not violated under $\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item $\delta$ is not unit wrt.~$\abef$ (inv2). Therefore, $\delta$ is not unit wrt.~$\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned wrt.~$\aaf$. Then $\bsgl_1$ and $\bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied under $\abef$, because $\abef \subset \aaf = \abef \circ \sgl_i$ and $\sgl_i \not \in \delta$. Therefore, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ must hold (inv3). For the same two literals, $\delta \in \daf^\pm(\bsgl_1)$ and $\delta \in \daf^\pm(\bsgl_2)$ holds. % Needs clarification. Reference the loop that the nogood is certainly not part of.
\item Analogous to (c), if $\delta$ has any triggers, their assignment does not change, as $\sgl_i \not \in \delta$, and no watches $\delta \in \dbef^\alpha(\bsgl)$ are changed. The same $\bsgl$ will satisfy $\delta \in \dbef^\alpha(\bsgl)$ for $\abef$ and $\aaf$.
\end{enumerate}
\item Else ($\sgl_i \in \delta$):
\begin{enumerate}
\item If $\delta \not \in \dbef^\pm(\sgl_i)$, i.e.~$\delta$ was not watched on $\sgl_i$, then
\begin{enumerate}
\item To show that $\delta$ is not violated by $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not violated under $\aaf$ as $\delta$ is not violated by $\abef$ (inv1) and $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals in $\delta$ unassigned wrt.~$\abef$ as $\delta$ is not unit wrt.~$\abef$ (inv2). From $|\aaf| = |\abef| + 1$ if follows that there must be at least one literal in $\delta$ which is unassigned wrt.~$\aaf$, therefore $\delta$ cannot be violated under $\aaf$.
\end{enumerate}
\item To show that $\delta$ is not unit under $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not unit under $\aaf$ because $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ that are unassigned wrt.~$\abef$, as $\delta$ is not unit under $\abef$ (inv2). Further, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ (inv3). From $\delta \not \in \dbef^\pm(\sgl_i)$ it follows that $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$. % How are binary signed literals and signed literals compared?
Therefore $\delta$ is not unit, because $\bsgl_1, \bsgl_2 \in \delta$ are unassigned wrt.~$\aaf$.
\end{enumerate}
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned under $\aaf$. Then $\bsgl_1, \bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied wrt.~$\abef$ because $\abef \subset \aaf$ and $\delta \not \in \dbef^\pm(\sgl_i)$ and $\delta$ is not unit wrt.~$\abef$.
\item Same as 1.d ...
\end{enumerate}
\item Else ($\delta \in \dbef^\pm(\sgl_i)$), i.e.~$\delta$ was watched on $\sgl_i$.
\begin{enumerate}
\item If $\delta$ is weakly unit under $\aaf$ with $\bsgl$ unassigned, then the algorithm generates the assignment $\negweak{\bsgl}$.
\item Else
\item If there are two unassigned pointer move $\to$ two unassigned literals
\item pointer move $\to$ two unassigned literals
\item violated $\to$ conflict
\item weakly unit $\to$ satisfied
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{comment}

Above induction step serves as an explanation on how execution of the loop affects the assignment and especially the watch structure. By using induction, $\mathcal{P}(i)$ was shown for any $i \geq 0$, and therefore for any iteration of the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} as well. Specifically $\mathcal{P}(i)$ holds for the last iteration $i = k$ represented by $S_k = \langle \ass_k, \Delta_k \rangle$.

For cases without conflict and the loop terminating at $S_k$, \ref{up:sound:post2b} is obvious from \ref{up:sound:ind:watches} as $\ass' = \ass_k$ and $\Delta' = \Delta_k$. From termination follows $A_k^R = \emptyset$, i.e.~there are no nogoods $\delta \in \Delta'$ that are weakly unit, strongly unit or violated under $\ass'$, thus all $\delta$ are silent under $\ass'$ which amounts to \ref{up:sound:post2a}.

Cases in the induction step leading to show \ref{up:sound:ind:conflict} map to \ref{up:sound:post3}.

To show \ref{up:sound:post1} rather trivially: Assume $\sgl$ conflicts with $\ass$. Then, on line~\ref{alg:up:circ} of the algorithm $\ass$ will be assigned \emph{conflict}. Consequently, the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} is not executed as $|\emph{conflict}| = 0$ and $i$ must be at least 1, as it is assigned 1 on line \ref{alg:up:i}. $\langle \ass, \Delta \rangle$ is returned.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is complete.
\end{theorem}

\begin{proof}
Indirect proof, showing that if there is an assignment that results from propagation it will be generated.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is sound and complete.
\end{theorem}

\begin{proof}

\end{proof}

\chapter{Implementation}

\section{Benchmarks}

\chapter{Conclusion}

\section{Related Work}

\section{Conclusion}

\subsection{Related Work}

\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
\printglossaries

% Add a bibliography.
\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}

