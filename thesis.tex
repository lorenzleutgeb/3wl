\documentclass{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amsthm}
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage{enumitem}   % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
%\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last.
\usepackage{lmodern}% http://ctan.org/pkg/lmodern
\usepackage{xspace}
\usepackage{marvosym}
\usepackage[numbers,longnamesfirst]{natbib}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{shapes.multipart,calc}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}

% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Lorenz Leutgeb} % The author name without titles.
\newcommand{\thesistitle}{Three Watched Literals} % The title of the thesis. The English version should be used, if it exists.
\newcommand{\thesissubtitle}{Efficient Propagation for Lazy-Grounding Answer~Set~Programming Systems} % The title of the thesis. The English version should be used, if it exists.

\hypersetup{
    pdfpagelayout   = TwoPageRight,
    linkbordercolor = {1 0.8 0.8}, %TODO change this to Melon when finished.
    pdfauthor       = {\authorname},
    pdftitle        = {\thesistitle},
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {asp, solver, propagation, nogood}
}

\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

\makeindex      % Use an optional index.
%\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Prof.~Dr.}{Thomas Eiter}{}{male}

% For bachelor and master theses:
\setfirstassistant{Dr.}{Antonius Weinzierl}{}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

\setaddress{Engilgasse 3a, 1160 Wien}
\setregnumber{1127842}
\setdate{31}{10}{2016} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{\thesistitle} % Sets English and German version of the title (both can be English or German).
\setsubtitle{\thesissubtitle}{\thesissubtitle} % Sets English and German version of the subtitle (both can be English or German).

\setthesis{bachelor}

\setcurriculum{Software \& Information Engineering}{Software \& Information Engineering} % Sets the English and German name of the curriculum.

% Define convenience macros.
\newcommand{\todo}[1]{{\color{red}\textbf{TODO: {#1}}}} % Comment for the final version, to raise errors.

\newtheorem{example}{Example}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[theorem]
\newtheorem{corollary}{Corollary}[theorem]

\newtheorem*{remark}{Remark}

\newcommand{\mbt}{must-be-true\xspace}
\newcommand{\negstrong}[1]{\overline{#1}^s}
\newcommand{\negweak}[1]{\overline{#1}^w}

% Function B transforming an assignment into a boolean assignment.
\newcommand{\bass}{\mathcal{B}}

% An assignment A.
\newcommand{\ass}{A}

% Herbrand Base function of some logic program.
\newcommand{\hb}{\textit{HB}}

\newcommand{\bT}{\mathbf{T}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\fabef}{\ass_{i}}
\newcommand{\faaf}{\ass_{i + 1}}
\newcommand{\abef}{\fabef{k + i}}
\newcommand{\aaf}{\faaf^{k + i + 1}}
\newcommand{\dbef}{\Delta_{i}}
\newcommand{\daf}{\Delta_{i+1}}
\newcommand{\contradiction}{\Lightning}
\newcommand{\cdpm}{C_\pm}
\newcommand{\cdal}{C_\alpha}
\newcommand{\dpm}{\Delta^\pm}
\newcommand{\dal}{\Delta^\alpha}

\newcommand{\righta}[1]{\ass_{#1}[{#1}, |\ass_{#1}|]}
\newcommand{\lefta}[1]{\ass_{#1}[0, {#1-1}]}

\newcommand{\welf}{well formed\xspace}
\newcommand{\upinv}{silent\xspace}
\newcommand{\lowinv}{watches\xspace}
\newcommand{\stbl}{stable\xspace}

\newcommand{\headf}{H}
\newcommand{\bodyf}{B}

\newcommand{\fail}{\mathrm{not } \ \xspace}
%\newcommand{\from}{\mathrm{\ \xspace :- \ \xspace}}
\newcommand{\from}{\ensuremath{\leftarrow}}
\newcommand{\problem}{\ensuremath{\mathscr{P}}}

\newcommand{\entails}{\models}

% Least model (of a Horn program).
\newcommand{\lm}{\mathrm{lm}}

% Set of stable models (of a program).
\newcommand{\stm}{\mathrm{STM}}
\newcommand{\sol}{\mathrm{Sol}}
\newcommand{\compl}{\mathrm{Co}}
\newcommand{\groundext}{\mathrm{Gr}}
\newcommand{\defense}{\mathrm{Def}_F}

% Entails according to well founded semantics.
\newcommand{\wf}{\ensuremath{\entails_{wf}}}

% Entails according to stable model semantics using brave reasoning
\newcommand{\brave}{\ensuremath{\entails_{st}^b}}

% Entails according to stable model semantics using cautious reasoning
\newcommand{\caut}{\ensuremath{\entails_{st}^c}}

% Selective Linear Definite-clause with Negation as Failure
\newcommand{\sldnf}{\ensuremath{\vdash_{NF}}}

\newcommand{\universe}{\mathcal{U}}
\newcommand{\afs}{\mathcal{F}}
\newcommand{\attacks}{\rightsquigarrow}

\newcommand{\sgl}{\mu}
\newcommand{\bsgl}{\sigma}

\newcommand{\thrice}{{\{\bT, \bM, \bF \}}}

\newcommand{\wkn}{\textit{weaken}}

\newcommand{\asperix}{\texttt{ASPeRiX}\xspace}
\newcommand{\clasp}{\texttt{clasp}\xspace}
\newcommand{\dlv}{\texttt{dlv}\xspace}
\newcommand{\omiga}{\texttt{OMiGA}\xspace}

\usepackage[autostyle=false,style=american]{csquotes}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian}
\addtitlepage{english}
\addstatementpage

\begin{acknowledgements*}
I would like to thank Antonius Weinzierl for his consistent and continuous efforts in supporting me writing this thesis through numerous meetings, openness in discussion, acceptance of my contributions to the Alpha system and finding the right balance between pushing me to finish and letting me slack off to think freely.
\end{acknowledgements*}

\begin{kurzfassung}
Answer Set Programming (ASP; \cite{stable}) ist eine deklarative Programmiersprache in Anlehnung an Prädikatenlogik erster Stufe, welche üblicherweise durch ASP-Systeme evaluiert wird. Wir präsentieren das \emph{grounding bottleneck}, um die Limitationen aktueller ASP-Systeme aufzuzeigen und diskutieren mögliche Lösungsansätze mit einem Fokus auf \emph{lazy-grounding} wie im Alpha System.

Der Komppromiss zwischen Speicherverbrauch und vollständiger Verfügbarkeit des grundierten Programms resultiert in neuen Restriktionen für Algorithmen und Datenstrukturen in ASP-Systemen. Der Hauptteil der Arbeit beschreibt wie \emph{Unit Propagation} basierend auf \emph{two-watched-literals} auf drei Literale erweitert werden kann, sodass Berechnungen mit einem teilweise grundierten Programm ausgeführt werden können.
\end{kurzfassung}

\begin{abstract}
Answer Set Programming (ASP) is a declarative programming language rooted in first order logic that is commonly evaluated using ASP systems. We present the \emph{grounding bottleneck}, which is exhibits limitations of state-of-the-art ASP systems and discuss possible approaches, with a focus on \emph{lazy-grounding} as implemented in the Alpha system.

Trading off memory consumption for complete availability of the ground program poses new design constraints on algorithms and data structures in ASP systems. The main part of the work describes how \emph{unit propagation} based on \emph{two-watched-literals} can be extended to three watched literals in order to account for a lazily grounded program.
\end{abstract}

\selectlanguage{english}

\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}
\label{chap:intro}

Since the inception of computer programming, different ways of encoding algorithms, structuring data and modeling the real world in computer programs have led to the development of various conceptually diverse programming languages. Families of programming languages that share some properties are usually grouped into so called \enquote{programming paradigms}.
Such paradigms describe the common, most important concepts and lay a framework for a family of languages.

The most widely used languages follow the \enquote{imperative} programming paradigm (some more strict, some less), which revolves around \enquote{commanding} the computer. In this work, in contrast to mainstream software engineering, the main focus is Answer Set Programming (ASP), a declarative programming paradigm that roots in first order logic.

Without going into further details about how ASP \enquote{works}, consider the following example for an intuition.

\begin{example}
\label{ex:garments}
Suppose one needs to decide what to wear. The following program narrows down the selection of garments in the wardrobe by checking whether specific pieces are designed to be worn in the current season. For the sake of the example we assume that it is summer.
%rule with two vars
%allowdisplaybreaks?
\begin{align}
garment(winterjacket)\from& \ .\label{ex:garments:garments:begin}\\
garment(jeans)\from& \ .\\
garment(tshirt)\from& \ .\\
garment(shorts)\from& \ .\label{ex:garments:garments:end}\\
warm(winterjacket)\from& \ .\label{ex:garments:style:begin}\\
light(shorts)\from& \ .\label{ex:garments:style:end}\\
summer\from& \ .\label{ex:garments:season}\\
inseason(G) \from& \ winter, garment(G),~\fail light(G). \label{ex:garments:inseason:begin}\\
inseason(G) \from& \ summer, garment(G),~\fail warm(G). \label{ex:garments:inseason:end}\\
wear(G) \from& \ garment(G), inseason(G). \label{ex:garments:wear}\\
\from& \ winter, summer. \label{ex:garments:seasons}
\end{align}

In lines \ref{ex:garments:garments:begin} to \ref{ex:garments:garments:end} we list the four pieces we have in the wardrobe (a winter jacket, a pair of jeans, a t-shirt and shorts) and in lines \ref{ex:garments:style:begin} to \ref{ex:garments:style:end} garments that are warm or light are qualified. The current season is encoded in line \ref{ex:garments:season}. Using the two inference rules in lines \ref{ex:garments:inseason:begin} and \ref{ex:garments:inseason:end} we define when a garment is \enquote{in season}, i.e.~whether a piece is not light (resp.~not warm) which means it should be worn in winter (resp.~summer). Finally, we express that a garment can be worn in case it is in season on line \ref{ex:garments:wear}. Line \ref{ex:garments:seasons} models a constraint: It is unreasonable that it is both winter and summer for one evaluation of the program.
\end{example}

The evaluation of an ASP program is done by an ASP system, which may be comprised of further components. For \enquote{user} and programmer, no detailed knowledge about the system is required. The abstract input/output behaviour of these systems is enough to use them in most cases: Given an input program (and sometimes a few options on which algorithms or data structures to employ) it computes the answer sets. Loosely speaking, answer sets are possible combinations of values that satisfy all requirements that are stated in the program.

% benuetzen gleiche techniken, es hat sich gezeigt, dass techniken aus dem sat bereich effizient sind

Many ASP system implementations use solving algorithms closely related to those found in boolean satisfiability (\cite{sat}, SAT) solvers to search for answer sets. Finding an answer set for a logic program, which means exploring truth assignments for atomic expressions under the rules defined in the program, is similar to finding a satisfying assignment for a formula, which means exploring possible truth values for constants under the structure of the formula. Adapting SAT solvers and their methods turned out to be highly effective for solving ASP. To keep up this close relation however, one key difference between formulas in SAT and programs in ASP must be accounted for: Formulas in SAT do not have variables, but logic programs do. Variables such as \emph{G} in the above example must be removed. The process of substituting variables with constants, e.g. substituting \emph{G} with one of the four concrete garments, is referred to as \emph{grounding} and the resulting variable-free program is said to be \emph{ground}.

\begin{example}
\label{ex:garmentsground}
Reconsider Example \ref{ex:garments}. Na{\"i}vely substituting each occurrence of \emph{G} in the example yields eight instances of the \emph{inseason} rule (two per garment), and four of the \emph{wear} rule (one per garment).
\begin{align}
garment(winterjacket)\from& \ .\label{ex:garmentsground:garments:begin}\\
garment(jeans)\from& \ .\\
garment(tshirt)\from& \ .\\
garment(shorts)\from& \ .\label{ex:garmentsground:garments:end}\\
warm(winterjacket)\from& \ .\label{ex:garmentsground:style:begin}\\
light(shorts)\from& \ .\label{ex:garmentsground:style:end}\\
summer\from& \ .\label{ex:garmentsground:season}\\
inseason(winterjacket) \from& \ winter, garment(winterjacket),\\
& \ \ \fail light(winterjacket). \label{ex:garmentsground:inseason:begin}\\
inseason(jeans) \from& \ winter, garment(jeans), \fail light(jeans).\\
inseason(tshirt) \from& \ winter, garment(tshirt), \fail light(tshirt).\\
inseason(shorts) \from& \ winter, garment(shorts), \fail light(shorts).\\
inseason(winterjacket) \from& \ summer, garment(winterjacket),\\
& \ \ \fail warm(winterjacket).\\
inseason(jeans) \from& \ summer, garment(jeans), \fail warm(jeans).\\
inseason(tshirt) \from& \ summer, garment(tshirt), \fail warm(tshirt).\\
inseason(shorts) \from& \ summer, garment(shorts), \fail warm(shorts). \label{ex:garmentsground:inseason:end}\\
wear(winterjacket) \from& \ garment(winterjacket), inseason(winterjacket).\\
wear(jeans) \from& \ garment(jeans), inseason(jeans).\\
wear(tshirt) \from& \ garment(tshirt), inseason(tshirt).\\
wear(shorts) \from& \ garment(shorts), inseason(shorts).\\
\from& \ winter, summer. \label{ex:garmentsground:seasons}
\end{align}
With rules that use two garments, the number of instances would multiply by the number of garments once more. We see that, in general, while the program with variables can be rather terse, the corresponding ground program might be exponentially larger.
\end{example}

State-of-the-art ASP systems feature two components: The \emph{grounder} takes care of substituting all variables, i.e.~generating the ground program, while the \emph{solver} takes this ground program as input and computes answer sets. Traditionally, the grounder is invoked first, and only after it has output the ground program, the solver starts execution. This two-phased mode of operation is referred to as \emph{ground-and-solve}. With the ground program being exponentially larger than the original input program with variables, these systems are prone to what we call the \emph{grounding bottleneck}: When the ground program is so large that it does not fit into memory, the search for answer sets is impossible in practice. For more examples that exhibit the grounding bottleneck, we refer to \cite[Section 1]{asperix}.

\section{Motivation}
\label{sec:motivation}
% propagation als teil des solvers
% leitet information her
% anhand des beispiels beispiel für propagation
% vergleich mit g-s übersetzen in sat klauseln bzw. nogoods (2wl)

The goal of solver components in ASP systems is determining which propositions (such as $wear(winterjacket)$, for example) are \emph{true} and \emph{false} respectively. In the process, an \emph{assignment} designates which propositions are \emph{true} (resp.~\emph{false}), it allows to express statements such as \enquote{$wear(winterjacket)$ is \emph{true}}. Once an assignment is found that associates a truth value with every proposition, an answer set is derived. Assignments conflicting with rules of the program are considered invalid. In Example \ref{ex:garments}, any assignment that allows stating both \enquote{$summer$ is \emph{true}} and \enquote{$winter$ is \emph{true}} at the same time, must be avoided as it cannot represent an answer set, because of the constraint in line \ref{ex:garments:seasons}.

Through the combination of truth values and information about conflicting truth values of propositions, both encoded by the rules of the input program, solvers can infer truth values of other propositions. One method to extend an assignment this way is called \emph{unit propagation}: Rules are modeled as sets of literals (propositions and their negations), called \emph{nogoods}, for which not all might satisfy the assignment. From their property that not all corresponding truth values in the assignment may conform with the nogood at the same time, it follows that when all but one elements of the nogood agree with the assignment (we say the nogood is \emph{unit}), the truth value of the remaining proposition can be inferred and added to the assignment.

\begin{example}
\label{ex:garmentprop}
Consider again Example \ref{ex:garments}. Line \ref{ex:garments:seasons} can be written as a clause $winter \wedge summer$ that must not evaluate to \emph{true}, or simply as a nogood $\delta = \{ \bT summer, \bT winter \}$ of the two propositions that cannot conform with the assignment at the same time. An assignment saying that \enquote{$summer$ is \emph{true}} in combination with $\delta$ implies a new truth value, namely that \enquote{$winter$ is \emph{false}}.
\end{example}

In order to perform unit propagation, ground-and-solve systems commonly translate the input program into a set of nogoods, and even more advanced algorithms have been devised to dynamically \enquote{learn} new nogoods in the process of searching for answer sets. 

For solvers to be efficient, it is crucial to quickly identify which nogoods are unit, even when the assignment under which the nogoods might individually be unit changes frequently during search. Modern solvers implement the so called \emph{two-watched-literals} (2WL) strategy \cite{effsat,questsat}, which describes both an algorithm and a data structure to track nogoods and propagate as soon as they become unit.

An optimization technique to speed up the solving process, pioneered by the ground-and-solve system \dlv (cf.~\ref{sec:dlv}) is the introduction of a third truth value \emph{\mbt} in addition to the two well known values \emph{true} and \emph{false}. Using a third truth value also is an effective optimization in lazy-grounding systems (cf.~\ref{sec:asperix,sec:omiga}). However, 2WL does only account for two truth values, thus cannot be used in conjunction with \emph{\mbt}.

The motivation of this work is twofold. Firstly, enabling lazy-grounding systems to profit from the benefits of 2WL. Secondly, by integration a procedure very similar to 2WL into a lazy-grounding framework, making it simpler to eventually re-use results that previously were exclusive to ground-and-solve systems in lazy-grounding systems as well.

In contrast to ground-and-solve systems, lazy-grounding systems commonly improve their search mechanism by using a third truth value, adding \emph{\mbt} to the two well known values \emph{true} and \emph{false}. 

However, translation of the input program into nogoods in its entirety requires the input program to be ground, because truth values can only be inferred for concrete propositions. \todo{Is this the correct reason why 2WL does not work for lazy grounding?} The approach is therefore subject to the grounding bottleneck.

The motivation of this work is finding a way to adapt 2WL, which was shown to be successfully in SAT solvers as well as ground-and-solve ASP systems, such that it can be employed in lazy-grounding ASP systems.

%\section{Problem Statement}
%\label{sec:problem}
% 2wl works for sat and ground asp. how to adapt it for lazy grounding?

%2WL is an efficient technique for implementing propagation in SAT solvers \cite{effsat,questsat} and ground-and-solve ASP systems \cite[Sec.~5.3]{clasp}. However, it cannot be directly used in lazy-grounding ASP systems, because its prerequisite of a ground program is in conflict with the principle of lazy grounding. The problem to be solved therefore is finding a way to adapt the known procedure in a way that is compatible with lazy-grounding.

%\section{Aim of the Work}
%\label{sec:aim}
% enahnce 2wl st it has properties for lazy g
% -> 3wl works for lazy grounding

%\section{Methodological Approach}
% design algorithms and datastructures
% analyze and proof soundness/completeness
% implementation
% benchmarks

After an analysis of 2WL, algorithms and data structures that account for lazy-grounding is devised and their soundness and completeness is shown. An implementation is contributed to the Alpha system, which in turn is compared against a na{\"i}ve approach in form of a benchmark.

\section{Structure of the Work} % 3 sentences

In Chapter \ref{chap:prelim} we formally introduce logic programs such as the one in the above example (syntax and semantics) of ASP and stable models. Also, a selection of state-of-the-art ASP systems is discussed.

In chapter \ref{chap:prop} efficient propagation for lazy-grounding Answer Set solving is presented.

\todo{Expand to include later chapters.}

\chapter{Preliminaries}
\label{chap:prelim}

This chapter revisits definitions of syntax and semantics of answer set programs. Interpretations and answer sets of such programs are defined.

Apart from these formal foundations, a brief overview of state-of-the-art ASP systems is given and systems that implement lazy-grounding are described.

\section{Answer Set Programming}

In Section \ref{chap:intro} we presented an example program with an intuitive description. In this section we formally define syntactic structure and variants of logic programs, and their semantics under ASP. For a thorough introduction to ASP we refer to \cite{DBLP:conf/rweb/EiterIK09}.

\subsection{Syntax}

%set of PS
%set of Consts
%set of Vars

Given a finite set of constants $\mathcal{C}$, a set of variables $\mathcal{V}$ and a finite set $\mathcal{P}$ of predicate symbols, with $\mathcal{C}$, $\mathcal{V}$, $\mathcal{P}$ pairwise disjoint, we define atoms as the \enquote{building blocks} of logic programs.

\begin{definition}
An \emph{atom} is an expression of the form $p(t_1, \ldots , t_n)$ where $p \in \mathcal{P}$ is a predicate symbol of arity $n \geq 0$ and $\{ t_1, \ldots , t_n \} \subseteq \mathcal{V} \cup \mathcal{C}$ are terms.
\end{definition}

Note that for atoms of arity zero, parentheses usually are omitted. For simplicity, this definition of atoms does not account for function symbols or function terms. Towards a distinction of ground programs (cf.~\ref{chap:intro,ex:garmentsground}) from programs with variables, we formally define the class of ground atoms, for which the set of terms coincides with the set of constants.

\begin{definition}
An atom $p(t_1, \ldots , t_n)$ is called \emph{ground} if $\{ t_1, \ldots , t_n \} \subseteq \mathcal{C}$
\end{definition}

Atoms can be negated as usual in first order logic, leading to the definition of literals. However, note that we discriminate between two types negation in logic programs.

\begin{definition}
A \emph{literal} is an atom $q$ or its negation $\neg q$, it is \emph{ground} if $q$ is ground. The symbol $\neg$ is called \emph{classical negation} or \emph{strong negation}.
\end{definition}

We structure literals in the form of rules, which are in turn divided into a head, consisting of at most one literal, and a body of arbitrary length.

\begin{definition}
A \emph{rule} $r$ is an expression of the form $$a \from b_1, \ldots, b_m, \fail b_{m+1}, \ldots, \fail b_n.$$ where $a, b_1, \ldots, b_n$ are literals, $\mathrm{not}$ is \emph{negation as failure} (or \emph{default negation}), $\{ a \}$ is the \emph{head}, denoted $\headf(a)$ and $\{ b_1, \ldots, b_m \}$ is the \emph{positive body}, denoted $\bodyf^+(r)$, and $\{ b_{m+1}, \ldots, b_n \}$ is the \emph{negative body} of $r$, denoted $\bodyf^-(r)$. Positive and negative body together are simply the \emph{body} of $r$ i.e., $\bodyf(r) = \bodyf^+(r)\cup \bodyf^-(r)$.
A \emph{fact} is a rule $r$ with $\bodyf(r) = \emptyset$ and it is \emph{ground} if all atoms in $\headf(r) \cup \bodyf(r)$ are.
\end{definition}

Note that for a rule $r$ both body and head can be empty: In case $\bodyf(r)$ is empty, we say $r$ is a \emph{fact}, and when $\headf(r)$ is empty, we say that $r$ is a \emph{constraint}.

Finally, we arrive at the notion of a logic program.

\begin{definition}
A \emph{(logic) program} $P$ is a finite set of rules. It is \emph{ground} if all $r \in P$ are ground.
\end{definition}

% disjunction, aggregates, choice rules
% easier to model programs
% beyond scope

For the scope of this work, above definition of rules is sufficient. Programs consisting only of rules of this form are called \emph{normal} programs. For example, more generally, rules with disjunctive heads $a_1 \vee \cdots \vee a_k \from \ldots$ also have interesting properties, but are outside the scope of this thesis.

In practice, many more syntactic constructs are used to ease modelling programs: Arithmetic expressions, aggregates allowing statements about sets (counting how many elements match some criteria, summation of numeric values, etc.) and choice rules that encode sets of atoms for which only a given number should be in an answer set, all of which can be translated into simple rules. For core standard, widely acceptedamong ASP many systems, consider \cite{calimeri2015asp}.

%\begin{definition}[{\cite[p.~12]{DBLP:conf/rweb/EiterIK09}}]
%A \emph{normal logic program} is a set of clauses having the form $$a \leftarrow b_1, \ldots , b_m, \text{not } c_1, \ldots , \text{not } c_n \qquad (n, m \geq 0)$$ where all $a, b_i$ and $c_j$ ($1 \leq i \leq n$ and $a \leq j \leq m$) are atoms of a first order language $L$. Expressions $\text{not } c_1, \ldots , \text{not } c_n$ are called the \emph{(default) negated literals} and consist of atoms $c_j$ preceded by the negation modifier $\text{not}$. Accordingly the atoms $a_i$ are called \emph{positive literals}.
%\end{definition}

\subsection{Semantics}

An atom in the sense of ASP is a proposition with no deeper structure. It might represent some external state of affairs, e.g.~$rainy$ to indicate whether the weather is not nice or $handsome(yue)$ a statement about Yue being handsome. Their granularity or level of abstraction directly affects how detailed the world is modeled by a program, because atoms are treated as internally consistent statements and they cannot be split further.

In order to reason about the truth values of atoms in a program, we define an interpretation.

\begin{definition}
An \emph{interpretation} is a set of ground atoms $I$.
\end{definition}

%Observe that $I$ is a set of \emph{ground} literals, i.e.~we only define an interpretation for ground atoms and a na\ddot{i}ve implementation will therefore first ground the input program. This is the root of the bottleneck.

Considering Example \ref{ex:garments}, note that the set $I_1 = \{ wear(G) \}$ is not an interpretation, because the atom it contains is not ground. However $I_2 = \{ wear(winterjacket) \}$ is an interpretation, because $winterjacket$ is used as a constant in the program.

The truth value of an atom is defined against an interpretation, which in turn is simply the set of atoms that are considered \emph{true}, i.e.~we say that 

Interpretations and literals are related through satisfaction.

\begin{definition}
An interpretation $I$ \emph{satisfies} a positive literal $l = p$, if $p \in I$ and a negative literal $l = \neg p$ if $p \not \in I$. We denote this as $I \models l$ .
\end{definition}

We commonly encode the truth value of atoms through satisfaction, e.g.~we say that an atom $p$ is \emph{true} under some interpretation $I$ if the the literal $l = p$ is satisfied by $I$ and vice versa. Satisfaction of literals expands to satisfaction of rules.

\begin{definition}
An interpretation $I$ \emph{satisfies} a ground rule $r$, denoted $I \models r$ if $\bodyf^+(r) \subseteq I \wedge \bodyf^-(r) \cap I = \emptyset$ implies that $\headf(r) \subseteq I$ and $\headf(r) \not = \emptyset$, i.e.~whenever the body of $r$ is satisfied, then the head of $r$ is satisfied as well.
\end{definition}

In case an interpretation satisfies all rules of a program, we call it a model thereof.

\begin{definition}
A \emph{(classical) model} of a ground program $P$ is an interpretation $I$ that is a model of all rules in the program, i.e.~$I \models r$ for all $r \in P$.
\end{definition}

We use the Gelfond-Lifschitz reduct towards a definition of answer sets.

\begin{definition}[see {\cite[Section 2]{stable}}]
	Given a ground program $P$ and an interpretation $I$, the \emph{Gelfond-Lifschitz reduct} (or just \emph{reduct} in short) of $P$ with respect to $I$, denoted $P^I$ is defined as follows:
\begin{multline*}
P^I = \Bigl\{ a \from b_1, \ldots , b_m \mid a \from b_1, \ldots, b_m, \fail b_{m+1}, \ldots, \fail b_n \in P\\ \text{ and } \{ \neg b_{m+1} , \ldots , \neg b_n \} \subseteq I \Bigr\}
\end{multline*}
\end{definition}

Finally, an answer set is a $\subset$-minimal model of the corresponding reduct.

\begin{definition}
An interpretation $I$ is an \emph{answer set} iff it is a $\subset$-minimal model of $P^I$, i.e. there is no $J \subset I$ which is also a model of $P^I$.
\end{definition}

\todo{Examples! Three programs and some interpretations that are no models, models that are no answer sets, and answer sets.}

In practice, interpretations cannot be guessed in their entirety but are constructed step-by-step in a search process (\enquote{solving}). A distinction between an unassigned atom and an atom that has been found to be \emph{false} is not possible when directly working with interpretations like above; partial interpretations cannot be expressed, as everything that is not explicitly included in the interpretation is effectively assumed to be \emph{false}. This is why interpretations are commonly represented by assignments, which explicitly encode the truth value of atoms.

\begin{definition}
An \emph{assignment} $\ass$ is a set of literals.
\end{definition}

Literals can be related with assignments similar to interpretations: $A \models l$ if $l \in A$. We say that an atom $p$ is unassigned if neither $A \models p$ nor $A \models \neg p$. For the case where there are no unassigned atoms, the interpretation that corresponds to the assignment is the subset of all positive literals in the assignment itself.

% "ASP means stable models. Logic programs with negation may use other semantics."
%Note that we are only interested in the particular semantics of stable models which characterizes ASP and falls into the category of \emph{multiple} model semantics. There exist other semantics, such as the \emph{perfect model} semantics in \cite{DBLP:books/mk/minker88/Przymusinski88}.

\section{State-of-the-art ASP Systems}

In this section we survey state-of-the-art ASP systems in order to highlight similarities and differences in their approaches. As this work is concerned with the adoption of 2WL, a technique common in SAT solvers and ground-and-solve ASP systems, for lazy-grounding systems, we focus on the comparison of ground-and-solve and lazy-grounding systems.

The first ASP systems developed are based on the ground-and-solve approach, as it is less involved and can be implemented in a more straight-forward manner than lazy-grounding. We consider \clasp as it uses two-watched literals and employs nogood learning and \dlv because it introduced \emph{\mbt} as a truth value, which turns out to be very effective in lazy-grounding as well.

Only gradually, running into the grounding bottleneck with benchmarks and in industry settings, the grounding bottleneck was recognized, which lead to the development of lazy-grounding systems. With lazy-grounding systems being newer, and less time spent reasoning about their efficiency and (re-)engineering them, they often fail to achieve the performance of ground-and-solve systems. The main culprit of early lazy-grounding systems is that they cannot leverage state-of-the-art techniques from ground-and-solve systems: Among others, propagation using two-watched literals and heuristics are where the performance of ground-and-solve systems stems from.

\subsection{Ground-and-Solve}

We describe two very successful systems that follow the ground-and-solve approach.

\subsubsection{clingo}

\texttt{clingo}\footnote{\url{https://potassco.org/clingo/}} is a ground-and-solve ASP system, written in C++\footnote{\url{http://www.open-std.org/jtc1/sc22/wg21/}}, which combines the grounder \texttt{gringo} and the solver \texttt{clasp}. \clasp uses the 2WL strategy for propagation \cite[Sec.~5.3]{clasp} and implements conflict-driven nogood learning (CDNL) \cite[Sec.~4.1]{clasp} in analogy to conflict-driven clause learning (CDCL) in SAT solvers \cite{grasp,cdl-sat}. It is among the fastest ASP systems according to \cite{aspcomp2015}\footnote{With detailed results at \url{http://aspcomp2015.dibris.unige.it/aspcomp2015-iclp-slides.pdf}}.

\subsubsection{DLV}

\dlv \cite{dlv} is a versatile ground-and-solve ASP system divided into front-end, intelligent grounding, model generation and model checking components. It comes with front-ends for various applications: (Extended) Disjunctive Logic Programming \cite{dlp} (similar to DISLOG \cite{dislog} and DisLoP \cite{dislop}), Diagnostic Reasoning, and the Structured Query Language\footnote{\cite{dlv} references the 1999 version available from \url{https://www.iso.org/standard/26196.html} and \url{https://www.iso.org/standard/26197.html}}). With \cite{dlv-mbt} the authors add two important features: Firstly, they introduce a third truth value, \mbt, to enhance propagation. It marks atoms that must be assigned true in order to yield an answer set, but where there is no proof found in the search process (see Section \ref{sec:asperix} and Example \ref{ex:mbt} as well). Secondly, heuristics that increase the odds of choices to be correct greatly improve overall performance.

A detailed paper on the development, optimization and industrial application of \dlv is available through \cite{dlvproject}.

\subsection{Lazy-Grounding}

In this section we briefly describe three different ASP systems that were designed to circumvent the grounding bottleneck. They all build on top of computations as described in \cite{computations}.

\subsubsection{ASPeRiX}
\label{sec:asperix}

\asperix is one of the first ASP systems that were designed to avoid the grounding bottleneck. It was first prototyped in 2008\footnote{According to the project's website \url{http://www.info.univ-angers.fr/pub/claire/asperix/\#download}} and published in \cite{asperixfirst,fofchain}, with a detailed explanation in \cite{asperix}. It is implemented in C++. The core algorithm evolved from the concept of computation as in \cite{computations}.

In the process of finding a solution, it extends a partial interpretation \cite[Def.~4]{asperix} in form of a pair $\langle IN, OUT \rangle$ of disjoint atom sets, where the atoms in $IN$ belong to the answer set that is currently searched and the atoms in $OUT$ do not. Further, the system tracks the set of ground rules, $R$, which is lazily extended by grounding the input program. Rules of the program $r$ relate to a partial interpretation and are called \emph{supported} ($\bodyf^+(r) \subseteq IN$), \emph{blocked} ($\bodyf^-(r) \cap IN \not = \emptyset$), \emph{unblocked} ($\bodyf^-(r) \subseteq OUT$), and \emph{applicable} (supported and not blocked) \cite[Def.~5]{asperix}. 

The main concept in this ASP system is an \asperix \emph{computation} \cite[Def.~7]{asperix}: It is a sequence of pairs $\langle R_i, I_i \rangle$ that captures ground rules and a partial interpretation $I_i = \langle IN, OUT \rangle$. The computation starts with $\langle \emptyset, \langle \emptyset, \{ \bot \} \rangle \rangle$ and is inductively defined through the rules \emph{propagation} (monotonic; a new rule $r_i \not \in R_{i-1}$ can be ground from the program such that it \enquote{fires}, i.e.~its head is added to $IN$), \emph{choice} (non-monotonic; there are no rules that propagate, but the solver guesses whether an applicable rule fires, i.e. forces or prohibits its instantiation) and \emph{stability} (no rules for propagation or choice left). Through inductive definition of computations, it is guaranteed that the sequence converges to an answer set iff there exists one \cite[Thm.~2]{asperix}.

The most important take-away from \asperix for this work, however is the introduction of a third truth value which allows for more efficient convergence of above computation: The truth value \mbt indicates that an atom that is not in already in $IN$ must be in $IN$ (cannot be in $OUT$) in order to find an answer set. It allows to mark certain atoms for which a \enquote{proof}, i.e. a firing rule with the atom as its head, has not yet fired, but must, at some point in the computation.

\begin{example}[{\cite[Example 7]{asperix}}]
\label{ex:mbt}
Let $\from \fail b.$ be a constraint whose body contains only one literal $\fail b$ with $b \not \in IN \cup OUT$. In order to have an answer set, $b$ must be in $IN$ so that the constraint is not applicable but $b$ is not yet proved (it is not in the head of a fired rule). Thus, one can only conclude that $b$ must be true.
\end{example}

This leads to a reduction of the search space in propagation \cite[Ex.~8]{asperix} and also decreases the size set of non-monotonic candidate rules for choice \cite[Ex.~9]{asperix}. Partial interpretation and computation are modified to consider \mbt in \cite[Def.~8]{asperix} and \cite[Def.~11]{asperix} accordingly. Again, there is a correspondence to answer sets \cite[Thm.~3]{asperix}.

\asperix shows how lazy grounding ASP systems can leverage \mbt as a third truth value. How unit propagation is affected by \mbt is a central topic in Chapter \ref{chap:prop}.

\subsubsection{OMiGA}

\omiga\footnote{\url{http://www.kr.tuwien.ac.at/research/systems/omiga/}} \cite{omiga}, written in Java\footnote{\url{https://oracle.com/java/}}, uses computation to explore the search space similar to \asperix. In contrast it uses a so called \emph{Rete network} \cite{rete} as dominating data structure: Rete is an algorithm to search large collections of objects for those matching a pattern, and it was initially designed to be used in expert systems and rule based production systems, where there are many rules to consider.

In \omiga the network is used to: (a) store ground atoms, (b) retrieve ground atoms for the purpose of grounding new rules, (c) find applicable non-ground rules (\emph{propagation} in \asperix), and (d) find rules to guess on (corresponding to \emph{choice} in \asperix). While \asperix re-evaluates applicability of non-ground rules at each step in the computation, \omiga keeps grounded atoms and partial ground rule interpretations in the network. In choosing a Rete network to store these data, \omiga trades space for time, as information retrieval from the network is faster than re-computation of applicability. 

\omiga was also extended for learning of non-ground rules in \cite{nglearn}, analogous to conflict driven nogood learning as in \clasp and clause learning in SAT solvers.

\subsubsection{GASP}

GASP \cite{gasp,gasp2}\footnote{\url{https://users.dimi.uniud.it/~agostino.dovier/GASP/} and \url{https://users.dimi.uniud.it/~agostino.dovier/CLPASP/}} is implemented SICStus Prolog 4\footnote{\url{https://sicstus.sics.se/}}. It represents interpretations as finite domains and uses Constraint Logic Programming.

%\subsection{Summary}

%Any newly developed ASP system should naturally profit from the design efforts and experimental results of the above systems (and others). We therefore aim to identify key features and techniques of these approaches.

\section{Two Watched Literals}

As briefly mentioned in Section \ref{sec:motivation}, Two Watched Literals (also \enquote{Two Literal Watching}, 2WL, \cite{effsat,questsat}) is an algorithm for unit propagation commonly used in SAT solvers (cf.~\cite[Section 2.2.2, p.~94]{handbook-sat}), which has been adopted by ground-and-solve ASP systems \cite{clasp}. This section is devoted to a description of the method, first in the context of SAT, then about its application in  ASP solving.

\begin{example}
\label{ex:clause-prop}
Suppose $\psi = (a_1 \vee \neg a_2 \vee a_3 \vee \neg a_4) \wedge (\neg a_1 \vee \neg a_2 \vee a_3 \vee a_4)$ is input to a SAT solver\footnote{In SAT solving, formulas are typically input to solvers in conjunctive normal form (CNF). The DIMACS format is commonly used to encode concrete formulas.}. The formula $\psi$ would yield two \enquote{clauses}, $\psi = \phi_1 \wedge \phi_2$ with $\phi_1 = a_1 \vee \neg a_2 \vee a_3 \vee \neg a_4$ and $\phi_2 = \neg a_1 \vee \neg a_2 \vee a_3 \vee a_4$, both of which have to be satisfied in order for $\psi$ to be satisfied. As the solver is evaluating $\psi$ under different (partial) assignments for atoms $a_1, \ldots, a_4$ it \enquote{watches} two literals per clause. This way it can detect whether a clause is unit. Whenever an atom $a$ is assigned it considers the clauses where $a$ is a watched literal for propagation. Conversely, all other clauses, where $a$ is not watched, are guaranteed to not be unit.
\end{example}

The concept of a nogood originates in constraint programming (CP) (cf.~\cite{clasp,handbook-cp,handbook-kr-cp}), where the goal is to find an assignment for variables such that given constraints are satisfied. SAT and ASP can be viewed as specializations of CP. For example, in a problem containing the variable $x$ and the constraint $x > 1$ one can forbid the value $x = 1$. The assignment $x = 1$ is a nogood. In this work, nogoods are only used to represent boolean constraints. Unit propagation is sometimes also referred to as boolean constraint propagation.

\begin{definition}[cf.~\cite{handbook-cp}]
\label{def:nogood}
A \emph{nogood} is a set $\{ \bsgl_1, \ldots, \bsgl_n \}$ of literals that cannot be extended to a solution.
\end{definition}

First proposed by \citet{clasp}, in the solver components of ASP systems, nogoods take the role of clauses in SAT solvers. Nogoods correspond to partial assignments that cannot be extended to an answer set, and are derived from rules \cite[Section 3]{clasp}.

\begin{example}
\label{ex:rule-to-nogood}
For example, a rule $r$ of the form $a_1 \from a_2, \neg a_3, a_4$ translates to the nogood $\delta = \{\neg a_1, a_2, \neg a_3, a_4 \}$. An interpretation $I$ that satisfies all elements of $\bodyf(r) = \{a_2, \neg a_3, a_4$ and $\neg a_1$, the negation of the only element of $\headf(r)$, cannot be a model of $r$.
\end{example}

Given a nogood $\delta$ and an interpretation $I$, with $I \models \bsgl$ for all $\bsgl \in \delta$, then $I$ is not a solution. This property allows for propagation: If $T = \{ \bsgl \mid \bsgl \in \delta \text{ and } I \not \models \bsgl\}$ and $|T| = 1$ we say that $\delta$ is \emph{unit} or unit on $\bsgl$ for $\bsgl \in T$. In order to obtain a solution we may extend $I$ to $I'$ so that $I' \models \neg \bsgl$.

The number of nogoods generated from a program is proportional to the size of the corresponding ground program. Thus, one can expect many nogoods to be generated in the process. However, after constructing nogoods from the input program (or parts thereof, as in the lazy-grounding case) and propagating truth values, it is important to efficiently re-evaluate whether there is a nogood that is unit under the extended assignment. This is where the benefits of 2WL in SAT over clauses and in ASP over nogoods align.

For each nogood, two distinct and unassigned literals are chosen to watch the nogood. When one of these literals is assigned, a different literal (distinct from the second watching literal) in the nogood is chosen to watch the nogood. This process is continued until there are no more two distinct literals available in the nogood. If the nogood is unit at this point, a new assignment can be generated.

When grounding a program, rules can be transformed into conjunctive clauses represented by nogoods that must not be satisfied as shown in Example \ref{ex:garmentprop}. Such clauses written as sets are called nogoods.

\begin{example}
Consider Figure \ref{fig:2wl}. It shows the nogood $\delta = \{\neg a_1, a_2, \neg a_3, a_4 \}$ (which might represent a rule like $r$ from Example \ref{ex:rule-to-nogood} or $\phi_1$ from Example \ref{ex:clause-prop}) in the context of propagation using 2WL. The watched literals are marked by arrows.

Initially, the two watched literals are selected arbitrarily. Transitioning from State 1 (empty assignment) to State 2, the solver will not check $\delta$ for unity, because $a_3$ is not watched. When $a_2$ is assigned to \emph{true}, the solver \enquote{looks at} $\delta$. As $a_2$ is assigned, it cannot be a watched literal anymore, but $\delta$ also is not unit, because $a_1$ is still unassigned. The pointer that previously pointed at $a_2$ is \enquote{moved} to $\neg a_1$. Note that this is the only option, as the atoms of all other literals are already assigned and $a_4$ is already being pointed at.

Processing the assignment of $a_1$, again, $\delta$ is considered. Now, there is no unassigned literal, that is not also watched, left. The nogood is unit. The truth value of $a_4$ is inferred to be \emph{false}. At this point (State 5), pointer placement is irrelevant, because $\delta$ is satisfied.
\end{example}

\begin{figure}
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]

\node(ng1)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={white,white,white,white},
    inner sep=6pt,
    text width=6mm,
    align=center
    ] {
$\neg a_1$     % two
\nodepart{two} $a_2$
\nodepart{three}  $\neg a_3$
\nodepart{four}  $a_4$
};

\node[left=0.7cm of ng1]{State 1};

\draw [<-] (ng1.two north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng1.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng1ass)[below=0.4cm of ng1] { $A_1 = \emptyset$ };
\node(ng1des)[right=1cm of ng1.east, text width=7cm] { Initially, pointers are placed arbitrarily. };

\draw ($ (ng1.east) + (1,-1.2) $) -- ($ (ng1.east) + (1,-2.2) $) node[right=0.5cm,right,pos=0.5] {$a_3$ is assigned \emph{false}.};

\node(ng2)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={white,white,yellow!60,white},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng1
    ] {
$\neg a_1$     % two
\nodepart{two} $a_2$
\nodepart{three}  $\neg a_3$
\nodepart{four}  $a_4$
};

\node[left=0.7cm of ng2]{State 2};

\draw [<-] (ng2.two north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng2.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng2ass)[below=0.4cm of ng2] { $A_2 = \{\neg a_3\}$ };
\node(ng2des)[right=1cm of ng2.east, text width=7cm] { Pointers were not checked, as $a_3$ is not watched. };

\draw ($ (ng2.east) + (1,-1.2) $) -- ($ (ng2.east) + (1,-2.2) $) node[right=0.5cm,pos=0.5] {$a_2$ is assigned \emph{true}.};

\node(ng3)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={white,yellow!60,yellow!60,white},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng2
    ] {
$\neg a_1$     % two
\nodepart{two} $a_2$
\nodepart{three}  $\neg a_3$
\nodepart{four}  $a_4$
};

\node[left=0.7cm of ng3]{State 3};

\draw [<-] (ng3.one north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng3.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng3ass)[below=0.4cm of ng3] { $A_3 = \{\neg a_3, a_2 \}$ };
\node(ng3des)[right=1cm of ng3.east, text width=7cm] {No pointer must point at an assigned atom, therefore it is moved. };

\draw ($ (ng3.east) + (1,-1.2) $) -- ($ (ng3.east) + (1,-2.2) $) node[right=0.5cm,right,pos=0.5] { $a_1$ is assigned \emph{false}. };

\node(ng4)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={yellow!60,yellow!60,yellow!60,white},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng3
    ] {
$\neg a_1$     % two
\nodepart{two} $a_2$
\nodepart{three}  $\neg a_3$
\nodepart{four}  $a_4$
};

\node[left=0.7cm of ng4]{State 4};

\draw [<-] (ng4.one north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng4.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng4ass)[below=0.4cm of ng4] { $A_4 = \{\neg a_3, a_2, \neg a_1 \}$ };
\node(ng4des)[right=1cm of ng4.east, text width=7cm] {  Only one literal is left unassigned. };

\draw ($ (ng4.east) + (1,-1.2) $) -- ($ (ng4.east) + (1,-2.2) $) node[right=0.5cm,pos=0.5] { The nogood is unit, $a_4$ is assigned \emph{false}. };

\node(ng5)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={yellow!60,yellow!60,yellow!60,teal!60},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng4
    ] {
$\neg a_1$     % two
\nodepart{two} $a_2$
\nodepart{three}  $\neg a_3$
\nodepart{four}  $a_4$
};

\node[left=0.7cm of ng5]{State 5};

\draw [<-] (ng5.one north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng5.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng5ass)[below=0.4cm of ng5] { $A_5 = \{\neg a_1, a_2, \neg a_3, \neg a_4 \}$ };
\node(ng5des)[right=1cm of ng5.east, text width=6cm] { $a_4$ was assigned via propagation, s.t.~the nogood is satisfied. };

\end{tikzpicture}
  \caption{Example layout of a \emph{watch structure}.}
  \label{fig:2wl} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

\chapter{Three Watched Literals}
\label{chap:prop}

The central idea of propagation is to infer (\emph{propagate}) new truth values from known truth values and nogood clauses, derived from the input program, as briefly explained in \ref{sec:motivation}. 

In this chapter we extend 2WL, a technique to implement propagation, and present an algorithm that accounts for \emph{\mbt} as third truth value.

\section{Literals, Assignments and Nogoods}

% Signed literal vs. boolean signed literal.

In this section we amend the definition of Literals and Nogoods, for the purpose of propagation with \emph{\mbt}.

Following definitions lay out the vocabulary and concepts towards an explanation of unit propagation. Most of them fundamentally depend on \emph{atoms} (usually denoted $v$) but do not refer to neither a set of atoms nor their domain. This is because all definitions are bound to a logic program $P$ to be solved (i.e.~to find answer sets for). The set of ground atoms wrt.~$P$, effectively its Herbrand Base $\textit{HB}(P)$, is obtained by the grounding process, which is not detailed in this work. What might seem to be lacking from the definitions therefore is the context of the input program $P$ and the domain of atoms. $P$ and its context is omitted in the following.

%In this section we define the notions 
%As we will be mainly concerned ith assignments, sequences that, informally, \enquote{relate} to interpretations, but require explicitly stating that some atom is \emph{false}.

% TODO: Where does v come from? Should be in some HB(P)?
%\begin{definition}
%A \emph{ground atom} (or simply \emph{atom}) wrt.~a logic program $P$ is an element of $\textit{HB}(P)$, usually denoted $v$.
%\end{definition}

Amending Definition \ref{def:lit}, for the remainder of the work we consider boolean signed literals, which mean atoms and their negations in the classical sense, and, more generally, signed literals, which also allow for a third sign that allows modeling \emph{\mbt}.

\begin{definition}
A \emph{boolean signed literal} $\bsgl$ of the form $\bT v$ or $\bF v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, and $\bF v$ that it is \emph{false}.
\end{definition}

\begin{definition}
A \emph{signed literal} $\sgl$ is of the form $\bT v$, $\bF v$, or $\bM v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, $\bF v$ that it is \emph{false} and $\bM v$ that it \emph{\mbt}.
\end{definition}

%\begin{definition}
%The function $\wkn(\bsgl)$ takes a boolean signed literal $\bsgl$ and transforms it into a signed literal referred to as its \emph{weak form}, meaning that while \emph{false} stays \emph{false}, e.g.~$\wkn(\bF v) = \bF v$, \emph{true} is mapped to \emph{\mbt}, e.g.~$\wkn(\bT v) = \bM v$.
%\end{definition}

% TODO: Remark on boolean signed literal vs. signed literal with context of clasp?

With the introduction of literals like $\bM v$, we also explicitly define two forms of taking the complement of such literals.

\begin{definition}
Strong complement, denoted by $\negstrong{\sgl}$, and weak complement, $\negweak{\sgl}$, mapping $\bF v$ to $\bT v$ and $\bF v$ to $\bM v$ respectively, of a signed literal are defined by the following truth table:%equalities: $\negstrong{\bT v} = \bF v$, $\negstrong{\bM v} = \bF v$ and  $\negstrong{\bF v} = \bT v$, while $\negweak{\bT v} = \bF v$, $\negweak{\bM v} = \bF v$ and $\negweak{\bF v} = \bM v$.
% "andere Richtung auch erklären"

\begin{center}
\begin{tabular}{|c|cc|}
\hline
$\sgl$&$\negstrong{\sgl}$&$\negweak{\sgl}$\\
\hline
\hline
$\bT v$&$\bF v$&$\bF v$\\
$\bM v$&$\bF v$&$\bF v$\\
$\bF v$&$\bT v$&$\bM v$\\
\hline
\end{tabular}
\end{center}
\end{definition}

A literal does not only conflict with its strong complement but also with its weak complement.

\begin{definition}
Two literals $\sgl_1, \sgl_2$ are said to \emph{conflict} in case $\sgl_1 = \negweak{\sgl_2}$ or $\negweak{\sgl_1} = \sgl_2$.
\end{definition}

Occasionally the notation $\sgl = \bX v$ will be used to express that $\sgl$ is a literal of $v$ where $\bX \in \thrice$, i.e.~$\sgl$ is \enquote{bound} to $v$, but the sign is not important.

Similar to \cite[Section 2, p.~3]{clasp} we define assignments. However, here assignments contain not only boolean signed literals, but also signed literals and the notation for expressing a partial assignment differs.

\begin{definition}
An \emph{assignment} $\ass$ is a sequence $(\sgl_1, \ldots, \sgl_n)$ of signed literals $\sgl_i = \bX v_i$ with $1 \leq i \leq n$, or \emph{conflict}.
\end{definition}

%\begin{remark}
Below, assignments are sometimes also used as sets, in which case the set represented by some assignment is simply the set of all signed literals contained in the sequence.
%\end{remark}

For an assignment $\ass = (\sgl_1, \ldots, \sgl_i, \ldots, \sgl_j, \ldots, \sgl_n)$, we denote its size as $|\ass|$ with $|\ass| = n$, and a partial assignment, which is a sub-sequence constructed from an assignment, as $\ass[i,j] = (\sgl_i, \ldots, \sgl_j)$ where $1 \leq i < j \leq n$ and reference a single literal using $A[i] = \sgl_i$ for $1 \leq i \leq n$.

The assignment obtained by appending the literal $\sgl$ to $\ass = (\sgl_1, \ldots, \sgl_n)$ is denoted by $$\ass \circ \sgl = \left\{\begin{array}{ll}
        
        \emph{conflict} & \text{if } \{ \negstrong{\sgl}, \negweak{\sgl} \} \cap \ass \not = \emptyset \text{ or } \ass = \emph{conflict}\\
        %(\sgl_1, \ldots, \sgl_{n-1}, \sgl) & \text{if } \sgl = \bT v \text{ and } \bM v \in \ass \text{, i.e. appending } \bT v \text{ removes } \bM v\\
        (\sgl_1, \ldots, \sgl_{n}, \sgl) & \text{otherwise} \\
        \end{array}\right.$$

%Appending preserves that for any atom $v$ there is at most one literal in the assignment: With $\sgl = \bT v$ and $\bM v \in \ass$, for $\ass' = \ass \circ \sgl$ it holds that $\bM v \not \in \ass'$ (and $|\ass'| = |\ass|$).

%Furthermore $\emph{conflict} \circ \sgl = \emph{conflict}$ for any $\sgl$. 

For every assignment, we can also construct a corresponding boolean assignment, which is obtained by substituting all literals of the form $\bM v$ with $\bT v$. Boolean assignments are just sets, and not sequences like assignments are, because we do not require any ordering in this work.

\begin{definition}
A \emph{boolean assignment} is a set of boolean signed literals derived from an assignment, denoted $\bass(\ass)$ and defined as $\bass(\ass) = \{ \sgl \in \ass \ | \ \sgl = \bT v \textrm{ or } \sgl = \bF v \} \cup \{ \bT v \ | \ \bM v \in \ass \}$.
\end{definition}

Relating assignments with literals and atoms, we say that an atom $v$ is \emph{assigned} under some assignment $\ass$ if any literal containing it is in $\ass$, i.e.~if $\ass \cap \{\bT v, \bM v, \bF v \} \not = \emptyset$. We say that an atom is unassigned under $A$ if it is not assigned under $A$. We also say that a literal $\bX v$ is assigned under $\ass$ if $v$ is. \todo{Do I really say that a literal is assigned under some assignment at some point? Sounds strange.}

%\begin{definition}
%An atom $v$ is \emph{unassigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} = \emptyset$$
%\end{definition}

%\begin{definition}
%A signed literal $\bX v$ is \emph{assigned} under $\ass$ if $v$ is assigned under $\ass$.
%\end{definition}

%Intuitively, atoms and literals are \emph{unassigned} under $\ass$ iff the are not assigned under $\ass$.

\begin{definition}
A literal $\sgl_1$ is said to conflict with $\ass$ in case it conflicts with any $\sgl_2 \in \ass$.
\end{definition}

In this section we extend Definition \ref{def:nogood}. For propagation with \emph{\mbt}, it is important qualify literals in nogoods that correspond to correspond heads of rules.

\begin{definition}
The \emph{head} of a nogood $\delta$, is a set of literals $\headf(\delta)$, for which $\headf(\delta) \subseteq \delta$ and $|\headf(\delta)| \leq 1$.\end{definition}

Note that $\headf(\delta)$ is always of the form $\bF v$. \todo{Why?} Complementary we define the body, as all literals that are not in the head.

\begin{definition}
The \emph{body} of a nogood $\delta$ a set of literals $\bodyf(\delta)$ such that $\bodyf(\delta) \cap \headf(\delta) = \emptyset$ and $\delta = \bodyf(\delta) \cup \headf(\delta)$.
\end{definition}

We need two variants of a nogood being unit. One that accounts for \emph{\mbt} and one that does not, i.e.~treats $\bM v$ the same as $\bT v$.

\begin{definition}
A nogood $\delta$ is \emph{strongly unit} under an assignment $\ass$ if $\delta \setminus \ass = \{ \headf(\delta) \}$
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{weakly unit} under an assignment $\ass$ if $\delta \setminus \bass(\ass) = \{ \bsgl \}$
\end{definition}

Note that, as the names suggest, any nogood that is strongly unit under some assignment is also weakly unit, but not the other way round. Below, nogoods are sometimes referred to be \emph{unit} which amounts to stating that they are weakly unit. Also, when clear from context, reference to a particular assignment is omitted.

\begin{definition}
\label{def:vio}
A nogood $\delta$ is \emph{violated} under an assignment $\ass$ if $\delta \subseteq \bass(\ass)$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{satisfied} under an assignment $\ass$ if there is no $\ass' \supseteq \ass$ s.t.~$\delta$ is violated under $\ass'$.
\end{definition}

Note that for an assignment $\ass$, any nogood that is satisfied under $\ass$ will also never be unit, and never propagate, for any $\ass' \supseteq \ass$.

\begin{definition}
A nogood $\delta$ is \emph{silent} under some assignment $\ass$ if $\delta$ is not violated by $\ass$ and $\delta$ is not unit wrt.~$\ass$.
\end{definition}

Note the difference between some $\delta$ being silent vs.~satisfied under an assignment: With $\delta$ being silent under $\ass_1$, there might well be some $\ass_1' \supset \ass_1$ under which $\delta$ is unit or violated. However $\delta$ satisfied under $\ass_2$ is stronger and implies that there is no \enquote{larger} assignment $\ass_2' \supset \ass_2$ such that $\delta$ is not satisfied under $\ass_2'$. It follows that $\delta$ can neither be unit nor violated under $\ass_2'$.

\section{Watch Structures}

In Section \ref{sec:2wl} we have left open how the \enquote{pointers}, as illustrated in Figure \ref{fig:2wl} are stored. Without an efficient way of associating assigned atoms with the nogoods that they are \enquote{watching}, there is no benefit in using watched literals at all. We therefore define watch structures, abstract data structures that allow to store this information.

Concrete implementations might use hash table lookups to implement watch structures as outlined below.

%Here, a watch structure is a function that maps atoms to to triples, as 

%When implementing propagation, na{\"i}vely obtaining checking a large set of nogoods that represents an ASP program for unity is infeasible. Sophisticated data structures are needed to make propagation sufficiently fast.

\begin{definition}
% ASK: Why not define watch structure as a function/relation mapping from atom to watch sets? Structure is irrelevant, and mapping function is closer to a map in code.
% ASK: How to omit irrelevant elements of a tuple?
A \emph{watch structure} is a function that maps atoms $v$ to triples containing sets of nogoods, the so called \emph{watch sets} of $v$: $$\Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

%For any watch set $W$ in $\Delta(v)$ and nogood $\delta \in W$ it follows that $\bX v \in \delta$.

For some signed literal $\sgl = \bX v$ let $$\dpm(\sgl) = \left\{\begin{array}{ll}
        W^+ & \text{if } \sgl = \bT v \ \text{or } \sgl = \bM v\\
        W^- & \text{if } \sgl = \bF v \\
        \end{array}\right\} \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

For some signed literal $\sgl = \bX v$ or an atom $v$ let $$\dal(\sgl) = \dal(v) = W_i^\alpha \ \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$
\end{definition}

The functions $\dpm(\sgl)$ and $\dal(\sgl)$ can for example be implemented as simple hash table lookups (visualized in Figure \ref{fig:watches}), which take constant time. When a literal $\bX v$ is appended to the assignment, all nogoods that might have become unit can be found in the sets $\dpm(\bX v)$ and $\dal(\bX v)$.

%Interpretation as a set $\Delta = \{(v_i, (W_i^+, W_i^-, W_i^\alpha)\}$ for $1 \leq i \leq n$ where $i \not = j \to v_i \not = v_j$ for $1 \leq j \leq n$ reveals how such a mapping can be stored or visualized (see figure~\ref{fig:watches}).

\begin{figure}
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]
\node(s)[stack=4]  {
                 Atom     % text
\nodepart{two}   $v_1$     % two
\nodepart{three} $v_2$      % three
\nodepart{four}  \vdots % four
};

\node(v1t)[stack=3, rectangle split horizontal, above right=2cm and 3cm of s.two] {
$\delta_1$     % two
\nodepart{two} $\delta_2$      % three
\nodepart{three}  \ldots % four
};

\node(v1m)[stack=3, rectangle split horizontal, above right=1cm and 3.5cm of s.two] {
$\delta_3$     % two
\nodepart{two} $\delta_4$      % three
\nodepart{three}  \ldots % four
};

\node(v1f)[stack=3, rectangle split horizontal, above right=0cm and 4cm of s.two] {
$\delta_5$     % two
\nodepart{two} $\delta_6$      % three
\nodepart{three}  \ldots % four
};

\path (s.two east)
edge [out=east,in=west, left] node {$+$} (v1t)
edge [out=east,in=west, above] node {$-$} (v1m)
edge [out=east,in=west, above] node {$\alpha$} (v1f)
;

\end{tikzpicture}
  \caption{Example layout of a \emph{watch structure}.}
  \label{fig:watches} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

Given a nogood $\delta$ and an assignment $\ass$ we call the subset of literals in $\delta$ that might be \enquote{watched}, the candidate set. For the case of 2WL, the candidate set is simply the set of unassigned literals. However, with \emph{\mbt}, we have three pointers 

We call the set of literals that can be watched
For 2WL, only unassigned literals can we \enquote{watched}. Again, suppose some new assignment $\bX v$ is made, and 

\begin{definition}
The \emph{candidate sets} of a nogood $\delta$ under an assignment $A$ are subsets of the nogood  and defined as follows:

$$\cdpm(\delta, A) = \{\bsgl \in \delta \ | \ \bsgl \not \in \bass(\ass)\}$$

$$\cdal(\delta, A) = \{ \bT v \in \bodyf(\delta) \ | \ \bT v \not \in \ass \}$$

Intuitively, $C_\alpha(\delta, A)$ is the set of positive body literals in $\delta$ that are not assigned to be $\emph{true}$.
\end{definition}

\begin{definition}

A watch structure $\Delta$ \emph{\lowinv} an assignment $\ass$ iff for every nogood $\delta \in \Delta$ holds:

\begin{enumerate}
\item $|\cdpm(\delta, A)| \geq 2$ implies there exist $\bsgl_1, \bsgl_2 \in \cdpm(\delta, A)$ such that $\bsgl_1 \not = \bsgl_2$ and $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$, and
%Older version: \item If $\delta$ is not satisfied under $\ass$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ unassigned under $\ass$, then $\delta$ is contained in exactly two distinct watch sets, e.g. $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$ with $\bsgl_1 \not = \bsgl_2$.
\item $\cdal(\delta, A) \not = \emptyset$ implies that there is exactly one $\bsgl \in \cdal(\delta, A)$ with $\delta \in \dal(\bsgl)$.
\end{enumerate}
\end{definition}

Using watch structures that watch assignments, propagation can be implemented efficiently: Given $\Delta$ watching $\ass$ and a new assignment for some atom $\sgl = \bX v$ the nogoods that are candidates for propagation are those in $\dpm(\sgl)$ (in case $\sgl \not \in A$, thus $\sgl$ changes from \emph{unassigned} to \emph{true}, \emph{\mbt} or \emph{false}) and $\dal(\sgl)$ (in case $\sgl \in A$, thus $\sgl$ changes from \emph{\mbt} to \emph{true}).

However, with $\Delta$ watching $\ass$ and extending the assignment $\ass' = \ass \circ \sgl$, now $\Delta$ does not trivially watch $\ass'$.

\begin{definition}
A watch structure $\Delta$ is said to be \welf under some assignment $\ass$ in case all nogoods $\delta \in \Delta$ are \upinv under $\ass$ and $\Delta$ \lowinv $\ass$.
\end{definition}

In the next section, a closer look at propagation will reveal that when transitioning from an assignment to the next one, watch sets can be altered efficiently to obtain a well formed watch structure for the extended assignment.

\section{Unit Propagation}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		a~signed~literal~$\sgl$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation with literal $A[j]$ and $\Delta$ with updated watches.}
  $\langle \ass_1, \Delta_1 \rangle \leftarrow \langle \ass \circ \sgl, \Delta \rangle$ \label{alg:up:circ}\\
  $i \leftarrow 1$ \label{alg:up:i}\\
  \While{$|\ass_i| \geq |A| + i$\label{alg:up:loop:begin}}{
  $\langle \ass_{i+1}, \Delta_{i+1} \rangle \leftarrow$ \textsc{UnitPropagate}($\ass_{i}$, $\Delta_{i}$, $|A| + i$) \label{alg:up:loop:prop}\\
    $i \leftarrow i + 1$ \label{alg:up:loop:incr}
  } \label{alg:up:loop:end}
  \Return{$\langle \ass_i, \Delta_i \rangle$} \label{alg:up:ret}
  \caption{\textsc{UnitPropagateAll}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:up}
\end{algorithm}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		an~index~$j$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation and $\Delta$ with updated watches.}
%  \If{$|A| < j$}{\Return{$\langle \ass, \Delta \rangle$}}
  $\sgl \leftarrow \ass[j]$ \label{alg:up:loop:lit}\\
  $\langle \ass', \Delta' \rangle \leftarrow$ \textsc{UnitPropagationUnassigned}($\ass$, $\Delta$, $\sgl$)\\
  \If{$\sgl$ is of form $\bT v$}
  {
    $\langle \ass'', \Delta'' \rangle \leftarrow$ \textsc{UnitPropagationAssigned}($\ass'$, $\Delta'$, $\sgl_i$)\\
    \Return{$\langle \ass'', \Delta'' \rangle$}
  }
  \Return{$\langle \ass', \Delta' \rangle$}
  \caption{\textsc{UnitPropagate}($\ass$, $\Delta$, $j$)}
  \label{alg:upsingle}
\end{algorithm}

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~set~of~watched~nogoods~$\Delta$,~and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation and $\Delta$ with updated watches.}
%  \ForEach{$\delta \in w_{=2}(\Delta, \sigma)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned in $\mathbf{A}$}
%    {
%      $\mathbf{A} \leftarrow \mathbf{A} \circ \negweak{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dpm(\sgl)$ \label{alg:upu:it}}
  {
    \uIf{$\delta$ is violated \label{alg:upu:vio}}
    {
      \Return{$\langle \emph{conflict}, \Delta \rangle$ \label{alg:upu:conflict}}
    }
    \uElseIf{$\delta$ is strongly unit \label{alg:upu:su}}
    {
      $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upu:su:circ}
    }
    \uElseIf{$\delta$ is weakly unit with $\bsgl$ unassigned \label{alg:upu:wu}}
    {
      $\ass \leftarrow \ass \circ \negweak{\bsgl}$ \label{alg:upu:wu:circ}
    }
    \Else%If{there is some unassigned $\sigma' \in \delta$}
    { \label{alg:upu:else}
      \ForEach{$\bsgl \in \delta$}
      {
      	$\dpm(\bsgl) \leftarrow \dpm(\bsgl) \setminus \{ \delta \}$ \label{alg:upu:rm}
 	  }\label{alg:upu:move:start}
      Let $\bsgl_1, \bsgl_2 \in C_\pm(\delta, A)$ be arbitrary\\
      $\dpm(\bsgl_1) \leftarrow \dpm(\bsgl_1) \cup \{ \delta \}$\\
      $\dpm(\bsgl_2) \leftarrow \dpm(\bsgl_2) \cup \{ \delta \}$ \label{alg:upu:move:end}\\
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateUnassigned}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upu}
\end{algorithm}

Algorithm \ref{alg:upu} exhibits how unit propagation is used to infer assignments (of either false or \mbt) from watched nogoods. 
In line 1, the input literal $\sgl$ is transformed to its weak form as lookups in $\Delta$ are always made against the set of nogoods that might propagate in case the literal \mbt, even if $\sgl$ is of $\bT x$. % Why?
In the loop spanning from line 2-13 all nogoods that are to be checked for propagation according to $\Delta$ are iterated. For any such nogood one of the following three cases holds true
\begin{enumerate}
\item it is violated, leading to the algorithm immediately returning the conflicting assignment, or
\item it is weakly unit, in which case a new assignment can be inferred from the nogood, or
\item in any other case, there must be at least two unassigned literals in $\delta$, which are to be watched for changes in assignments.
% TODO: Does not (1.) and not (2.) guarantee that there are two unassigned literals?! Nogood could be satisfied.
\end{enumerate}

In case (3.), $\Delta$ is modified in lines 8-11. As $\sgl$ is now assigned, it should not be watched for changes anymore. This is achieved by removing $\delta$ from the set of watches $\Delta(\sgl)$ and instead adding it to the set of watches for two unassigned literals in $\delta$.

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~watch~structure~$\Delta$, and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation.}
%  \ForEach{nogood $\delta \in w_{=2}(\Delta)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned}
%    {
%      $\mathbf{A} \circ \negstrong{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dal(\sgl)$}
  {
	\uIf{$\delta$ is strongly unit}
	{
	  $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upa:su:circ}
	}
    \ElseIf{$C_\alpha(\delta, A) \not = \emptyset$}
    {
      \label{alg:upa:move:start}
      $\dal(\sgl) \leftarrow \dal(\sgl) \setminus \{ \delta \}$\\
      % Choose $\bsgl \in L$ s.t.~there is no $\bsgl' \in L$ with $\ass = (\ldots, \bsgl, \ldots, \bsgl', \ldots)$.\\
      Let $\sigma \in C_\alpha(\delta, A)$ be arbitrary\\
      $\dal(\bsgl) \leftarrow \dal(\bsgl) \cup \{ \delta \}$\\
      \label{alg:upa:move:end}
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateAssigned}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upa}
\end{algorithm}

%In order to implement efficient propagation, a data

% No Unfounded Set checks -> MBT.

% Explain 2WL with MBT, propagation with MBT (pseudocode of propagation algorithm).

% Invariant
For every nogood $\delta \in \Delta$, if $\delta$ contains at least two atoms unassigned under $\ass$, then $\delta$ is contained in exactly two watch lists.
%TODO define watch list!

\begin{theorem}
Algorithm \ref{alg:up} is sound, i.e.~given an assignment $\ass$, a watch structure $\Delta$, a literal $\sgl$, and the following preconditions, it results in a new assignment $\ass'$ and a new watch structure $\Delta'$ such that all following postconditions hold:

\begin{enumerate}[label={\normalfont (\textsc{Pre}\arabic*)},ref=(\textsc{Pre}\arabic*)]
\item $\Delta$ \lowinv $A$. \label{up:sound:pre2}
\item All nogoods $\delta \in \Delta$ are silent under $\ass$. \label{up:sound:pre1}
\end{enumerate}

\begin{enumerate}[label={\normalfont (\textsc{Post}\arabic*)},ref=(\textsc{Post}\arabic*)]
\item If $\sgl$ does not conflict with $\ass$ and there are assignments that can be inferred by means of unit propagation, then: \label{up:sound:post2}
\begin{enumerate}[label={\normalfont (\alph*)},ref=\theenumi(\alph*)]
\item $\Delta'$ \lowinv $\ass'$. \label{up:sound:post2b}
\item All nogoods $\delta \in \Delta'$ are silent under $\ass'$. \label{up:sound:post2a}
\end{enumerate}
\item If a literal inferred from $\Delta$ and $\ass \circ \sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$. \label{up:sound:post3}
\item If $\sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$ and $\Delta' = \Delta$. \label{up:sound:post1}% Trivial case.
\end{enumerate}
\end{theorem}

\begin{proof}
%We show that:

%\begin{enumerate}
%\item in case $\sgl$ conflicts with $\ass$, the algorithm will return the assignment \emph{conflict} and $\Delta$ is not guaranteed to be well formed,
%\item otherwise, the resulting watch structure $\Delta$ will be well formed wrt. the resulting assignment $\ass$.
%\end{enumerate}

%In line 1 of algorithm \ref{alg:up}, $\ass$ is altered by appending the given signed literal $\sgl$. Now, $\Delta$ might not be well formed wrt.~the altered assignment $\ass'$ anymore, because there might be some nogood $\delta \in \dpm(\sgl)$. By executing algorithm \ref{alg:upu}, $\Delta$ is transformed into a well formed watch structure $\Delta'$.

Before establishing a proof for \ref{up:sound:post2} and \ref{up:sound:post3} observe the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} of Algorithm \ref{alg:up} closely:

\begin{description}
\item[Initialization] Construct $A_1$ by appending $\sgl$ to $\ass$ (ln.~\ref{alg:up:circ}). Initialize some loop counter $i = 1$ (ln.~\ref{alg:up:i}). It points at the next literal on which propagation should be performed, i.e.~initially $\sgl = \ass_1[|\ass| + 1]$. 

\item[Iteration] Let the pair $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle = \textsc{UnitPropagate}(\ass_i, \Delta_i, \ass_i[|A| + i])$ (ln.~\ref{alg:up:loop:prop}) denote the output of the $i$-th iteration which performs propagation on assignment $\ass_i$, watch structure $\Delta_i$ and literal $\ass_i[|A| + i]$ (ln.~\ref{alg:up:loop:lit}). Conversely $S_i$ can be interpreted as the input for the $i$-th iteration. Analysis of the difference between $\Delta_{i}$ and $\Delta_{i+1}$ is what resembles soundness below.

\item[Termination] Because the number of literals in all nogoods $\delta \in \Delta$ is finite, for some $i = k$ the loop invariant (ln.~\ref{alg:up:loop:begin}) is violated, i.e.~$|A| + i > |\ass_{i}|$. Intuitively, this is the case if no new assignment can be inferred ($S_{k-1} = \langle \ass_{k-1}, \Delta_{k-1} \rangle$ and $S_k = \langle \ass_k, \Delta_k \rangle$ with $\ass_{k-1} = \ass_k$) or a conflict is reached ($\ass_k = \emph{conflict}$). When the loop terminates, $\langle \ass', \Delta' \rangle = S_k$ is returned (ln.~\ref{alg:up:ret}).
\end{description}

Towards showing \ref{up:sound:post2} and \ref{up:sound:post3} by induction, assume that $\sgl$ does not conflict with $\ass$ and let $\mathcal{P}(n) = \textrm{\ref{up:sound:ind:noconflict}} \vee \textrm{\ref{up:sound:ind:conflict}}$ where

\begin{enumerate}[label=(\Roman*)]
	\item Let $\ass_n^L = \ass_n[1, |A| + n - 1], \ass_n^R = \ass_n[|A| + n, |\ass_n|]$. For each $\delta$ in $\Delta$: \label{up:sound:ind:noconflict}
		\begin{enumerate}[label=(\alph*),ref=\theenumi(\alph*)]
			\item $\Delta_n$ watches $\ass^L_n$. \label{up:sound:ind:watches} % Or watches \ass^L_n?
			\item If $\delta$ is weakly unit under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:wu}
			\item If $\delta$ is strongly unit under $\ass_n$, then $\exists {\bT v_1} \in A_n^R : \delta \in \Delta_n^\alpha(v_1)$ or $\exists {\bF v_2} \in A_n^R : \delta \in \Delta_n^\pm({\bF v_2})$. \label{up:sound:ind:su}
			\item If $\delta$ is violated under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:vio}
		\end{enumerate}
	\item $\ass_n = \emph{conflict}$ \label{up:sound:ind:conflict}
\end{enumerate}

\paragraph{Base Case} Concerning the input assignment $\ass_0 = \ass$ and $\Delta_0 = \Delta$, $\mathcal{P}(0)$ directly follows, because \ref{up:sound:ind:watches} amounts to \ref{up:sound:pre2}, and \ref{up:sound:pre1} implies that the antecedents of \ref{up:sound:ind:wu}, \ref{up:sound:ind:su}, \ref{up:sound:ind:vio} are false.

%The induction step now consists of observing that the loop in lines 3-10 \enquote{preserves} properties (1.) and (2.) of soundness, i.e.~it argues the transitivity of those properties for iteration steps $S_{i}$ to $S_{i+1}$.

%We show that every nogood $\delta \in \Delta'$ is \welf wrt.~$\Delta'$ and $\ass'$, i.e.~$\Delta'$ is \welf wrt.~$\ass'$, by using that $\Delta$ is \welf wrt.~$\ass$ and the definition of the algorithm.

\paragraph{Induction Hypothesis} $\mathcal{P}(i)$ holds for some $i$.

\paragraph{Induction Step} For two consecutive iteration steps $S_{i} = \langle \ass_{i}, \Delta_{i} \rangle$ and $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle$, assume $\mathcal{P}(i)$. For readability, let $j = |A| + i$, $\ass_i^L = \ass_i[1, j - 1]$, $\ass_i^R = \ass_i[j, |\ass_i|]$, $\ass_{i+1}^L = \ass_i[1, j]$, $\ass_{i+1}^R = \ass_i[j + 1,|\ass_{i+1}|]$, $\sgl_i = A_i[j]$. Then show $\mathcal{P}(i) \to \mathcal{P}(i + 1)$ as follows:

\paragraph{Intuition} $\ass_i^R$ is the \enquote{right} subsequence of the assignment, which contains all assignments that already are processed and will not cause propagation. Conversely, $\ass_i^L$ is the \enquote{left} subsequence, and contains all the literals that might still cause unit propagation. Note that $\sgl_i \not \in \ass_i^L$, $\sgl_i \in \ass_i^R$ and $\sgl_i \in \ass_{i+1}^L$, $\sgl_i \not \in \ass_{i+1}^R$, intuitively in the $i$-th iteration, $\sgl_i$ \enquote{moves} from the \enquote{right} subsequence of the assignment to its \enquote{left} subsequence. As expected, the two subsequences united add up to the full sequence $A_i = A_i^L \cup A_i^R$. Further the \enquote{right} subsequence \enquote{grows} (with the exception of $\sgl_i$), i.e.~$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$. Also, $\ass_{i+1}^L = \ass_{i}^L \cup \{ \sgl_i \}$ is useful.

\todo{$\Delta$ as the set of all nogoods in the program?}

\begin{enumerate}
\item To show \ref{up:sound:ind:watches}: $A_i^L$ differs from $A_{i+i}^L$ only by $\sgl_i$, which is processed by Algorithm \ref{alg:up}. Note that for two watches $\Delta_{i}$ and $\Delta_{i+1}$ containing the same nogoos $\Delta$, the size of candidate sets (bot $\cdpm$ and $\cdal$) for all nogoods in $\Delta$ monotonically decreases as the size of the assignment $A_i^L$ respectively $A_{i+i}^L$ increases. This follows from the definition of candidate sets.
\begin{enumerate}
	\item Assume $\sgl_i \not = \bT v$. Then Algorithm \ref{alg:upu} is invoked and processes all nogoods $\delta \in \dpm(\sgl)$. For any $\delta$, if $|\cdpm(\delta, A)| \geq 2$, then $\delta$ is inserted into the watches for exactly two candidates in lines \ref{alg:upu:move:start}-\ref{alg:upu:move:end}.
	\item Assume $\sgl_i = \bT v$. Then Algorithm \ref{alg:upa} is invoked and processes all nogoods $\delta \in \dal(\sgl)$. For any $\delta$, if $|\cdal(\delta, A)| \not = \emptyset$, then $\delta$ is inserted into the watches for exactly one candidate in lines \ref{alg:upa:move:start}-\ref{alg:upa:move:end}. 
\end{enumerate}

If $\sgl_i \in \Delta$ then the premises of the \enquote{watch} property regarding candidate sets are false, or pointers were moved such that $\sgl_i$ does not watch $\delta$ anymore.

\item To show \ref{up:sound:ind:wu}, let $\delta \in \Delta$ and assume $\delta$ is weakly unit under $\ass_{i+1}$ (else, \ref{up:sound:ind:wu} trivially holds):
\begin{enumerate}
	\item Assume $\delta$ is weakly unit under $\ass_i$. \label{pr:corr:wu:wu}
	
	Then $\exists \sgl \in \ass_i^R : \delta \in \Delta_i^\pm(\sgl)$ by the induction hypothesis. 
	
	Assume towards contradiction that $\sgl = \sgl_i$. As $\delta \in \dpm_i(\sgl)$, the weak complement of $\sgl$ is appended to the assignment (Algorithm \ref{alg:upu}, line \ref{alg:upu:wu:circ}), thus $\negweak{\sgl} \in A_{i+1}$. Then $\delta$ is not weakly unit under $A_{i+1}$ contradicting our assumption.
	
	Therefore, $\sgl \not = \sgl_i$. From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$. Further, we see that $\delta \in \dpm_{i}(\sgl)$ implies $\delta \in \Delta_{i+1}^\pm(\sgl)$ because of the behavior of Algorithm \ref{alg:upu} in case $\sgl \not = \sgl_i$ and $\delta$ being weakly unit: The set of nogoods that are considered for processing is indicated in line \ref{alg:upu:it} and consists of exactly those nogoods that are element of $\dpm_{i}(\sgl)$. From $\sgl \not = \sgl_i$ we know that the algorithm will not consider $\delta$ an specifically not add or remove it from any watch set $\dpm$. Thus we have $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:wu} holds.
%\end{enumerate}
	\item Assume $\delta$ is not weakly unit under $A_i$.
	
	Then $\cdpm(\delta, \ass_{i}) \geq 2$ and because $\Delta_i$ watches $A_i$ (ind.~hyp.), we have $\exists \bsgl_1, \bsgl_2 \in \delta : \bsgl_1 \not = \bsgl_2 \wedge \delta \in \Delta_i^\pm(\bsgl_1) \wedge \delta \in \Delta_i^\pm(\bsgl_2)$. We distinguish on whether $\sgl_i$ coincides with one of the watched literals:

	\begin{enumerate}
		%\item Assume $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$ towards a contradiction. As $\bsgl_1, \bsgl_2 \in \cdpm(\delta, \ass_i)$, both $\bsgl_1, \bsgl_2$ are unassigned under $\ass_i$ by definition of $\cdpm$. For $\delta$ to be weakly unit under $\ass_{i+1}$, there must be exactly one $\bsgl' \in \delta$ unassigned under $\ass_{i+1}$.
		\item Case $\sgl_i \not = \bsgl_1 \wedge \sgl_i \not = \bsgl_2$.
		
		$\Delta_i^\pm(\bsgl_1) = \Delta_{i+1}^\pm(\bsgl_1)$ and $\Delta_i^\pm(\bsgl_2) = \Delta_{i+1}^\pm(\bsgl_2)$, as watch sets are only modified in case $\bsgl_1 = \sgl_i$ and respectively $\bsgl_2 = \sgl_i$ (see Algorithm \ref{alg:upu}: only nogoods that are being iterated over in line \ref{alg:upu:it} are being removed from any watch sets in line \ref{alg:upu:rm}). Both $\bsgl_1$ and $\bsgl_2$ are in $A_{i+1}^R$, because $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, thus we have \ref{up:sound:ind:wu}.
		
		\item Case either $\sgl_i = \bsgl_1$ or $\sgl_i = \bsgl_2$.
		\label{sigmaprimes}		
		
		Without loss of generality ($\bsgl_1$ and $\bsgl_2$ arbitrary in $\cdpm(\delta, \ass_i)$), let $\sgl_i = \bsgl_1$. Therefore, $\bsgl_1 \not \in A_{i+1}^R$ and $\bsgl_2 \in A_{i+1}^R$. While processing $\delta$, in Algorithm \ref{alg:upu} the branch in line \ref{alg:upu:else} is taken (otherwise $\delta$ cannot be unit under $\ass_{i+1}$. All candidates $\cdpm(\delta, \ass_i)$ except $\bsgl_1$, and therefore any literals $\bsgl_1', \bsgl_2'$ (arbitrarily) chosen in the algorithm, are either unassigned under $\ass_{i+1}$ or in $\ass_{i+1}^R$. As $\delta$ is unit under $\ass_{i+1}$, exactly one of these must be unassigned.
		Assume (w.l.o.g., symmetric) $\bsgl_1'$ unassigned under $A_{i+1}$ and $\bsgl_2' \in \ass_{i+1}^R$. Then \ref{up:sound:ind:wu} holds for $\bsgl_2'$.
		
		\item Case $\bsgl_1 = \sgl_i \wedge \bsgl_2 = \sgl_i$ is impossible because $\bsgl_1 \not = \bsgl_2$.
		\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:su}, let $\delta \in \Delta$ and assume $\delta$ is strongly unit (and therefore also weakly unit or $\headf(\delta) = \bM v$) under $\ass_{i+1}$ (else, \ref{up:sound:ind:su} trivially holds):
\begin{enumerate}
	\item Case $\delta$ is strongly unit under $\ass_i$. Then $\exists {\bT v_1} \in \ass_i^R : \delta \in \dal_i(v_1)$ or $\exists {\bF v_2} \in \ass_i^R : \delta \in \dpm_i({\bF v_2})$ via induction hypothesis.
	\begin{enumerate}
		\item Case $\sgl_i = {\bT v_1}$. Then Algorithm \ref{alg:upa} appends the strong complement of the head (line \ref{alg:upa:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
		\item Case $\sgl_i = {\bF v_2}$. Then Algorithm \ref{alg:upu} appends the strong complement of the head (line \ref{alg:upu:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
			%\item Case $\sgl_i = {\bT v_1} \wedge \sgl_i = {\bF v_2}$ is contradictory. \contradiction % Amounts to the case where $\sgl_i = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$ because algorithm \ref{alg:upu} is executed before algorithm \ref{alg:upa}, which degrades to a no-operation, because $\delta$ is neither strongly unit, nor is $C_\alpha(\delta, A)$ (where $A$ is defined in the scope of the algorithm, a hybrid state between $A_i$ and $A_{i+1}$) non-empty when it is executed.
		\item Case $\sgl_i \not = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$.
		From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that if ${\bT v_1}, {\bF v_2}$ exist, they are in $\ass_{i+1}^R$. Also, $\delta \in \dal_i(v_1)$ implies $\delta \in \dal_{i+1}(v_1)$ and $\delta \in \dpm_i({\bF v_2})$ implies $\delta \in \dpm_{i+1}({\bF v_2})$ because $\delta$ is strongly unit and $\sgl_i \not \in \delta$. So we have $\exists {\bT v_1} \in \ass_{i+1}^R : \delta \in \dal_{i+1}(v_1)$ or $\exists {\bF v_2} \in \ass_{i+1}^R : \delta \in \dpm_{i+1}({\bF v_2})$, i.e.~\ref{up:sound:ind:su}. % TODO: \sgl might actually change (pointer move) which is not mentioned here. If this does not get mentioned in the watches section of the proof, add a remark here explaining that \sgl might change in the course of algorithm 3.3 but only in a way that fulfills above criteria.
	\end{enumerate}
	
	
	\item Case $\delta$ is not strongly unit under $A_i$. Then, $\bodyf(\delta) \setminus A_i \not = \emptyset$.


	\begin{enumerate}
		\item Case ${\bT v} \in \bodyf(\delta) \setminus A_i$.
		
		Then, $C^\alpha(\delta, A_{i}) \not = \emptyset$. Because $\Delta_i$ watches $\ass_i$ it follows that $\exists \bsgl \in C_\alpha(\delta, A_i): \delta \in \dal(\sigma)$.
		
		\begin{enumerate}
			\item Case $\sgl_i = \bsgl$.
			
			leads to a contradiction ($\delta$ not strongly unit under $A_{i+1}$)
			
			\item Case $\sgl_i \not = \bsgl$.
			
			$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, we have $\bsgl \in \ass_{i+1}^R$, thus $\exists \bsgl \in \ass_{i+1}^R : \delta \in \dal_{i+1}(\bsgl)$, i.e.~\ref{up:sound:ind:su}. \todo{Why $\delta \in \dal_{i+1}(\bsgl)$?}
		\end{enumerate}			
			
		\item Case ${\bT v} \not \in \bodyf(\delta) \setminus A_i$.
			\begin{enumerate}
				\item Case $\negweak{\headf(\delta)} \not \in A_{i} \wedge \negstrong{\headf(\delta)} \not \in A_{i}$, i.e.~the head is unassigned. Then there are at least two literals in $\delta$ unassigned under $A_i$ (one in the body and the head). From \ref{up:sound:ind:watches} we have $\bsgl_1, \bsgl $
				\item Case $\negweak{\headf(\delta)} \in A_{i}$.
				If $|\bodyf(\delta) \setminus A_i| \geq 2$, then there are at least two unassigned literals. Else if $\bodyf(\delta) \setminus A_i = \{ {\bF v} \}$, then $\delta$ is weakly unit.
			\end{enumerate}
	\end{enumerate}


%	\begin{enumerate}
%		\item Case $\bT v \in \bodyf(\delta) \setminus A_i$. If $\headf(\delta) \not \in A_i$ then there are at least two distinct literals $\bsgl_1, \bsgl_2 \in \delta$ (one in the body, and the head) that are unassigned unter  $A_i$ and \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$. Else, i.e.~$\headf(\delta) \in A_i$, then $|\bodyf(\delta) \setminus A_i| \geq 2$, thus \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$.
%		\item Case $\bodyf(\delta) \setminus A_i = \{ \bF v' \}$, i.e.~$\delta$ is weakly unit under $A_i$, then according to \ref{up:sound:ind:wu}, $\exists \ \bsgl \in \bass(A_i^R) : \delta \in \Delta_i^\pm(\bsgl)$. From $A_i^R \cap \delta \subseteq \{ \bF v' \}$ follows that $v = v'$ and thus \ref{up:sound:ind:su}.
%	\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:vio}, let $\delta \in \Delta$ and assume $\delta$ is violated under $A_{i+1}$ (else \ref{up:sound:ind:vio} trivially holds).
\begin{enumerate}
\item Assume $\delta$ is violated under $A_i$.

Then $\exists \sgl \in \ass_i^R : \delta \in \dpm_i(\sgl)$ via induction hypothesis.
\begin{enumerate}
\item Case $\sgl = \sgl_i$.

Then, according to Algorithm \ref{alg:upu} (line \ref{alg:upu:conflict}) $A_{i+1} = \emph{conflict}$, so \ref{up:sound:ind:conflict} holds.

\item Case $\sgl \not = \sgl_i$.

Then, from $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$, thus $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$. Also $\delta \in \dpm_i(\sgl)$ implies $\delta \in \dpm_{i+1}(\sgl)$, as watch sets are only modified for nogoods that are watched by $\sgl_i$. So we have $\exists \sgl \in \ass_i^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:vio} holds.
\end{enumerate}
\item Assume $\delta$ is not violated under $A_i$. Then $|\bass(A_i) \setminus \delta| \geq 1$  holds by Definition \ref{def:vio}.

\begin{enumerate}
\item Assume $|\bass(A_i) \setminus \delta| \geq 2$. Then because $\Delta_i$ watches $A_i$ it follows that $\exists \bsgl_1, \bsgl_2 : \delta \in \Delta_i^\pm(\bsgl_1), \Delta_i^\pm(\bsgl_2)$. Further $\bsgl_1 \not = \sgl_i$ or $\bsgl_2 \not = \sgl_i$, so w.l.o.g.~$\bsgl_1 \not = \sgl_i$, so $\exists \ {\bX v} \in X : \delta \in \Delta_{i+1}^\pm(v)$ with a reasoning similar to \ref{sigmaprimes}.

\item Assume $|\bass(A_i) \setminus \delta| = 1$. Then $\delta$ is weakly unit under $A_i$, thus this case amounts to \ref{pr:corr:wu:wu}.
\end{enumerate}

\end{enumerate}

\end{enumerate}

\begin{comment}
\begin{enumerate}
\item If $\sgl_i \not \in \delta$, then: % A nogood only contains boolean signed literals, so dies this even make sense? \sgl is a signed literal, not a boolean signed literal, so how can it be element of delta? Needs clarification.
\begin{enumerate}
\item $\delta$ is not violated under $\abef$ (inv1). Therefore, $\delta$ is not violated under $\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item $\delta$ is not unit wrt.~$\abef$ (inv2). Therefore, $\delta$ is not unit wrt.~$\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned wrt.~$\aaf$. Then $\bsgl_1$ and $\bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied under $\abef$, because $\abef \subset \aaf = \abef \circ \sgl_i$ and $\sgl_i \not \in \delta$. Therefore, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ must hold (inv3). For the same two literals, $\delta \in \daf^\pm(\bsgl_1)$ and $\delta \in \daf^\pm(\bsgl_2)$ holds. % Needs clarification. Reference the loop that the nogood is certainly not part of.
\item Analogous to (c), if $\delta$ has any triggers, their assignment does not change, as $\sgl_i \not \in \delta$, and no watches $\delta \in \dbef^\alpha(\bsgl)$ are changed. The same $\bsgl$ will satisfy $\delta \in \dbef^\alpha(\bsgl)$ for $\abef$ and $\aaf$.
\end{enumerate}
\item Else ($\sgl_i \in \delta$):
\begin{enumerate}
\item If $\delta \not \in \dbef^\pm(\sgl_i)$, i.e.~$\delta$ was not watched on $\sgl_i$, then
\begin{enumerate}
\item To show that $\delta$ is not violated by $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not violated under $\aaf$ as $\delta$ is not violated by $\abef$ (inv1) and $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals in $\delta$ unassigned wrt.~$\abef$ as $\delta$ is not unit wrt.~$\abef$ (inv2). From $|\aaf| = |\abef| + 1$ if follows that there must be at least one literal in $\delta$ which is unassigned wrt.~$\aaf$, therefore $\delta$ cannot be violated under $\aaf$.
\end{enumerate}
\item To show that $\delta$ is not unit under $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not unit under $\aaf$ because $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ that are unassigned wrt.~$\abef$, as $\delta$ is not unit under $\abef$ (inv2). Further, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ (inv3). From $\delta \not \in \dbef^\pm(\sgl_i)$ it follows that $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$. % How are binary signed literals and signed literals compared?
Therefore $\delta$ is not unit, because $\bsgl_1, \bsgl_2 \in \delta$ are unassigned wrt.~$\aaf$.
\end{enumerate}
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned under $\aaf$. Then $\bsgl_1, \bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied wrt.~$\abef$ because $\abef \subset \aaf$ and $\delta \not \in \dbef^\pm(\sgl_i)$ and $\delta$ is not unit wrt.~$\abef$.
\item Same as 1.d ...
\end{enumerate}
\item Else ($\delta \in \dbef^\pm(\sgl_i)$), i.e.~$\delta$ was watched on $\sgl_i$.
\begin{enumerate}
\item If $\delta$ is weakly unit under $\aaf$ with $\bsgl$ unassigned, then the algorithm generates the assignment $\negweak{\bsgl}$.
\item Else
\item If there are two unassigned pointer move $\to$ two unassigned literals
\item pointer move $\to$ two unassigned literals
\item violated $\to$ conflict
\item weakly unit $\to$ satisfied
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{comment}

Above induction step serves as an explanation on how execution of the loop affects the assignment and especially the watch structure. By using induction, $\mathcal{P}(i)$ was shown for any $i \geq 0$, and therefore for any iteration of the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} as well. Specifically $\mathcal{P}(i)$ holds for the last iteration $i = k$ represented by $S_k = \langle \ass_k, \Delta_k \rangle$.

For cases without conflict and the loop terminating at $S_k$, \ref{up:sound:post2b} is obvious from \ref{up:sound:ind:watches} as $\ass' = \ass_k$ and $\Delta' = \Delta_k$. From termination follows $A_k^R = \emptyset$, i.e.~there are no nogoods $\delta \in \Delta'$ that are weakly unit, strongly unit or violated under $\ass'$, thus all $\delta$ are silent under $\ass'$ which amounts to \ref{up:sound:post2a}.

Cases in the induction step leading to show \ref{up:sound:ind:conflict} map to \ref{up:sound:post3}.

To show \ref{up:sound:post1} rather trivially: Assume $\sgl$ conflicts with $\ass$. Then, on line~\ref{alg:up:circ} of the algorithm $\ass$ will be assigned \emph{conflict}. Consequently, the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} is not executed as $|\emph{conflict}| = 0$ and $i$ must be at least 1, as it is assigned 1 on line \ref{alg:up:i}. $\langle \ass, \Delta \rangle$ is returned.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is complete.
\end{theorem}

\begin{proof}
Indirect proof, showing that if there is an assignment that results from propagation it will be generated.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is sound and complete.
\end{theorem}

\begin{proof}

\end{proof}

\chapter{Conclusion}

\section{Related Work}

\section{Conclusion}

\section{Future Work}

\cite{effstructs} suggest other effective schemes for propagation.

\subsection{Related Work}

\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
%\printglossaries

% Add a bibliography.
%\bibliographystyle{alpha}
\bibliographystyle{plainnat}
\bibliography{thesis}

\end{document}

