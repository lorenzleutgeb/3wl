\documentclass{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{fixltx2e}   % Provides fixes for several errors in LaTeX2e.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amsthm}
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage{enumitem}   % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last.
\usepackage{xspace}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{shapes.multipart,calc}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}

% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Lorenz Leutgeb} % The author name without titles.
\newcommand{\thesistitle}{Efficient propagation for lazy-grounding Answer Set solving} % The title of the thesis. The English version should be used, if it exists.

\hypersetup{
    pdfpagelayout   = TwoPageRight,
    linkbordercolor = {Melon},
    pdfauthor       = {\authorname},
    pdftitle        = {\thesistitle},
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {asp, solver, propagation, nogood}
}

\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Prof.~Dr.}{Thomas Eiter}{}{male}

% For bachelor and master theses:
\setfirstassistant{Dr.}{Antonius Weinzierl}{}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

\setaddress{Engilgasse 3a, 1160 Wien}
\setregnumber{1127842}
\setdate{31}{10}{2016} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{Efficient propagation for lazy-grounding Answer Set solving} % Sets English and German version of the title (both can be English or German).
%\setsubtitle{Optional Subtitle of the Thesis}{Optionaler Untertitel der Arbeit} % Sets English and German version of the subtitle (both can be English or German).

\setthesis{bachelor}

\setcurriculum{Software \& Information Engineering}{Software \& Information Engineering} % Sets the English and German name of the curriculum.

% Define convenience macros.
\newcommand{\todo}[1]{{\color{red}\textbf{TODO: {#1}}}} % Comment for the final version, to raise errors.

\theoremstyle{example}
\newtheorem{example}{Example}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}[section]

\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}[theorem]

\theoremstyle{corollary}
\newtheorem{corollary}{Corollary}[theorem]

\newtheorem*{remark}{Remark}

\newcommand{\mbt}{must-be-true}
\newcommand{\negstrong}[1]{\overline{#1}^s}
\newcommand{\negweak}[1]{\overline{#1}^w}

% Function B transforming an assignment into a boolean assignment.
\newcommand{\bass}{\mathcal{B}}

% An assignment A.
\newcommand{\ass}{A}

% Herbrand Base function of some logic program.
\newcommand{\hb}{\textit{HB}}

\newcommand{\bT}{\mathbf{T}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\fabef}{\ass_{i}}
\newcommand{\faaf}{\ass_{i + 1}}
\newcommand{\abef}{\fabef[\ldots, k + i]}
\newcommand{\aaf}{\faaf[\ldots, k + i + 1]}
\newcommand{\dbef}{\Delta_{i}}
\newcommand{\daf}{\Delta_{i+1}}
\newcommand{\welf}{well formed\xspace}
\newcommand{\upinv}{stable\xspace}
\newcommand{\lowinv}{watches\xspace}
\newcommand{\stbl}{stable\xspace}


\newcommand{\sgl}{\mu}
\newcommand{\bsgl}{\sigma}

\newcommand{\thrice}{{\{\bT, \bM, \bF \}}}

\newcommand{\wkn}{\textit{weaken}}

\usepackage{csquotes}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian}
\addtitlepage{english}
\addstatementpage

\begin{danksagung*}
\todo{Ihr Text hier.}
\end{danksagung*}

\begin{acknowledgements*}
\todo{Enter your text here.}
\end{acknowledgements*}

\begin{kurzfassung}
\todo{Ihr Text hier.}
\end{kurzfassung}

\begin{abstract}
\todo{Enter your text here.}
\end{abstract}

\selectlanguage{english}

\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}

Answer Set Programming (ASP) is a programming paradigm aimed at solving problems by means of declarative and logic programming based on Nonmonotonic Reasoning. 

\section{Motivation}

\section{Problem Statement}

\section{Aim of the Work}

\section{Methodological Approach}

\section{Structure of the Work} % 3 sentences

This is just a test.\cite{Gebser:2012:CAS:2228640.2228952}

\chapter{Preliminaries}
\label{chap:preliminaries}

\section{Answer Set Programming}

% TODO: Introduction to ASP and it's semantics.

\section{State of the Art in ASP Solving}

% Two Watched Literals?

\subsection{Approaches based on Pre-Grounding}

% TODO: Explain how a solver works and what has been done already (grounding on the fly, omiga, asperix).
% TODO: What is a nogood? What is propagation?

% Everything that later sections build up on. Quote a lot. This chapter can be long. Show understanding of the matter in own words (i.e. what is an answer set incl. example?).

\subsection{Approaches based on Lazy Grounding}

\section{Analysis}

\section{Comparison and Summary of Existing Approaches}

\todo{Enter your text here.}

\chapter{Propagation for lazy-grounding Answer Set solving}

This chapter contextualizes propagation by providing definitions extending chapter \ref{chap:preliminaries}. It then presents and thoroughly explains the algorithms and data structures involved in propagation and concludes in a proof of soundness and completeness thereof.

\section{Definitions}

% Signed literal vs. boolean signed literal.

Following definitions lay out the vocabulary and concepts towards an explanation of unit propagation. Most of them fundamentally depend on \emph{atoms} (usually denoted $v$) but do not refer to neither a set of atoms nor their domain. This is because all definitions are bound to a logic program $P$ to be solved (i.e.~to find answer sets for). The set of ground atoms wrt.~$P$, effectively its Herbrand Base $\textit{HB}(P)$, is obtained by the grounding process, which is not detailed in this work. What might seem to be lacking from the definitions therefore is the context of the input program $P$ and therefore the domain of atoms. $P$ and its context is omitted in the following.

\subsection{Literals}

% TODO: Where does v come from? Should be in some HB(P)?
%\begin{definition}
%A \emph{ground atom} (or simply \emph{atom}) wrt.~a logic program $P$ is an element of $\textit{HB}(P)$, usually denoted $v$.
%\end{definition}

%\begin{definition}
A \emph{boolean signed literal} $\bsgl$ of the form $\bT v$ or $\bF v$ where $v$ is an atom and  $\bT v$ expresses that $v$ is \emph{true}, and $\bF v$ that it is \emph{false}.
%\end{definition}

%\begin{definition}
From boolean signed literals, generalize to $\sgl$ called a \emph{signed literal} of the form $\bT v$, $\bM v$ or $\bF v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, $\bM v$ that it \emph{must be true}, and $\bF v$ that it is \emph{false}.
%\end{definition}

%\begin{definition}
%The function $\wkn(\bsgl)$ takes a boolean signed literal $\bsgl$ and transforms it into a signed literal referred to as its \emph{weak form}, meaning that while \emph{false} stays \emph{false}, e.g.~$\wkn(\bF v) = \bF v$, \emph{true} is mapped to \emph{\mbt}, e.g.~$\wkn(\bT v) = \bM v$.
%\end{definition}

% TODO: Remark on boolean signed literal vs. signed literal with context of clasp?

\begin{definition}
Strong complement, denoted by $\negstrong{\sgl}$, and weak complement, $\negweak{\sgl}$, mapping $\bF v$ to $\bT v$ and $\bF v$ to $\bM v$ respectively, of a signed literal are defined by the following truth table:%equalities: $\negstrong{\bT v} = \bF v$, $\negstrong{\bM v} = \bF v$ and  $\negstrong{\bF v} = \bT v$, while $\negweak{\bT v} = \bF v$, $\negweak{\bM v} = \bF v$ and $\negweak{\bF v} = \bM v$.
% "andere Richtung auch erkl√§ren"

\begin{center}
\begin{tabular}{|c|cc|}
\hline
$\sgl$&$\negstrong{\sgl}$&$\negweak{\sgl}$\\
\hline
\hline
$\bT v$&$\bF v$&$\bF v$\\
$\bM v$&$\bF v$&$\bF v$\\
$\bF v$&$\bT v$&$\bM v$\\
\hline
\end{tabular}
\end{center}
\end{definition}

Occasionally the notation $\sgl = \bX v$ will be used to express that $\sgl$ is a literal of $v$ where $\bX \in \thrice$, i.e.~$\sgl$ is \enquote{bound} to $v$, but the sign is not important.

\subsection{Assignments}

\begin{definition}
An \emph{assignment} $\ass$ is a sequence $(\sgl_1, \ldots, \sgl_n)$ of signed literals $\sgl_i = \bX v_i$ where $v_i \not = v_j$ for $1 \leq i < j \leq n$, or \emph{conflict}.
\end{definition}

%\begin{remark}
Below, assignments are sometimes also used as sets, in which case the set represented by some assignment is simply the set of all signed literals contained in the sequence.
%\end{remark}

The number of elements in an assignment $|\ass|$ is intuitive, with $|\emph{conflict}| := 0$.

The assignment obtained by appending the literal $\sgl$ to $\ass$ is denoted by $\ass' = \ass \circ \sgl$. In case $\negstrong{\sgl} \in \ass$ or $\negweak{\sgl} \in \ass$ however, $\ass \circ \sgl := \emph{conflict}$ to indicate that appending $\sgl$ conflicts with other literals in $\ass$. Furthermore $\emph{conflict} \circ \sgl := \emph{conflict}$ for any $\sgl$. Appending preserves that for any atom $v$ there is at most one literal in the assignment: With $\sgl = \bT v$ and $\bM v \in \ass$, for $\ass' = \ass \circ \sgl$ it holds that $\bM v \not \in \ass'$ (and $|\ass'| = |\ass|$).

%\begin{definition}
For every assignment, a respective \emph{boolean assignment}, denoted $\bass(\ass)$ can be constructed by collapsing all atoms that \emph{must be true} to being \emph{true}:$$\bass(\ass) = \{ \sgl \in \ass \ | \ \sgl = \bT v \textrm{ or } \sgl = \bF v \} \cup \{ \bT v \ | \ \bM v \in \ass \}$$

\begin{definition}
An atom $v$ is \emph{unassigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} = \emptyset$$
\end{definition}

\begin{definition}
A signed literal $\bX v$ with $\bX \in \thrice$ is \emph{unassigned} under $\ass$ iff $v$ is unassigned under $\ass$.
\end{definition}

\subsection{Nogoods}

\begin{definition}
A \emph{nogood} reflects a partial assignment that cannot be extended to a solution. Here, a \emph{nogood} is a set $\{ \bsgl_1, \ldots, \bsgl_n \}$ of boolean signed literals.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{weakly unit} under an assignment $\ass$ iff $\delta \cap \bass(\ass) = \{ \bsgl \}$
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{strongly unit} under an assignment $\ass$ iff $\delta \cap \ass = \{ \bsgl \}$
\end{definition}

Note that, as the names suggest, any nogood that is strictly unit under some assignment is also weakly unit, but not the other way round. Below, nogoods are sometimes referred to be \emph{unit} which amounts to stating that they are weakly unit. Also, when clear from context, reference to a particular assignment is omitted.

\begin{definition}
A nogood $\delta$ is \emph{satisfied} under an assignment $\ass$ iff there is no $\ass' \supseteq \ass$ s.t.~$\delta$ is violated under $\ass'$.
\end{definition}

For the purpose of unit propagation, it is important to see that because a satisfied nogood will never be unit, therefore never yield a new assignment using unit propagation.

\begin{definition}
A nogood $\delta$ is \emph{violated} under an assignment $\ass$ iff $\delta \subseteq \bass(\ass)$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{\upinv} under some assignment $\ass$ iff $\delta$ is not violated by $\ass$ and $\delta$ is not unit wrt.~$\ass$.
\end{definition}

Note the difference between some $\delta$ being \upinv vs.~satisfied under an assignment: With $\delta$ being \upinv under $\ass_1$, there might well be some $\ass_1' \supset \ass_1$ under which $\delta$ is unit or violated. However $\delta$ satisfied under $\ass_2$ is stronger and implies that there is no \enquote{larger} assignment $\ass_2' \supset \ass_2$ such that $\delta$ is not satisfied under $\ass_2'$ by definition. It follows that $\delta$ can neither be unit nor violated under $\ass_2'$.

When implementing propagation, na{\"i}vely obtaining checking a large set of nogoods that represents an ASP program for unity is infeasible. Sophisticated data structures are needed to make propagation sufficiently fast.

\subsection{Watch structures}

\begin{definition}
% ASK: Why not define watch structure as a function/relation mapping from atom to watch sets? Structure is irrelevant, and mapping function is closer to a map in code.
% ASK: How to omit irrelevant elements of a tuple?
A \emph{watch structure} is a function that maps atoms $v$ to triples containing sets of nogoods, the so called \emph{watch sets} of $v$: $$\Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

%For any watch set $W$ in $\Delta(v)$ and nogood $\delta \in W$ it follows that $\bX v \in \delta$.

For some signed literal $\sgl = \bX v$ let $$\Delta^\pm(\sgl) = \left\{\begin{array}{ll}
        W^+ & \text{if } \sgl = \bT v \ \text{or } \sgl = \bM v\\
        W^- & \text{if } \sgl = \bF v \\
        \end{array}\right\} \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$

For some signed literal $\sgl = \bX v$ or an atom $v$ let $$\Delta^\alpha(\sgl) = \Delta^\alpha(v) = W_i^\alpha \ \text{with } \Delta(v) = \langle W^+, W^-, W^\alpha \rangle .$$
\end{definition}

Interpretation as a set $\Delta = \{(v_i, (W_i^+, W_i^-, W_i^\alpha)\}$ for $1 \leq i \leq n$ where $i \not = j \to v_i \not = v_j$ for $1 \leq j \leq n$ reveals how such a mapping can be stored or visualized (see figure~\ref{fig:watches}).

\begin{figure}[h]
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]
\node(s)[stack=4]  {
                 Atom     % text
\nodepart{two}   $v_1$     % two
\nodepart{three} $v_2$      % three
\nodepart{four}  \vdots % four
};

\node(v1t)[stack=3, rectangle split horizontal, above right=2cm and 3cm of s.two] {
$\delta_1$     % two
\nodepart{two} $\delta_2$      % three
\nodepart{three}  \ldots % four
};

\node(v1m)[stack=3, rectangle split horizontal, above right=1cm and 3.5cm of s.two] {
$\delta_3$     % two
\nodepart{two} $\delta_4$      % three
\nodepart{three}  \ldots % four
};

\node(v1f)[stack=3, rectangle split horizontal, above right=0cm and 4cm of s.two] {
$\delta_5$     % two
\nodepart{two} $\delta_6$      % three
\nodepart{three}  \ldots % four
};

\path (s.two east)
edge [out=east,in=west, left] node {$+$} (v1t)
edge [out=east,in=west, above] node {$-$} (v1m)
edge [out=east,in=west, above] node {$\alpha$} (v1f)
;

\end{tikzpicture}
  \caption{Example layout of a \emph{watch structure}.}
  \label{fig:watches} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

\begin{definition}

A watch structure $\Delta$ \emph{\lowinv} an assignment $\ass$ iff for every nogood $\delta \in \Delta$ holds:

\begin{enumerate}
\item If $\delta$ is not satisfied under $\ass$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ unassigned under $\ass$, then $\delta$ is contained in exactly two distinct watch sets, e.g. $\delta \in \Delta^\pm(\bsgl_1)$ and $\delta \in \Delta^\pm(\bsgl_2)$ with $\bsgl_1 \not = \bsgl_2$.
\item Let $L_\delta = \{ \bT v \in \text{body}(\delta) \ | \ \bT v \not \in \ass \}$. If $L_\delta \not = \emptyset$, then there is exactly one $\bsgl \in L_\delta$ with $\delta \in \Delta^\alpha(\bsgl)$.
\end{enumerate}
\end{definition}

Using watch structures that watch assignments, propagation can be implemented efficiently: Given $\Delta$ watching $\ass$ and a new assignment for some atom $\sgl = \bX v$ the nogoods that are candidates for propagation are those in $\Delta^\pm(\sgl)$ (in case $\sgl \not \in A$, thus $\sgl$ changes from \emph{unassigned} to \emph{true}, \emph{\mbt} or \emph{false}) and $\Delta^\alpha(\sgl)$ (in case $\sgl \in A$, thus $\sgl$ changes from \emph{\mbt} to \emph{true}).

However, with $\Delta$ watching $\ass$ and extending the assignment $\ass' = \ass \circ \sgl$, now $\Delta$ does not trivially watch $\ass'$.

\begin{definition}
A watch structure $\Delta$ is said to be \welf under some assignment $\ass$ in case all nogoods $\delta \in \Delta$ are \upinv under $\ass$ and $\Delta$ \lowinv $\ass$.
\end{definition}

In the next section, a closer look at propagation will reveal that when transitioning from an assignment to the next one, watch sets can be altered efficiently to obtain a well formed watch structure for the extended assignment.

\section{Unit Propagation}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~signed~literal~$\sgl$,
        a~watch~structure~$\Delta$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation and $\Delta$ with updated watches.}
  $k \leftarrow |\ass|$ \label{alg:up:k}\\
  $i \leftarrow 1$ \label{alg:up:i}\\
  $\ass \leftarrow \ass \circ \sgl$ \label{alg:up:circ}\\
  \While{$k + i \leq |\ass|$ \label{alg:up:loop:begin}} 
  {
    $\sgl_i \leftarrow \ass[k + i]$\\
  $(\ass, \Delta) \leftarrow$ \textsc{UnitPropagationUnassigned}($\ass$, $\sgl_i$, $\Delta$)\\
  \If{$\sgl_i$ is of form $\bT v$}
  {
    $(\ass, \Delta) \leftarrow$ \textsc{UnitPropagationAssigned}($\ass$, $\sgl_i$, $\Delta$)
  }
    $i \leftarrow i + 1$
  } \label{alg:up:loop:end}
  \Return{$(\ass, \Delta)$}
  \caption{\textsc{UnitPropagation}}
  \label{alg:up}
\end{algorithm}

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~literal~$\sgl \in \ass$,~and
        a~set~of~watched~nogoods~$\Delta$.}
  \KwOut{$\ass$ extended by means of nogood propagation and $\Delta$ with updated watches.}
%  \ForEach{$\delta \in w_{=2}(\Delta, \sigma)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned in $\mathbf{A}$}
%    {
%      $\mathbf{A} \leftarrow \mathbf{A} \circ \negweak{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \Delta^\pm(\sgl)$}
  {
    \uIf{$\delta$ is violated}
    {
      \Return{$(\text{conflict}, \Delta)$}
    }
    \uElseIf{$\delta$ is weakly unit with $\sgl'$ unassigned}
    {
      $\ass \leftarrow \ass \circ \negweak{\sgl'}$
    }
    \Else%If{there is some unassigned $\sigma' \in \delta$}
    {
      $\Delta^\pm(\sgl) \leftarrow \Delta^\pm(\sgl) \setminus \{ \delta \}$\\
      Let $\bsgl$, $\bsgl'$ be two unassigned literals in $\delta$.\\
      $\Delta^\pm(\bsgl) \leftarrow \Delta^\pm(\bsgl) \cup \{ \delta \}$\\
      $\Delta^\pm(\bsgl') \leftarrow \Delta^\pm(\bsgl') \cup \{ \delta \}$\\
    }
  }
  \Return{$(\ass, \Delta)$}
  \caption{\textsc{UnitPropagationUnassigned}}
  \label{alg:upu}
\end{algorithm}

Algorithm \ref{alg:upu} exhibits how unit propagation is used to infer assignments (of either false or \mbt) from watched nogoods. 
In line 1, the input literal $\sgl$ is transformed to its weak form as lookups in $\Delta$ are always made against the set of nogoods that might propagate in case the literal \mbt, even if $\sgl$ is of $\bT x$. % Why?
In the loop spanning from line 2-13 all nogoods that are to be checked for propagation according to $\Delta$ are iterated. For any such nogood one of the following three cases holds true
\begin{enumerate}
\item it is violated, leading to the algorithm immediately returning the conflicting assignment, or
\item it is weakly unit, in which case a new assignment can be inferred from the nogood, or
\item in any other case, there must be at least two unassigned literals in $\delta$, which are to be watched for changes in assignments.
% TODO: Does not (1.) and not (2.) guarantee that there are two unassigned literals?! Nogood could be satisfied.
\end{enumerate}

In case (3.), $\Delta$ is modified in lines 8-11. As $\sgl$ is now assigned, it should not be watched for changes anymore. This is achieved by removing $\delta$ from the set of watches $\Delta(\sgl)$ and instead adding it to the set of watches for two unassigned literals in $\delta$.

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~literal~$\sgl \in \ass$, and
        a~watch~structure~$\Delta$.}
  \KwOut{$\ass$ extended by means of nogood propagation.}
%  \ForEach{nogood $\delta \in w_{=2}(\Delta)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned}
%    {
%      $\mathbf{A} \circ \negstrong{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \Delta^\alpha(\sgl)$}
  {
    $L \leftarrow \{ \bT v \in \delta \ | \ \bT v \not \in \ass \} \setminus \{ \sgl, \text{head}(\delta) \} $\\
%     $L \leftarrow \{ \bsgl \ | \ \bsgl \in \delta, \bsgl \not \in \ass \text{, and } \bsgl \ \text{is of form} \ \bT v \} \setminus \{ \sgl, \text{head}(\delta) \} $\\
    \uIf{$L \not = \emptyset$}
    {
      $\Delta^\alpha(\sgl) \leftarrow \Delta^\alpha(\sgl) \setminus \{ \delta \}$\\
      % Choose $\bsgl \in L$ s.t.~there is no $\bsgl' \in L$ with $\ass = (\ldots, \bsgl, \ldots, \bsgl', \ldots)$.\\
      $\Delta^\alpha(\bsgl) \leftarrow \Delta^\alpha(\bsgl) \cup \{ \delta \}$ for some $\sigma \in L$\\
    }
	\ElseIf{$\delta$ is strictly unit}
	{
	  $\ass \leftarrow \ass \circ \negstrong{\bsgl}$
	}
  }
  \Return{$(\mathbf{A}, \Delta)$}
  \caption{\textsc{UnitPropagationAssigned}}
  \label{alg:upa}
\end{algorithm}

%In order to implement efficient propagation, a data

% No Unfounded Set checks -> MBT.

% Explain 2WL with MBT, propagation with MBT (pseudocode of propagation algorithm).

% Invariant
For every nogood $\delta \in \Delta$, if $\delta$ contains at least two atoms unassigned under $\ass$, then $\delta$ is contained in exactly two watch lists.
%TODO define watch list!

\begin{theorem}
Algorithm \ref{alg:up} is sound, i.e.~given an assignment $\ass$, a watch structure $\Delta$ \welf wrt.~$\ass$ and a literal $\sgl$, it results in a new assignment $\ass'$ such that:
\begin{enumerate}
\item If $\sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$ and $\Delta' = \Delta$. % Trivial case.

\item If $\sgl$ does not conflict with $\ass$ and there are assignments that can be inferred by means of unit propagation, then these assignments are in $\ass'$ ($\ass \subset \ass'$) and $\Delta'$ is \welf wrt.~$\ass'$.

\item If a literal inferred from $\Delta$ and $\ass \circ \sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$.
\end{enumerate}
\end{theorem}

\begin{proof}
%We show that:

%\begin{enumerate}
%\item in case $\sgl$ conflicts with $\ass$, the algorithm will return the assignment \emph{conflict} and $\Delta$ is not guaranteed to be well formed,
%\item otherwise, the resulting watch structure $\Delta$ will be well formed wrt. the resulting assignment $\ass$.
%\end{enumerate}

To show (1.) rather trivially: Assume $\sgl$ conflicts with $\ass$. Then, on line~\ref{alg:up:circ} of the algorithm $\ass$ will be assigned \emph{conflict}. Consequently, the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} is not executed as $|\emph{conflict}| = \infty$ and $k + i$ must be finite. $(\ass, \Delta)$ is returned.

%In line 1 of algorithm \ref{alg:up}, $\ass$ is altered by appending the given signed literal $\sgl$. Now, $\Delta$ might not be well formed wrt.~the altered assignment $\ass'$ anymore, because there might be some nogood $\delta \in \Delta^\pm(\sgl)$. By executing algorithm \ref{alg:upu}, $\Delta$ is transformed into a well formed watch structure $\Delta'$.

Before establishing a proof for (2.) and (3.) observe what the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} achieves.

\paragraph{Initialization} Let $k$ be the size of the input assignment $\ass$ (see line~\ref{alg:up:k}), which serves as a reference point of the size of the assignment before propagation is performed and $i$ some loop counter (see line~\ref{alg:up:i}).

\paragraph{Representing iterations} For every iteration let the triple $S_i = (\sgl_i, \ass_i,  \Delta_i)$ denote that in the iteration represented by $S_i$, propagation on literal $\sgl_i$ is performed on the assignment $A_i$ and watch structure $\Delta_i$.

\paragraph{Semantics of an iteration} Further, this means that for two steps: $S_{i-1} = (\sgl_{i-1}, \ass_{i-1}, \Delta_{i-1})$ and $S_i = (\sgl_i, \ass_i, \Delta_i)$, $\ass_i$ is the result of performing propagation with $\sgl_{i-1}$ on $\ass_{i-1}$ using $\Delta_{i-1}$. Analysis of the difference between $\Delta_{i-1}$ and $\Delta_i$ is what resembles the proof below.

\paragraph{Termination of the loop} The loop ends when no new assignment can be inferred, i.e.~$S_{i-1} = (\sgl_{i-1}, \ass_{i-1}, \Delta_{i-1})$ and $S_i = (\sgl_i, \ass_i, \Delta_i)$ with $\ass_{i-1} = \ass_i$, and all nogoods in $\Delta_i$ are \lowinv wrt.~$A_i$, which follows from $k + i = |\ass_i|$ and thus $\ass_i = \ass_i[\ldots, k+i]$ (shown below).
If the loop ends, $\ass_i$ and $\Delta_i$ are returned, so $\ass_i = \ass'$ and $\Delta_i = \Delta'$.

Now, assume that $\sgl$ does not conflict with $\ass$ and show (2.) and (3.) are by induction on iteration steps $i$:

Let $\mathcal{P}(i)$ denote that $\dbef$ is \upinv wrt.~$\ass_i$ and $\dbef$ is \lowinv by $\abef$.

\emph{Base Case}: For the base case, concerning the input assignment $\ass$ and $\Delta$, $\mathcal{P}(0)$ is trivially true because $\ass_0 = \ass$ and $\Delta_0 = \Delta$ is \welf wrt.~$\ass$ (precondition).

% TODO Hypothesis is different for cases 1 and 2?!
\emph{Induction Hypothesis}: Assume $\mathcal{P}(i)$ holds for some $i$.

\emph{Induction Step}: The induction step now consists of observing that the loop in lines 3-10 \enquote{preserves} properties (1.) and (2.) of soundness, i.e.~it argues the transitivity of those properties for iteration steps $S_{i}$ to $S_{i+1}$.

%We show that every nogood $\delta \in \Delta'$ is \welf wrt.~$\Delta'$ and $\ass'$, i.e.~$\Delta'$ is \welf wrt.~$\ass'$, by using that $\Delta$ is \welf wrt.~$\ass$ and the definition of the algorithm.

Given two consecutive iteration steps $S_{i} = (\sgl_{i}, \ass_{i}, \Delta_{i})$ and $S_{i+1} = (\sgl_{i+1}, \ass_{i+1}, \Delta_{i+1})$, assume $\mathcal{P}(i)$ by the induction hypothesis, i.e.~$\dbef$ is \welf wrt.~$\abef$. Now for every nogood $\delta \in \daf$:

\begin{enumerate}
\item If $\sgl_i \not \in \delta$, then: % A nogood only contains boolean signed literals, so dies this even make sense? \sgl is a signed literal, not a boolean signed literal, so how can it be element of delta? Needs clarification.
\begin{enumerate}
\item $\delta$ is not violated under $\abef$ (inv1). Therefore, $\delta$ is not violated under $\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item $\delta$ is not unit wrt.~$\abef$ (inv2). Therefore, $\delta$ is not unit wrt.~$\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned wrt.~$\aaf$. Then $\bsgl_1$ and $\bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied under $\abef$, because $\abef \subset \aaf = \abef \circ \sgl_i$ and $\sgl_i \not \in \delta$. Therefore, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ must hold (inv3). For the same two literals, $\delta \in \daf^\pm(\bsgl_1)$ and $\delta \in \daf^\pm(\bsgl_2)$ holds. % Needs clarification. Reference the loop that the nogood is certainly not part of.
\item Analogous to (c), if $\delta$ has any triggers, their assignment does not change, as $\sgl_i \not \in \delta$, and no watches $\delta \in \dbef^\alpha(\bsgl)$ are changed. The same $\bsgl$ will satisfy $\delta \in \dbef^\alpha(\bsgl)$ for $\abef$ and $\aaf$.
\end{enumerate}
\item Else ($\sgl_i \in \delta$):
\begin{enumerate}
\item If $\delta \not \in \dbef^\pm(\sgl_i)$, i.e.~$\delta$ was not watched on $\sgl_i$, then
\begin{enumerate}
\item To show that $\delta$ is not violated by $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not violated under $\aaf$ as $\delta$ is not violated by $\abef$ (inv1) and $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals in $\delta$ unassigned wrt.~$\abef$ as $\delta$ is not unit wrt.~$\abef$ (inv2). From $|\aaf| = |\abef| + 1$ if follows that there must be at least one literal in $\delta$ which is unassigned wrt.~$\aaf$, therefore $\delta$ cannot be violated under $\aaf$.
\end{enumerate}
\item To show that $\delta$ is not unit under $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not unit under $\aaf$ because $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ that are unassigned wrt.~$\abef$, as $\delta$ is not unit under $\abef$ (inv2). Further, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ (inv3). From $\delta \not \in \dbef^\pm(\sgl_i)$ it follows that $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$. % How are binary signed literals and signed literals compared?
Therefore $\delta$ is not unit, because $\bsgl_1, \bsgl_2 \in \delta$ are unassigned wrt.~$\aaf$.
\end{enumerate}
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned under $\aaf$. Then $\bsgl_1, \bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied wrt.~$\abef$ because $\abef \subset \aaf$ and $\delta \not \in \dbef^\pm(\sgl_i)$ and $\delta$ is not unit wrt.~$\abef$.
\item Same as 1.d ...
\end{enumerate}
\item Else ($\delta \in \dbef^\pm(\sgl_i)$), i.e.~$\delta$ was watched on $\sgl_i$.
\begin{enumerate}
\item If $\delta$ is weakly unit under $\aaf$ with $\bsgl$ unassigned, then the algorithm generates the assignment $\negweak{\bsgl}$.
\item Else
\item If there are two unassigned pointer move $\to$ two unassigned literals
\item pointer move $\to$ two unassigned literals
\item violated $\to$ conflict
\item weakly unit $\to$ satisfied
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is complete.
\end{theorem}

\begin{proof}
Indirect proof, showing that if there is an assignment that results from propagation it will be generated.
\end{proof}

\begin{theorem}
Algorithm \ref{alg:up} is sound and complete.
\end{theorem}

\begin{proof}

\end{proof}

\chapter{Implementation}

\section{Benchmarks}

\chapter{Conclusion}

\section{Related Work}

\section{Conclusion}

\subsection{Related Work}

\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
\printglossaries

% Add a bibliography.
\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
