\documentclass[final]{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amsthm}
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage{enumitem}   % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
%\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last.
\usepackage{lmodern}% http://ctan.org/pkg/lmodern
\usepackage{xspace}
\usepackage{marvosym}
\usepackage{xfrac}
\usepackage[numbers,longnamesfirst]{natbib}
\usepackage{tikz}
\usetikzlibrary{positioning,fit,calc,arrows.meta,patterns,matrix,shapes.multipart}
\usepackage{babel}

% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Lorenz Leutgeb} % The author name without titles.
\newcommand{\thesistitle}{Three Watched Literals} % The title of the thesis. The English version should be used, if it exists.
\newcommand{\thesissubtitle}{Efficient Propagation for Lazy-Grounding Answer~Set~Programming Systems} % The title of the thesis. The English version should be used, if it exists.

\hypersetup{
    pdfpagelayout   = TwoPageRight,
    linkbordercolor = {1 0.8 0.8}, %TODO change this to Melon when finished.
    pdfauthor       = {\authorname},
    pdftitle        = {\thesistitle},
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {asp, solver, propagation, nogood}
}

\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

%\makeindex      % Use an optional index.
%\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Prof.~Dr.}{Thomas Eiter}{}{male}

% For bachelor and master theses:
\setfirstassistant{Dr.}{Antonius Weinzierl}{}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

\setaddress{Engilgasse 3a, 1160 Wien}
\setregnumber{1127842}
\setdate{18}{09}{2017} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{\thesistitle} % Sets English and German version of the title (both can be English or German).
\setsubtitle{\thesissubtitle}{\thesissubtitle} % Sets English and German version of the subtitle (both can be English or German).

\setthesis{bachelor}

\setcurriculum{Software \& Information Engineering}{Software \& Information Engineering} % Sets the English and German name of the curriculum.

% Define convenience macros.
\newcommand{\todo}[1]{{\color{red}\textbf{TODO: {#1}}}} % Comment for the final version, to raise errors.

\newtheorem{proof-sketch}{Sketch of Proof}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem{definition}{Definition}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[theorem]
\newtheorem{corollary}{Corollary}[theorem]

\newtheorem*{remark}{Remark}

\newcommand{\mbt}{must-be-true\xspace}
\newcommand{\negstrong}[1]{\overline{#1}^s}
\newcommand{\negweak}[1]{\overline{#1}^w}

% Function B transforming an assignment into a boolean assignment.
\newcommand{\bass}{\mathcal{B}}
\newcommand{\bpro}{\mathcal{B}}

% An assignment A.
\newcommand{\ass}{A}

% Herbrand Base function of some logic program.
\newcommand{\hb}{\textit{HB}}

\newcommand{\bT}{\mathbf{T}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\fabef}{\ass_{i}}
\newcommand{\faaf}{\ass_{i + 1}}
\newcommand{\abef}{\fabef{k + i}}
\newcommand{\aaf}{\faaf^{k + i + 1}}
\newcommand{\dbef}{\Delta_{i}}
\newcommand{\daf}{\Delta_{i+1}}
\newcommand{\contradiction}{\Lightning}
\newcommand{\cdpm}{C_\pm}
\newcommand{\cdal}{C_\alpha}
\newcommand{\dpm}{\Delta^\pm}
\newcommand{\dal}{\Delta^\alpha}

\newcommand{\righta}[1]{\ass_{#1}[{#1}, |\ass_{#1}|]}
\newcommand{\lefta}[1]{\ass_{#1}[0, {#1-1}]}

\newcommand{\welf}{well formed\xspace}
\newcommand{\upinv}{silent\xspace}
\newcommand{\lowinv}{watches\xspace}
\newcommand{\stbl}{stable\xspace}

\newcommand{\headf}{H}
\newcommand{\bodyf}{B}

\newcommand{\fail}{\mathrm{not } \ \xspace}
%\newcommand{\from}{\mathrm{\ \xspace :- \ \xspace}}
\newcommand{\from}{\ensuremath{\leftarrow}}
\newcommand{\problem}{\ensuremath{\mathscr{P}}}

\newcommand{\entails}{\models}

% Least model (of a Horn program).
\newcommand{\lm}{\mathrm{lm}}

% Set of stable models (of a program).
\newcommand{\stm}{\mathrm{STM}}
\newcommand{\sol}{\mathrm{Sol}}
\newcommand{\compl}{\mathrm{Co}}
\newcommand{\groundext}{\mathrm{Gr}}
\newcommand{\defense}{\mathrm{Def}_F}

% Entails according to well founded semantics.
\newcommand{\wf}{\ensuremath{\entails_{wf}}}

% Entails according to stable model semantics using brave reasoning
\newcommand{\brave}{\ensuremath{\entails_{st}^b}}

% Entails according to stable model semantics using cautious reasoning
\newcommand{\caut}{\ensuremath{\entails_{st}^c}}

% Selective Linear Definite-clause with Negation as Failure
\newcommand{\sldnf}{\ensuremath{\vdash_{NF}}}

\newcommand{\universe}{\mathcal{U}}
\newcommand{\afs}{\mathcal{F}}
\newcommand{\attacks}{\rightsquigarrow}

\newcommand{\sgl}{\mu}
\newcommand{\bsgl}{\sigma}

\newcommand{\thrice}{{\{\bT, \bM, \bF \}}}

\newcommand{\wkn}{\textit{weaken}}

\newcommand{\asperix}{\texttt{ASPeRiX}\xspace}
\newcommand{\clasp}{\texttt{clasp}\xspace}
\newcommand{\dlv}{\texttt{dlv}\xspace}
\newcommand{\omiga}{\texttt{OMiGA}\xspace}

\usepackage[autostyle=true,austrian=quotes,english=american]{csquotes}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian}
\addtitlepage{english}
\addstatementpage

\selectlanguage{english}

\begin{acknowledgements*}
I would like to thank Antonius Weinzierl for his consistent and continuous efforts in supporting me writing this thesis through numerous meetings, openness in discussion and acceptance of my contributions to the Alpha system.
\end{acknowledgements*}

\selectlanguage{naustrian}

\begin{kurzfassung*}
Answer Set Programming (ASP) ist eine deklaratives Programmierparadigma in Anlehnung an Prädikatenlogik erster Stufe. ASP-Programme werden üblicherweise durch ASP-Systeme evaluiert, deren Design stark durch Löser (engl.~\enquote{solver}) für das Erfüllbarkeitsproblem der Aussagenlogik (SAT, von engl.~\enquote{satisfiability}) inspiriert ist. Ein zentrales Verfahren in diesen Systemen ist die sogenannte \emph{Einheitsresolution} (engl.~\enquote{unit propagation}), wodurch aus bekannten Wahrheitswerten für Konstanten und der Struktur der Formel neue Wahrheitswerte ableitet werden können.

Im Unterschied zu SAT-Formeln enthalten ASP-Programme jedoch Variablen, wodurch sich das sogenannte \emph{grounding bottleneck} ergibt, welches die praktische Verwendbarkeit von ASP-Systemen einschränkt. An der Entwicklung sogenannter \emph{lazy-grounding} ASP-Systeme wird aktiv geforscht. Durch die Einführung eines dritten Wahrheitswerts \emph{\mbt} (neben den zwei Boolschen Werten \emph{true} und \emph{false}) kann die Suche nach Lösungen beschleunigt werden. Diese Optimierung hat sich für lazy-grounding ASP-Systeme als besonders wirkungsvoll herausgestellt, sie ist allerdings mit den bewährten Varianten der Einheitsresolution nicht kompatibel, da diese nur die zwei Booleschen Wahrheitswerte berücksichtigen.

Der Hauptteil der Arbeit beschreibt einen möglichen Lösungsansätz der effizienten Einheitsresolution mit drei Wahrheitswerten, insbesondere für lazy-grounding ASP-Systeme, aufbauend auf der \emph{Two Watched Literals} (2WL) Methode. Die neue Methode nennt sich \emph{Three Watched Literals} (3WL).

Die Korrektheit des Algorithmus wird gezeigt. Die erste bekannte Implementierung des Verfahrens -- Teil des lazy-grounding ASP-Systems \enquote{Alpha} -- wurde zu einer Evaluation anhand von  verfügbaren Eingabeprogrammen herangezogen, deren Ergebnisse diskutiert werden.
%Der Komppromiss zwischen Speicherverbrauch und vollständiger Verfügbarkeit des grundierten Programms resultiert in neuen Restriktionen für Algorithmen und Datenstrukturen in ASP-Systemen. Der Hauptteil der Arbeit beschreibt wie \emph{Unit Propagation} basierend auf \emph{two-watched-literals} auf drei Literale erweitert werden kann, sodass Berechnungen mit einem teilweise grundierten Programm ausgeführt werden können.
\end{kurzfassung*}

\selectlanguage{english}

\begin{abstract*}
Answer Set Programming (ASP) is a declarative programming paradigm based on first order logic. ASP programs are usually evaluated by ASP systems, whose design is strongly inspired by solvers for the boolean satisfiability problem (SAT). A central method in these systems is \emph{unit propagation}, enabling to derive new truth assignments for constants from known truth assignments, using the structure of the input formula.

Contrary to SAT formulas, ASP programs contain variables, leading to the so-called \emph{grounding bottleneck}, which limits the practical applicability of ASP systems. The development of \emph{lazy-grounding} ASP systems to overcome the grounding bottleneck is an active area of research. By introducing a third truth value \emph{\mbt} (in addition to the two boolean truth values \emph{true} and \emph{false}) search for solutions can be improved. This optimization was shown to be especially effective in lazy-grounding ASP systems, but it is not compatible with established variants of unit propagation, because they only consider the boolean truth values.

The main part of this work describes an approach for efficient unit propagation with three truth values, especially considering lazy-grounding ASP systems, based on the \emph{Two Watched Literals} (2WL) method. The new approach is called \emph{Three Watched Literals} (3WL).

Soundness of the new algorithm is shown. The first known implementation -- part of the lazy-grounding ASP system \enquote{Alpha} -- was used to evaluate performance with freely available input programs. Results are discussed.
\end{abstract*}

\tableofcontents* % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}
\label{chap:intro}

Since the inception of computer programming, different ways of encoding algorithms, structuring data and modeling the real world in computer programs have led to the development of various conceptually diverse programming languages. Families of programming languages that share some properties are usually grouped into so called \enquote{programming paradigms}.
Such paradigms describe the common, most important concepts and lay a framework for a family of languages.

The languages most widely used in industry follow the \emph{imperative} programming paradigm (some more strict, some less), which revolves around instructing the computer step by step. In this work, in contrast to mainstream software engineering, the main focus is Answer Set Programming (ASP, \cite{stable}), a declarative programming paradigm that roots in first order logic.

A key difference between declarative and imperative programming is that in the former the focus is explaining the problem to be solved and \emph{what} a solution should look like, while for the latter, programmers write code that specifies \emph{how} the problem is to be solved.

Without going into further details about how ASP works internally, consider the following example for an intuition.

\begin{example}
\label{ex:garments}
Suppose one needs to decide what to wear. The following program narrows down the selection of garments in the wardrobe by checking whether specific pieces are designed to be worn in the current season. For the sake of the example we assume that it is summer.
%rule with two vars
%allowdisplaybreaks?
\begin{align}
garment(winterjacket)\from& \ .\tag{$f_1$}\label{ex:garments:garments:begin}\\
garment(jeans)\from& \ .\tag{$f_2$}\\
garment(tshirt)\from& \ .\tag{$f_3$}\\
garment(shorts)\from& \ .\tag{$f_4$}\label{ex:garments:garments:end}\\
warm(winterjacket)\from& \ .\tag{$f_5$}\label{ex:garments:style:begin}\\
light(shorts)\from& \ .\tag{$f_6$}\label{ex:garments:style:end}\\
summer\from& \ .\tag{$f_7$}\label{ex:garments:season}\\
inseason(G) \from& \ winter, garment(G),~\fail light(G). \tag{$r_1$}\label{ex:garments:inseason:begin}\\
inseason(G) \from& \ summer, garment(G),~\fail warm(G). \tag{$r_2$}\label{ex:garments:inseason:end}\\
wear(G) \from& \ garment(G), inseason(G). \tag{$r_3$}\label{ex:garments:wear}\\
\from& \ winter, summer. \tag{$c_1$}\label{ex:garments:seasons}
\end{align}

The program is made up of eleven rules: \ref{ex:garments:garments:begin} \ldots \ref{ex:garments:garments:end} list the four pieces we have in the wardrobe (a winter jacket, a pair of jeans, a t-shirt and shorts). As these rules have no premises, they are also called \emph{facts}. Rules \ref{ex:garments:style:begin} and \ref{ex:garments:style:end} qualify garments that are light or warm. The current season is encoded in \ref{ex:garments:season}. Through \ref{ex:garments:inseason:begin} and \ref{ex:garments:inseason:end} we define when a garment is \enquote{in season}, i.e.~whether a piece is not light (resp.~not warm) which means it should be worn in winter (resp.~summer). Finally, we express that a garment can be worn in case it is in season in rule \ref{ex:garments:wear}. The last rule \ref{ex:garments:seasons} models a \emph{constraint}: It is unreasonable that it is both winter and summer for one evaluation of the program.
\end{example}
enquote
The evaluation of an ASP program is done by an ASP system, which may be comprised of further components. For user and programmer, no detailed knowledge about the system is required. The abstract input/output behaviour of these systems is enough to use them in most cases: Given an input program (and sometimes a few options on which algorithms or data structures to employ) it computes the answer sets. Loosely speaking, answer sets are possible combinations of values that satisfy all requirements that are stated in the program.

% benuetzen gleiche techniken, es hat sich gezeigt, dass techniken aus dem sat bereich effizient sind

Many ASP system implementations use solving algorithms closely related to those found in boolean satisfiability (SAT, \cite{sat}) solvers to search for answer sets. Finding an answer set for a logic program, which means exploring truth assignments for atomic expressions under the rules defined in the program, is similar to finding a satisfying assignment for a formula, which means exploring possible truth values for constants under the structure of the formula. Adapting SAT solvers and their methods turned out to be highly effective for solving ASP. To keep up this close relation however, one key difference between formulas in SAT and programs in ASP must be accounted for: formulas in SAT do not have variables, but logic programs do. Variables such as \emph{G} in the above example must be removed. The process of substituting variables with constants, e.g. substituting \emph{G} with one of the four concrete garments, is referred to as \emph{grounding} and the resulting variable-free program is said to be \emph{ground}.

\begin{example}
\label{ex:garmentsground}
Reconsider Example \ref{ex:garments}, na{\"i}vely substituting all occurrences of \emph{G} yields eight instances of the rule $r_1$ (two per garment), and four of rule $r_2$ (one per garment).
\begin{align}
garment(winterjacket)\from& \ . \tag{$f_1$}\label{ex:garmentsground:garments:begin}\\
garment(jeans)\from& \ .\tag{$f_2$}\\
garment(tshirt)\from& \ .\tag{$f_3$}\\
garment(shorts)\from& \ .\tag{$f_4$}\label{ex:garmentsground:garments:end}\\
warm(winterjacket)\from& \ .\tag{$f_5$}\label{ex:garmentsground:style:begin}\\
light(shorts)\from& \ .\tag{$f_6$}\label{ex:garmentsground:style:end}\\
summer\from& \ .\tag{$f_7$}\label{ex:garmentsground:season}\\
inseason(winterjacket) \from& \ winter, garment(winterjacket), \notag\\
& \ \ \fail light(winterjacket). \tag{$r_{1,1}$}\label{ex:garmentsground:inseason:begin}\\
inseason(jeans) \from& \ winter, garment(jeans), \fail light(jeans).\tag{$r_{1,2}$}\\
inseason(tshirt) \from& \ winter, garment(tshirt), \fail light(tshirt).\tag{$r_{1,3}$}\\
inseason(shorts) \from& \ winter, garment(shorts), \fail light(shorts).\tag{$r_{1,4}$}\\
inseason(winterjacket) \from& \ summer, garment(winterjacket), \notag\\
& \ \ \fail warm(winterjacket).\tag{$r_{1,5}$}\\
inseason(jeans) \from& \ summer, garment(jeans), \fail warm(jeans).\tag{$r_{1,6}$}\\
inseason(tshirt) \from& \ summer, garment(tshirt), \fail warm(tshirt).\tag{$r_{1,7}$}\\
inseason(shorts) \from& \ summer, garment(shorts), \fail warm(shorts). \tag{$r_{1,8}$}\label{ex:garmentsground:inseason:end}\\
wear(winterjacket) \from& \ garment(winterjacket), inseason(winterjacket).\tag{$r_{2,1}$}\\
wear(jeans) \from& \ garment(jeans), inseason(jeans).\tag{$r_{2,2}$}\\
wear(tshirt) \from& \ garment(tshirt), inseason(tshirt).\tag{$r_{2,3}$}\\
wear(shorts) \from& \ garment(shorts), inseason(shorts).\tag{$r_{2,4}$}\\
\from& \ winter, summer.\tag{$c_1$} \label{ex:garmentsground:seasons}
\end{align}
\end{example}

Generally, the ground program may be exponentially bigger than the input program.

\newpage

\begin{example}[{\cite[Example 1]{alpha-techniques}}]
\label{ex:explosion}
Consider the following program $P$ which selects at most one element from a domain:
\begin{align}
dom(1) \from& \ .\tag{$f_1$} \\
\vdots \notag \\
dom(n) \from& \ . \tag{$f_n$} \\
selected(X) \from& \  dom(X), \fail notSelected(X).  \tag{$r_1$} \\
notSelected(X) \from& \  dom(X), \fail selected(X).  \tag{$r_2$} \\
\from& \ selected(X), selected(Y), X \not = Y.  \tag{$c_1$}
\end{align}
Facts $f_1$ to $f_n$ span a domain of size $n$, while rules $r_1$ and $r_2$ together achieve that each element from the domain is either selected or not selected, and finally the constraint $c_1$ ensures that there are no two (or more) selected elements. The corresponding ground program will have $n^2 + 2n$ rules. In other words, the size of the ground program is polynomial in the size of the input program.

Adding another rule to the program will however cause the size of the ground program to grow out of polynomial relation:
\begin{align}p(X_1, \ldots, X_k) \from selected(X_1), \ldots, selected(X_k). \tag{$r_3$} \end{align}
Now, the size of the ground program of $P \cup \{ r_3 \}$ will be exponential\footnote{In practice for most ASP systems. \cite{bounded-arities} shows that for programs with bounded predicate arities, polynomial space is sufficient.} in $k$, precisely $n^k + n^2 + 2n$.
\end{example}

State-of-the-art ASP systems feature two components: the \emph{grounder} takes care of substituting all variables, i.e.~generating the ground program, while the \emph{solver} takes this ground program as input and computes answer sets. Traditionally, the grounder is invoked first, and only after it has output the ground program, the solver starts execution. This two-phased mode of operation is referred to as \emph{ground-and-solve}. With the ground program being exponentially larger than the original input program with variables, these systems are prone to what we call the \emph{grounding bottleneck}: When the ground program is so large that it does not fit into memory, the search for answer sets is impossible in practice. For more examples that exhibit the grounding bottleneck, we refer to \cite[Section 1]{asperix}.

\section{Motivation}
\label{sec:motivation}
% propagation als teil des solvers
% leitet information her
% anhand des beispiels beispiel für propagation
% vergleich mit g-s übersetzen in sat klauseln bzw. nogoods (2wl)

The goal of solver components in ASP systems is determining which propositions (such as $wear(winterjacket)$, for example) are \emph{true} and \emph{false} respectively. In the process, an \emph{assignment} designates which propositions are \emph{true} (resp.~\emph{false}), it allows to express statements such as \enquote{$wear(winterjacket)$ is \emph{true}}. Once an assignment is found that associates a truth value with every proposition and does not conflict with any rule, an answer set is derived. Assignments conflicting with rules of the program are considered invalid. In Example \ref{ex:garments}, any assignment that allows stating both \enquote{$summer$ is \emph{true}} and \enquote{$winter$ is \emph{true}} at the same time, must be avoided as it cannot represent an answer set, because of the constraint in line \ref{ex:garments:seasons}.

Through the combination of truth values and information about conflicting truth values of propositions, both encoded by the rules of the input program, solvers can infer truth values of other propositions. One method to extend an assignment this way is called \emph{unit propagation}: rules are modeled as sets of literals (propositions and their negations), called \emph{nogoods}, for which not all might satisfy the assignment. From their property that not all corresponding truth values in the assignment may conform with the nogood at the same time, it follows that when all but one elements of the nogood agree with the assignment (we say the nogood is \emph{unit}), the truth value of the remaining proposition can be inferred and added to the assignment.

\begin{example}
\label{ex:garmentprop}
Consider Example \ref{ex:garments} again, which contains the constraint \ref{ex:garments:seasons}. It can be written as a clause $winter \wedge summer$ that must not evaluate to \emph{true}, or simply as a nogood $\delta = \{ \bT summer, \bT winter \}$ of the two propositions that cannot conform with the assignment at the same time. An assignment saying that \enquote{$summer$ is \emph{true}} in combination with $\delta$ implies a new truth value, namely that \enquote{$winter$ is \emph{false}}.
\end{example}

In order to perform unit propagation, ground-and-solve systems commonly translate the input program into a set of nogoods, and even more advanced algorithms have been devised to dynamically learn new nogoods in the process of searching for answer sets. 

For solvers to be efficient, it is crucial to quickly identify which nogoods are unit, even when the assignment under which the nogoods might individually be unit changes frequently during search. Modern solvers implement the so called \emph{Two Watched Literals} (2WL) strategy \cite{effsat,questsat}, which describes both an algorithm and a data structure to track nogoods and propagate as soon as they become unit.

An optimization technique to speed up the solving process, pioneered by the ground-and-solve system \dlv (cf.~\ref{sec:dlv}) is the introduction of a third truth value \emph{\mbt} in addition to the two usual values \emph{true} and \emph{false}. Using a third truth value also is an effective optimization in lazy-grounding systems (cf.~Sections \ref{sec:asperix} and \ref{sec:omiga}). However, 2WL does only account for two truth values, thus cannot be used in conjunction with \emph{\mbt}.

\paragraph{Goal.} The goal of this work is to combine the two improvements (2WL for propagation, which was shown to be successfully in SAT solvers as well as ground-and-solve ASP systems, and \emph{\mbt} as a third truth value) within one algorithmic framework, such that it can employed in lazy-grounding ASP systems.

Motivation for this is twofold: firstly, enabling lazy-grounding systems to profit from the benefits of 2WL, i.e.~improved propagation speeds, while still using \emph{\mbt}. Secondly, by integrating a procedure very similar to 2WL into a lazy-grounding framework, making it simpler to eventually re-use results that previously were exclusive to ground-and-solve systems in lazy-grounding systems as well.

%\section{Problem Statement}
%\label{sec:problem}
% 2wl works for sat and ground asp. how to adapt it for lazy grounding?

%2WL is an efficient technique for implementing propagation in SAT solvers \cite{effsat,questsat} and ground-and-solve ASP systems \cite[Sec.~5.3]{clasp}. However, it cannot be directly used in lazy-grounding ASP systems, because its prerequisite of a ground program is in conflict with the principle of lazy grounding. The problem to be solved therefore is finding a way to adapt the known procedure in a way that is compatible with lazy-grounding.

%\section{Aim of the Work}
%\label{sec:aim}
% enahnce 2wl st it has properties for lazy g
% -> 3wl works for lazy grounding

%\section{Methodological Approach}
% design algorithms and datastructures
% analyze and proof soundness/completeness
% implementation
% benchmarks

\paragraph{Contributions.} After an analysis of 2WL, algorithms and data structures that account for lazy-grounding are devised and their soundness is shown. We call the new approach Three Watched Literals (3WL). It comes with a description of \emph{watch strctures}, abstract data structures that suggest a memory layout for implementations, as well as a procedural description of the algorithm. It is an extension of 2WL but uses three instead of two watched literals in order to account for the third truth value \emph{\mbt}. An implementation is contributed to the Alpha system, which in turn is compared against a na{\"i}ve approach in form of a benchmark. Instances for the benchmark are taken from previous work in the field to maximize reproducibility.

\section{Structure of the Work}

In Chapter \ref{chap:prelim} we formally introduce logic programs such as the one in the above example (syntax and semantics) of ASP and stable models. Also, a selection of state-of-the-art ASP systems is discussed. The main part of the work is Chapter \ref{chap:prop} introducing Three Watched Literals (3WL), an algorithm for efficient propagation for lazy-grounding Answer Set solving based on Two Watched Literals. Evaluation of 3WL as implemented in the Alpha system is evaluated in Chapter \ref{chap:eval} and we conclude in Chapter \ref{chap:conc}.

\chapter{Preliminaries}
\label{chap:prelim}

This chapter revisits definitions of syntax and semantics of answer set programs. Interpretations and answer sets of such programs are defined.

Apart from these formal foundations, a brief overview of state-of-the-art ASP systems is given and systems that implement lazy-grounding are described.

\section{Answer Set Programming}

In Section \ref{chap:intro} we presented an example program with an intuitive description. In this section we formally define syntactic structure and variants of logic programs, and their semantics under ASP. For a thorough introduction to ASP we refer to \cite{DBLP:conf/rweb/EiterIK09}.

\subsection{Syntax}

%set of PS
%set of Consts
%set of Vars

Given a finite set of constants $\mathcal{C}$, a set of variables $\mathcal{V}$ and a finite set $\mathcal{P}$ of predicate symbols, with $\mathcal{C}$, $\mathcal{V}$, $\mathcal{P}$ pairwise disjoint, we define atoms as the \enquote{building blocks} of logic programs.

\begin{definition}
An \emph{atom} is an expression of the form $p(t_1, \ldots , t_n)$ where $p \in \mathcal{P}$ is a predicate symbol of arity $n \geq 0$ and $\{ t_1, \ldots , t_n \} \subseteq \mathcal{V} \cup \mathcal{C}$ are terms.
\end{definition}

Note that for atoms of arity zero, parentheses usually are omitted. For simplicity, this definition of atoms does not account for function symbols or function terms. Towards a distinction of ground programs (cf.~Example \ref{ex:garmentsground}) from programs with variables, we formally define the class of ground atoms, for which the set of terms coincides with the set of constants.

\begin{definition}
An atom $p(t_1, \ldots , t_n)$ is called \emph{ground} if $\{ t_1, \ldots , t_n \} \subseteq \mathcal{C}$
\end{definition}

%Atoms can be negated as usual in first order logic, leading to the definition of literals. However, note that we discriminate between two types negation in logic programs.

%\begin{definition}
%\label{def:lit}
%A \emph{literal} is an atom $q$ or its negation $\neg q$, it is \emph{ground} if $q$ is ground. The symbol $\neg$ is called \emph{classical negation} or \emph{strong negation}.
%\end{definition}

We structure atoms in the form of rules, which are in turn divided into a head, consisting of at most one atom, and a body of arbitrary size.

\begin{definition}
A \emph{rule} $r$ is an expression of the form $$a \from b_1, \ldots, b_m, \fail b_{m+1}, \ldots, \fail b_n.$$ where $a, b_1, \ldots, b_n$ are atoms, $\mathrm{not}$ is \emph{negation as failure} (or \emph{default negation}), $\{ a \}$ is the \emph{head}, denoted $\headf(a)$ and $\{ b_1, \ldots, b_m \}$ is the \emph{positive body}, denoted $\bodyf^+(r)$, and $\{ b_{m+1}, \ldots, b_n \}$ is the \emph{negative body} of $r$, denoted $\bodyf^-(r)$. Positive and negative body together are simply the \emph{body} of $r$ i.e., $\bodyf(r) = \bodyf^+(r)\cup \bodyf^-(r)$.
A rule $r$ is \emph{ground} if all atoms in $\headf(r) \cup \bodyf(r)$ are.
\end{definition}

Note that for a rule $r$ both body and head can be empty: in case $\bodyf(r)$ is empty, we say $r$ is a \emph{fact}, and when $\headf(r)$ is empty, we say that $r$ is a \emph{constraint}. Finally, we arrive at the notion of a logic program.

\begin{definition}
A \emph{(logic) program} $P$ is a finite set of rules. It is \emph{ground} if all $r \in P$ are ground.
\end{definition}

%\todo{We refer to $grnd(P)$ which is not defined. Probably we can ditch it because we do not need it anyhow ...}

For the scope of this work, the above definition of rules is sufficient. Programs consisting only of rules of this form are called \emph{normal} programs. More general, e.g.~rules with disjunctive heads $a_1 \vee \cdots \vee a_k \from \ldots$ also have interesting properties, but are outside the scope of this thesis.

In practice, many more syntactic constructs are used to ease modelling programs: arithmetic expressions, aggregates allowing statements about sets (counting how many elements match some criteria, summation of numeric values, etc.) and choice rules that encode sets of atoms for which only a given number should be in an answer set, all of which can be translated into simple rules. The core standard, widely accepted by ASP many systems, is available from \cite{calimeri2015asp}.

\subsection{Semantics}

An atom in the sense of ASP is a proposition with no deeper structure. It might represent some external state of affairs, e.g.~$rainy$ to indicate whether the weather is not nice or $handsome(yue)$ a statement about Yue being handsome. Their granularity or level of abstraction directly affects how detailed the world is modeled by a program, because atoms are treated as internally consistent statements and they cannot be split further.

In order to state the truth values of atoms in a program, we define an interpretation.

\begin{definition}
An \emph{interpretation} is a set of ground atoms $I$.
\end{definition}

%Observe that $I$ is a set of \emph{ground} literals, i.e.~we only define an interpretation for ground atoms and a na\ddot{i}ve implementation will therefore first ground the input program. This is the root of the bottleneck.

Considering Example \ref{ex:garments}, note that the set $I_1 = \{ wear(G) \}$ is not an interpretation, because the atom it contains is not ground, however $I_2 = \{ wear(winterjacket) \}$ is an interpretation, because $winterjacket$ is.

The truth value of an atom is defined by an interpretation $I$, which in turn is simply the set of atoms that are considered \emph{true}, i.e.~we say that \enquote{$a$ is \emph{true}} if $a \in I$.

Interpretations and literals are related through satisfaction.

\begin{definition}
An interpretation $I$ \emph{satisfies} a positive literal $l = p$, if $p \in I$ and a negative literal $l = \fail p$ if $p \not \in I$. We denote this as $I \models l$ .
\end{definition}

We commonly encode the truth value of atoms through satisfaction, e.g.~we say that an atom $p$ is \emph{true} under some interpretation $I$ if the the literal $l = p$ is satisfied by $I$ and vice versa. Satisfaction of literals expands to satisfaction of rules.% \cite{ryan}. TODO why is this source here?

\begin{definition}
\label{def:rule-model}
An interpretation $I$ \emph{satisfies} a ground rule $r$, denoted $I \models r$ if $\bodyf^+(r) \subseteq I$ and $\bodyf^-(r) \cap I = \emptyset$ implies that $\headf(r) \subseteq I$, i.e.~when the body of $r$ is satisfied, then the head of $r$ is satisfied as well.
\end{definition}

In case an interpretation satisfies all rules of a program, we call it a model thereof.

\begin{definition}
A \emph{(classical) model} of a ground program $P$ is an interpretation $I$ that is a model of all rules in the program, i.e.~$I \models r$ for all $r \in P$.
\end{definition}

We use the Gelfond-Lifschitz reduct towards a definition of answer sets.

\begin{definition}[see {\cite[Section 2]{stable}}]
	Given a ground program $P$ and an interpretation $I$, the \emph{Gelfond-Lifschitz reduct} (or just \emph{reduct} in short) of $P$ with respect to $I$, denoted $P^I$ is defined as follows:
\begin{multline*}
P^I = \Bigl\{ a \from b_1, \ldots , b_m \mid a \from b_1, \ldots, b_m, \fail b_{m+1}, \ldots, \fail b_n \in P\\ \text{ and } \{ b_{m+1} , \ldots , b_n \} \cap I = \emptyset \Bigr\}
\end{multline*}
\end{definition}

Finally, an answer set is a $\subset$-minimal model of the corresponding reduct.

\begin{definition}
An interpretation $I$ is an \emph{answer set} of a ground program $P$ if it is a $\subset$-minimal model of $P^I$, i.e. there is no $J \subset I$ which is also a model of $P^I$.
\end{definition}

Note that the answer sets of some logic program $P$ equal the answer sets of the corresponding ground program.

\begin{example}[{cf.~\cite[Example 16]{DBLP:conf/rweb/EiterIK09}}]
Consider the following program $P$:
\begin{align*}
citizen(alice)\from& \ .\\
democrat(C) \from& \ citizen(C),~\fail democrat(C).\\
republican(C) \from& \ citizen(C),~\fail republican(C).
\end{align*}

The corresponding ground program is as follows:
\begin{align}
citizen(alice)\from& \ . \tag{$f_1$} \\
democrat(alice) \from& \ citizen(alice),~\fail republican(alice). \tag{$r_1$} \\
republican(alice) \from& \ citizen(alice),~\fail democrat(alice). \tag{$r_2$} 
\end{align}

Note that interpretations without $citizen(alice)$ immediately conflict with $f_1$, i.e.~$f_1$ is not satisfied. Conceivable interpretations are:
\begin{align*}
I_1 =& \{ citizen(alice), democrat(alice) \}\\
I_2 =& \{ citizen(alice), republican(alice) \}\\
I_3 =& \{ citizen(alice), democrat(alice), republican(alice) \}\\
I_4 =& \{ citizen(alice) \}
\end{align*}

Considering $I_1$ we obtain the reduct $P^{I_1}$
\begin{align*}
citizen(alice)\from& \ .\\
democrat(alice) \from& \ citizen(alice).
\end{align*}
The negative body of $r_1$ is removed because $democrat(alice) \in I_1$ and $r_2$ is not in the reduct because $republican(alice) \not \in I_1$. The least model of $P^{I_1}$ coincides with $I_1$, so $I_1$ is an answer set. For the same reason (symmetric argumentation), $I_2$ is an answer set as well.

Considering $I_3$ we see that $P^{I_3}$ is just the fact $f_1$, but there are two more elements in $I_3$, so it is not an answer set.

$P^{I_4}$ contains the positive part of both rules, i.e.~$P^{I_4}$ is:
\begin{align*}
citizen(alice)\from& \ . \\
democrat(alice) \from& \ citizen(alice). \\
republican(alice) \from& \ citizen(alice).
\end{align*}
Two atoms that are in the smallest model of $P^{I_4}$, inferred via the two rules, are missing from $I_4$: $\{democrat(alice), republican(alice) \}$
\end{example}

In practice, interpretations cannot be guessed in their entirety but are constructed step-by-step in a search process called \emph{solving}. A distinction between an unassigned atom and an atom that has been found to be \emph{false} is not possible when directly working with interpretations like above; partial interpretations cannot be expressed, as everything that is not explicitly included in the interpretation is effectively assumed to be \emph{false}. This is why interpretations are commonly represented by assignments, which explicitly encode the truth value of atoms.

\begin{definition}
An \emph{assignment} $\ass$ is a set of literals. Assignments are consistent, i.e. for any literal $\bT a \in \ass$, its negation is not contained, i.e. $\bF a \not \in \ass$.
\end{definition}

Literals can be related with assignments similar to interpretations: $A \models l$ if $l \in A$. We say that an atom $p$ is unassigned if neither $A \models \bT p$ nor $A \models \bF p$. For the case where there are no unassigned atoms, the interpretation that corresponds to the assignment is the subset of all positive literals in the assignment itself.

% "ASP means stable models. Logic programs with negation may use other semantics."
%Note that we are only interested in the particular semantics of stable models which characterizes ASP and falls into the category of \emph{multiple} model semantics. There exist other semantics, such as the \emph{perfect model} semantics in \cite{DBLP:books/mk/minker88/Przymusinski88}.

\section{State-of-the-art ASP Systems}

In this section we survey state-of-the-art ASP systems in order to highlight similarities and differences in their approaches. As this work is concerned with the adoption of 2WL, a technique common in SAT solvers and ground-and-solve ASP systems, for lazy-grounding systems, we focus on the comparison of ground-and-solve and lazy-grounding systems.

The first ASP systems developed are based on the ground-and-solve approach, as it is less involved and can be implemented in a more straight-forward manner than lazy-grounding. We consider \clasp as it uses two-watched literals and employs nogood learning and \dlv because it introduced \emph{\mbt} as a truth value, which turns out to be very effective in lazy-grounding as well.

Only gradually, running into grounding issues with benchmarks and in industry settings, the grounding bottleneck was recognized, which lead to the development of lazy-grounding systems. With lazy-grounding systems being newer, and less time spent reasoning about their efficiency and engineering them, they often fail to achieve the performance of ground-and-solve systems. The main culprit of early lazy-grounding systems is that they cannot leverage state-of-the-art techniques from ground-and-solve systems: Among others, propagation using two-watched literals and heuristics are where the performance of ground-and-solve systems stems from.

\subsection{Ground-and-Solve}

We describe two very successful systems that follow the ground-and-solve approach.

\subsubsection{clingo}

\texttt{clingo}\footnote{\url{https://potassco.org/clingo/}} is a ground-and-solve ASP system, written in C++\footnote{\url{http://www.open-std.org/jtc1/sc22/wg21/}}, which combines the grounder \texttt{gringo} and the solver \texttt{clasp} \cite{clasp-first}. \clasp uses the 2WL strategy for propagation \cite[Sec.~5.3]{clasp} and implements conflict-driven nogood learning (CDNL) \cite[Sec.~4.1]{clasp} in analogy to conflict-driven clause learning (CDCL) in SAT solvers \cite{grasp,cdl-sat}. It is among the fastest ASP systems according to \cite{aspcomp2015}\footnote{See \url{http://aspcomp2015.dibris.unige.it/aspcomp2015-iclp-slides.pdf} for detailed results}.

\subsubsection{DLV}
\label{sec:dlv}

\dlv \cite{dlv} is a versatile ground-and-solve ASP system divided into front-end, intelligent grounding, model generation and model checking components. It comes with front-ends for various applications: (Extended) Disjunctive Logic Programming \cite{dlp} (similar to DISLOG \cite{dislog} and DisLoP \cite{dislop}), Diagnostic Reasoning, and the Structured Query Language\footnote{\cite{dlv} references the 1999 version available from \url{https://www.iso.org/standard/26196.html} and \url{https://www.iso.org/standard/26197.html}}). With \cite{dlv-mbt} the authors add two important features: Firstly, they introduce a third truth value, \mbt, to enhance propagation. It marks atoms that must be assigned true in order to yield an answer set, but where there is no proof found in the search process (see Section \ref{sec:asperix} and Example \ref{ex:mbt} as well). Secondly, heuristics that increase the odds of choices to be correct greatly improve overall performance.

A detailed account on the development, optimization and industrial application of \dlv is available \cite{dlvproject}.

\subsection{Lazy-Grounding}

In this section we briefly describe three different ASP systems that were designed to circumvent the grounding bottleneck. They all build on top of computations as described in \cite{computations}.

\subsubsection{ASPeRiX}
\label{sec:asperix}

\asperix is one of the first ASP systems that were designed to avoid the grounding bottleneck. It was first prototyped in 2008\footnote{According to the project's website\\ \url{http://www.info.univ-angers.fr/pub/claire/asperix/\#download}} and published in \cite{asperixfirst,fofchain}, with a detailed explanation in \cite{asperix} and a C++ implementation. Its core algorithm evolved from the concept of computation as in \cite{computations}.

In the process of finding a solution, it extends a partial interpretation \cite[Def.~4]{asperix} in form of a pair $\langle IN, OUT \rangle$ of disjoint atom sets, where the atoms in $IN$ belong to the answer set that is currently searched and the atoms in $OUT$ do not. Furthermore, the system tracks the set of ground rules, $R$, which is lazily extended by grounding the input program. Rules of the program $r$ relate to a partial interpretation and are called \emph{supported} ($\bodyf^+(r) \subseteq IN$), \emph{blocked} ($\bodyf^-(r) \cap IN \not = \emptyset$), \emph{unblocked} ($\bodyf^-(r) \subseteq OUT$), and \emph{applicable} (supported and not blocked) \cite[Def.~5]{asperix}. 

The main concept in this ASP system is an \asperix \emph{computation} \cite[Def.~7]{asperix}: It is a sequence of pairs $\langle R_i, I_i \rangle$ that captures ground rules and a partial interpretation $I_i = \langle IN, OUT \rangle$. The computation starts with $\langle \emptyset, \langle \emptyset, \{ \bot \} \rangle \rangle$ and is inductively defined through the rules \emph{propagation} (monotonic; a new rule $r_i \not \in R_{i-1}$ can be ground from the program such that it \enquote{fires}, i.e.~its head is added to $IN$), \emph{choice} (non-monotonic; there are no rules that propagate, but the solver guesses whether an applicable rule fires, i.e. forces or prohibits its instantiation) and \emph{stability} (no rules for propagation or choice left). Through inductive definition of computations, it is guaranteed that the sequence converges to an answer set iff there exists one \cite[Thm.~2]{asperix}.

The most important take-away from \asperix for this work, however is the introduction of a third truth value which allows for more efficient convergence of above computations: The truth value \mbt indicates that an atom that is not in already in $IN$ must be in $IN$ (cannot be in $OUT$) in order to find an answer set. It allows to mark certain atoms for which a \enquote{proof}, i.e. a firing rule with the atom as its head, has not yet fired, but must, at some point in the computation.

\begin{example}[{\cite[Example 7]{asperix}}]
\label{ex:mbt}
Let $\from \fail b.$ be a constraint whose body contains only one literal $\fail b$ with $b \not \in IN \cup OUT$. In order to have an answer set, $b$ must be in $IN$ so that the constraint is not applicable but $b$ is not yet proved (it is not in the head of a fired rule). Thus, one can only conclude that $b$ must be true.
\end{example}

This leads to a reduction of the search space in propagation \cite[Ex.~8]{asperix} and also decreases the size set of non-monotonic candidate rules for choice \cite[Ex.~9]{asperix}. Partial interpretation and computation are modified to consider \mbt in \cite[Def.~8]{asperix} and \cite[Def.~11]{asperix} accordingly. Again, there is a correspondence to answer sets \cite[Thm.~3]{asperix}.

\asperix shows how lazy grounding ASP systems can leverage \mbt as a third truth value. How unit propagation is affected by \mbt is a central topic in Chapter \ref{chap:prop}.

\subsubsection{OMiGA}
\label{sec:omiga}

\omiga\footnote{\url{http://www.kr.tuwien.ac.at/research/systems/omiga/}} \cite{omiga}, written in Java\footnote{\url{https://oracle.com/java/}}, uses computation to explore the search space similar to \asperix. In contrast to that it uses a so called \emph{Rete network} \cite{rete} as dominating data structure: Rete is an approach to search large collections of objects for those matching a pattern, and it was initially designed to be used in expert systems and rule based production systems, where there are many rules to consider.

In \omiga the network is used to: (a) store ground atoms, (b) retrieve ground atoms for the purpose of grounding new rules, (c) find applicable non-ground rules (\emph{propagation} in \asperix), and (d) find rules to guess on (corresponding to \emph{choice} in \asperix). While \asperix re-evaluates applicability of non-ground rules at each step in the computation, \omiga keeps grounded atoms and partial ground rule interpretations in the network. In choosing a Rete network to store these data, \omiga trades space for time, as information retrieval from the network is faster than re-computation of applicability. 

\omiga was also extended for learning of non-ground rules in \cite{nglearn}, analogous to conflict driven nogood learning as in \clasp and clause learning in SAT solvers.

\subsubsection{GASP}

GASP \cite{gasp,gasp2}\footnote{\url{https://users.dimi.uniud.it/~agostino.dovier/GASP/} and\\ \url{https://users.dimi.uniud.it/~agostino.dovier/CLPASP/}} is implemented in SICStus Prolog 4\footnote{\url{https://sicstus.sics.se/}}. It represents interpretations as finite domains and uses Constraint Logic Programming.

%\subsection{Summary}

%Any newly developed ASP system should naturally profit from the design efforts and experimental results of the above systems (and others). We therefore aim to identify key features and techniques of these approaches.

\section{Two Watched Literals}
\label{sec:2wl}

As briefly mentioned in Section \ref{sec:motivation}, Two Watched Literals (also \enquote{Two Literal Watching}, 2WL, \cite{effsat,questsat}) is an algorithm for unit propagation commonly used in SAT solvers (cf.~\cite[Section 2.2.2, p.~94]{handbook-sat}). This section is devoted to a description of the method, first in the context of SAT, then about its application in ASP solving.

In SAT solving, formulas are typically input to solvers in conjunctive normal form (CNF), i.e. conjunctions of disjunctive clauses of classical literals\footnote{The DIMACS format is commonly used to encode concrete formulas.}: $\psi = (l_{1,1} \vee \cdots \vee l_{1,k_1}) \wedge \cdots \wedge (l_{n,1} \vee \cdots \vee l_{n,k_n})$. As all disjunctive clauses are connected through conjunction, all of them must evaluate to \emph{true} for the formula to be satisfied. Each disjunctive clause evaluates to \emph{true} if at least one literal does. This property is exploited by SAT solvers to infer assignments. We call a disjunctive clause \emph{unit} if all but one literal in the clause evaluate to \emph{false}, and the last remaining literal has no truth value, i.e.~the variable in the literal is unassigned. In this case, we say that the clause \emph{propagates} and the unassigned varaible is assigned s.t.~the disjunctive clause evaluates to \emph{true}. Consider \cite{ryan} for efficient algorithms in SAT solvers.

\begin{example}
\label{ex:clause-prop}
Consider the formula $\psi = (a_1 \vee \neg a_2 \vee a_3 \vee \neg a_4) \wedge (\neg a_1 \vee \neg a_2 \vee a_3 \vee a_4)$ It yields two  disjunctive clauses, $\psi = \phi_1 \wedge \phi_2$ with $\phi_1 = a_1 \vee \neg a_2 \vee a_3 \vee \neg a_4$ and $\phi_2 = \neg a_1 \vee \neg a_2 \vee a_3 \vee a_4$, both of which have to be satisfied in order for $\psi$ to be satisfied. As the solver is evaluating $\psi$ under different (partial) assignments for atoms $a_1, \ldots, a_4$ it \enquote{watches} two literals per clause. This way it can detect whether a clause is unit. Whenever an atom $a$ is assigned it considers the clauses where $a$ is a watched literal for propagation. Conversely, all other clauses, where $a$ is not watched, are guaranteed to not be unit.
\end{example}

The concept of a nogood originates in constraint programming (CP) (cf.~\cite{clasp,handbook-cp,handbook-kr-cp}), where the goal is to find an assignment for variables such that given constraints are satisfied. SAT and ASP can be viewed as specializations of CP. For example, in a problem containing the variable $x$ and the constraint $x > 1$ one can forbid the value $x = 1$. The assignment $x = 1$ is a nogood. In this work, nogoods are only used as representations of boolean constraints. Unit propagation is sometimes also referred to as boolean constraint propagation.

\begin{definition}[cf.~\cite{handbook-cp}]
\label{def:nogood}
A \emph{nogood} is a set $\{ \bsgl_1, \ldots, \bsgl_n \}$ of literals that cannot be extended to a solution.
\end{definition}

First proposed by \citet{clasp-first}, in the solver components of ASP systems, nogoods take the role of clauses in SAT solvers. Nogoods correspond to partial assignments that cannot be extended to an answer set, and are derived from rules. \clasp uses a translation procedure based on Clark's completion \cite{clark}, described in \cite[Section 3]{clasp}, which requires knowledge of the full ground program. The Alpha system uses a different scheme defined in \cite[Definition 5]{blend} and other methods are conceivable.

\begin{example}
\label{ex:rule-to-nogood}
For example, given a rule $r$ of the form $a_1 \from a_2, a_3, \fail a_4$, the nogood $\delta = \{\bF a_1, \bT a_2, \bT a_3, \bF a_4 \}$ excludes assignments where the body of the rule is satisfied, but its head is not: An interpretation $I$ that satisfies all elements of $\bodyf(r) = \{a_2, a_3, \fail a_4 \}$ and the negation of the only element of $\headf(r)$, cannot be a model of $r$ (Definition \ref{def:rule-model}).
\end{example}

Given a nogood $\delta$ and an assignment $\ass$ with $\delta \subseteq \ass$, then no interpretation derived from $\ass$ can be a solution. This property allows for propagation: If $\ass \cap \delta = \{ \bsgl \}$, we say that $\delta$ is \emph{unit} or unit on $\bsgl$. In order to obtain a solution we may extend $\ass$ to $\ass'$ so that $\overline{\bsgl} \in \ass'$.

The number of nogoods generated from a program is proportional to the size of the corresponding ground program (depending on the translation scheme used). Thus, one can expect many nogoods, possibly millions, to be generated in the process. However, after constructing nogoods from the input program (or parts thereof, as in the lazy-grounding case) and propagating truth values, it is important to efficiently evaluate whether there is a nogood that is unit under the extended assignment. This is where the benefits of 2WL in SAT (over clauses) and in ASP (over nogoods) align.

For each nogood, two distinct and unassigned literals are chosen to be watched. When one of these literals is assigned, a different literal (distinct from the second watched literal) in the nogood is chosen as the new watched literal. This process is continued until there are no two distinct literals available in the nogood. Then the nogood is unit at this point and a new assignment can be generated.

\begin{example}
Consider Figure \ref{fig:2wl}. It shows the nogood $\delta = \{\bF a_1, \bT a_2, \bF a_3, \bT a_4 \}$ (which might be part of the representation of a rule in an ASP program, or the nogood corresponding to $\phi_1$ from Example \ref{ex:clause-prop}) in the context of propagation using 2WL. The watched literals are marked by arrows.

Initially, the two watched literals are selected arbitrarily. Transitioning from State 1 (empty assignment) to State 2, the solver will not check whether $\delta$ is unit, because $\bT a_3$ is not watched. When $a_2$ is assigned to \emph{true}, the solver checks $\delta$. As $a_2$ is assigned, $\bT a_2$ cannot be a watched literal anymore, but $\delta$ also is not unit, because $a_1$ is still unassigned. The pointer that previously pointed at $\bT a_2$ is moved to $\bF a_1$. Note that this is the only option, as the atoms of all other literals are already assigned and $\bT a_4$ is already being pointed at.

Processing the assignment of $a_1$, again, $\delta$ is considered. Now, there is no unassigned literal left that is not also watched. The nogood is unit. The truth value of $a_4$ is inferred to be \emph{false}. At this point (State 5), pointer placement is largely irrelevant, because $\delta$ is satisfied.
\end{example}
\begin{figure}
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]

\node(ng1)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={white,white,white,white},
    inner sep=8pt,
    text width=6mm,
    align=center
    ] {
$\bF a_1$     % two
\nodepart{two} $\bT a_2$
\nodepart{three}  $\bF a_3$
\nodepart{four}  $\bT a_4$
};

\node[left=0.7cm of ng1]{State 1};

\draw [<-] (ng1.two north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng1.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng1ass)[below=0.4cm of ng1] { $A_1 = \emptyset$ };
\node(ng1des)[right=1cm of ng1.east, text width=7cm] { Initially, pointers are placed arbitrarily. };

\draw ($ (ng1.east) + (1,-1.2) $) -- ($ (ng1.east) + (1,-2.2) $) node[right=0.5cm,right,pos=0.5] {$a_3$ is assigned \emph{false}.};

\node(ng2)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={white,white,yellow!60,white},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng1
    ] {
$\bF a_1$     % two
\nodepart{two} $\bT a_2$
\nodepart{three}  $\bF a_3$
\nodepart{four}  $\bT a_4$
};

\node[left=0.7cm of ng2]{State 2};

\draw [<-] (ng2.two north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng2.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng2ass)[below=0.4cm of ng2] { $A_2 = \{\bF a_3\}$ };
\node(ng2des)[right=1cm of ng2.east, text width=7cm] { Pointers were not checked, as $\bF a_3$ is not watched. };

\draw ($ (ng2.east) + (1,-1.2) $) -- ($ (ng2.east) + (1,-2.2) $) node[right=0.5cm,pos=0.5] {$a_2$ is assigned \emph{true}.};

\node(ng3)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={white,yellow!60,yellow!60,white},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng2
    ] {
$\bF a_1$     % two
\nodepart{two} $\bT a_2$
\nodepart{three}  $\bF a_3$
\nodepart{four}  $\bT a_4$
};

\node[left=0.7cm of ng3]{State 3};

\draw [<-] (ng3.one north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng3.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng3ass)[below=0.4cm of ng3] { $A_3 = \{\bF a_3, \bT a_2 \}$ };
\node(ng3des)[right=1cm of ng3.east, text width=7cm] {No pointer must point at an assigned atom, therefore it is moved. };

\draw ($ (ng3.east) + (1,-1.2) $) -- ($ (ng3.east) + (1,-2.2) $) node[right=0.5cm,right,pos=0.5] { $a_1$ is assigned \emph{false}. };

\node(ng4)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={yellow!60,yellow!60,yellow!60,white},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng3
    ] {
$\bF a_1$     % two
\nodepart{two} $\bT a_2$
\nodepart{three}  $\bF a_3$
\nodepart{four}  $\bT a_4$
};

\node[left=0.7cm of ng4]{State 4};

\draw [<-] (ng4.one north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng4.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng4ass)[below=0.4cm of ng4] { $A_4 = \{\bF a_3, \bT a_2, \bF a_1 \}$ };
\node(ng4des)[right=1cm of ng4.east, text width=7cm] {  Only one literal is left unassigned. };

\draw ($ (ng4.east) + (1,-1.2) $) -- ($ (ng4.east) + (1,-2.2) $) node[right=0.5cm,pos=0.5] { The nogood is unit, $a_4$ is assigned \emph{false}. };

\node(ng5)[
    stack=4,
    rectangle split horizontal,
    rectangle split part fill={yellow!60,yellow!60,yellow!60,teal!60},
    inner sep=8pt,
    text width=6mm,
    align=center,
    below = 3cm of ng4
    ] {
$\bF a_1$     % two
\nodepart{two} $\bT a_2$
\nodepart{three}  $\bF a_3$
\nodepart{four}  $\bT a_4$
};

\node[left=0.7cm of ng5]{State 5};

\draw [<-] (ng5.one north) to node[auto] {} ++ (-0.1,0.5);
\draw [<-] (ng5.four north) to node[auto] {} ++ (0.1,0.5);

\node(ng5ass)[below=0.4cm of ng5] { $A_5 = \{\bF a_1, \bT a_2, \bF a_3, \bF a_4 \}$ };
\node(ng5des)[right=1cm of ng5.east, text width=6cm] { $a_4$ was assigned via propagation, s.t.~the nogood is satisfied. };

\end{tikzpicture}
  \caption[Step-by-step visualization of unit propagation with Two Watched Literals]{Step-by-step visualization of unit propagation with Two Watched Literals.}
  \label{fig:2wl} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

\chapter{Three Watched Literals}
\label{chap:prop}

The central idea of propagation is to infer (\emph{propagate}) new truth values from known truth values and nogoods, derived from the input program, as briefly explained in \ref{sec:motivation}. 

In this chapter we extend Two Watched Literals (2WL), and present an algorithm that accounts for \emph{\mbt} as third truth value. We call the new algorithm Three Watched Literals (3WL).

For the description of 3WL we will largely disregard the original structure of the input logic program (both forms: with variables and ground), i.e.~its rules. We are only concerned with the solver component of the ASP system which deals with nogoods that in turn represent rules. The task of translating rules to nogoods is left to the grounder component and abstracted away for our purposes. However, we will still refer to a set of nogoods, meaning all nogoods that were generated from the input program by the grounder, and passed to the solver. Note that we do not require that these nogoods represent \emph{all} rules in the ground program, which would defeat the purpose of lazy-grounding.

The propagation algorithm described here will usually be called in alternation with the grounder component (among other procedures), searching for an assignment that represents an answer set. Visualizing which part of the ASP system we are concerned with in this work, we show the architecture of the Alpha system in Figure \ref{fig:arch}. Nogood storage implements what we call \emph{watch structures} in the following sections of the chapter, and the assignment component directly implements assignments as defined in the next section.

Concerning the control flow inside the solver system, we are not concerned with conflict resolution, but propagation only. As described below, the propagation algorithms is designed so that an implementation can stop computation as soon as a conflict is detected, but the resolution part is delegated to other components of the system.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[
    >={Latex[width=1.5mm,length=1.5mm]},
  node distance=1cm and 1cm,
  every node/.style={font=\sffamily},
  title/.style={font=\color{black!80}\sffamily},
  typetag/.style={rectangle, draw=black!50, font=\sffamily, anchor=west, text height=3mm, align=center}
]
\clip (0,-4.2cm) rectangle (11.8cm, 1.9cm);

  \node (as) at (0.7cm, -2.7cm) {};

  \node (gl) at (3.2cm, 0) [align=center, text width=2.1cm, title] { \large Grounder };

  \node (par) [below=8mm of gl.west, text width=22mm, typetag] { Parser };
  \node (gro) [below=12mm of par.west, text width=22mm, typetag] { Lazy-Grounding };
  \node (trans) [below=2.3mm of gro.west] {};

  \node (g) [draw=black, line width=2pt, inner sep=8pt, fit={(gl) (par) (trans) (gro)}] {};

  \node (sl) at (8.8cm, 0) [align=center, text width=4.5cm, title] { \large Solver };

  \node (ngs) [below=8mm of sl.east, text width=1.8cm, typetag, anchor=east, color=red, dotted, line width=2pt] { \textit{Nogood Storage} };
  \node (ass) [below=13.5mm of ngs.west, text width=1.8cm, typetag, color=red, dotted, line width=2pt] { \textit{Assignment} };
  \node (conf) [left=6mm of ngs.west, text width=1.8cm, typetag, anchor=east] { Conflict Resolution };
  \node (heur) [below=12mm of conf.west, text width=1.8cm, typetag] { Decision Heuristic };

  \node (s) [draw=black, line width=2pt, inner sep=8pt, fit={(sl) (ngs) (ass) (heur) (conf)}] {};
  
  
  \draw [->,line width=1.5pt] (s.south) to [out=230, in=310] node [midway, above=1.2ex] {partial Assignment} (g.south);
  
  
  \draw [->, draw=black!80] ($(ass.south)+(5mm,0)$) to node [pos=0.6, left] {Answer-Set} ($(ass.south)+(5mm,-1.5cm)$);

  
  \draw [->,line width=1.5pt] (g.north) to [out=50, in=130] node [midway, below=1mm] {Nogoods} (s.north);
  \draw [->, draw=black!80] (heur.west-|g.east) to node [pos=0.38, text width=1cm] {Choice Atoms} (heur.west) ;
  
  
  \draw [<->, draw=red, dotted] (ngs) -- (ass) node [midway, pos=0.3] {};
  \draw [->, draw=black!80] (conf) -- (heur) {};
  \draw [->, draw=black!80] (heur.east|-ass.west) -- (ass.west) {};
  
  \draw [<->, draw=black!80] (conf) to (ngs)  {};
  
  
  \draw [->, draw=black!80] (par) -- (gro) {};
  
  
  \draw [->, draw=black!80] ($(par)+(-3.0cm,0)$) -- (par) node [pos=0.3, above] {Program};
\end{tikzpicture}
\caption[Architecture of the Alpha system]{Architecture of the Alpha system \cite[Figure 1]{alpha-techniques}. Data flow is indicated by arrows. Grounder (left) and CDNL-based solver (right) interact cyclically for lazy-grounding. The components implementing Three Watched Literals (Nogood Storage and Assignment) are highlighted in red italics and have dotted borders.}
  \label{fig:arch}
\end{figure}

\section{Extended Notions for Lazy-Grounding}

% Signed literal vs. boolean signed literal.

In this section we amend the definition of literals and nogoods for the purpose of propagation with \emph{\mbt}. Atoms remain unchanged in their definition, however we will allow literals to not only be \emph{true} and \emph{false} but also \emph{\mbt}. Also, we will use assignments as sequences (not sets) to exploit the ordering of literals in the assignment for our method.

%Most of them fundamentally depend on \emph{atoms} (usually denoted $v$) but do not refer to neither a set of atoms nor their domain. This is because all definitions are bound to a logic program $P$ to be solved (i.e.~to find answer sets for). The set of ground atoms wrt.~$P$, effectively its Herbrand Base $\textit{HB}(P)$, is obtained by the grounding process, which is not detailed in this work. What might seem to be lacking from the definitions therefore is the context of the input program $P$ and the domain of atoms. $P$ and its context is omitted in the following.

%In this section we define the notions 
%As we will be mainly concerned ith assignments, sequences that, informally, \enquote{relate} to interpretations, but require explicitly stating that some atom is \emph{false}.

% TODO: Where does v come from? Should be in some HB(P)?
%\begin{definition}
%A \emph{ground atom} (or simply \emph{atom}) wrt.~a logic program $P$ is an element of $\textit{HB}(P)$, usually denoted $v$.
%\end{definition}

For the remainder of the work we consider boolean signed literals, which mean atoms and their negations in the classical sense, and, more generally, signed literals, which also allow for a third sign that allows modeling \emph{\mbt}.

\begin{definition}
A \emph{boolean signed literal} $\bsgl$ is of the form $\bT v$ or $\bF v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, and $\bF v$ that it is \emph{false}.
\end{definition}

\begin{definition}
A \emph{signed literal} $\sgl$ is of the form $\bT v$, $\bF v$, or $\bM v$ where $v$ is an atom and $\bT v$ expresses that $v$ is \emph{true}, $\bF v$ that it is \emph{false} and $\bM v$ that it \emph{\mbt}.
\end{definition}

%\begin{definition}
%The function $\wkn(\bsgl)$ takes a boolean signed literal $\bsgl$ and transforms it into a signed literal referred to as its \emph{weak form}, meaning that while \emph{false} stays \emph{false}, e.g.~$\wkn(\bF v) = \bF v$, \emph{true} is mapped to \emph{\mbt}, e.g.~$\wkn(\bT v) = \bM v$.
%\end{definition}

% TODO: Remark on boolean signed literal vs. signed literal with context of clasp?

With the introduction of literals like $\bM v$, we also explicitly define two forms of taking the complement of such literals.

\begin{definition}
Strong complement, denoted by $\negstrong{\sgl}$, and weak complement, $\negweak{\sgl}$, mapping $\bF v$ to $\bT v$ and $\bF v$ to $\bM v$ respectively, of a signed literal are defined by the following truth table:%equalities: $\negstrong{\bT v} = \bF v$, $\negstrong{\bM v} = \bF v$ and  $\negstrong{\bF v} = \bT v$, while $\negweak{\bT v} = \bF v$, $\negweak{\bM v} = \bF v$ and $\negweak{\bF v} = \bM v$.
% "andere Richtung auch erklären"

\begin{center}
\begin{tabular}{|c|cc|}
\hline
$\sgl$&$\negstrong{\sgl}$&$\negweak{\sgl}$\\
\hline
\hline
$\bT v$&$\bF v$&$\bF v$\\
$\bM v$&$\bF v$&$\bF v$\\
$\bF v$&$\bT v$&$\bM v$\\
\hline
\end{tabular}
\end{center}
\end{definition}

A literal does not only conflict with its strong complement but also with its weak complement.

\begin{definition}
Two literals $\sgl_1, \sgl_2$ are said to \emph{conflict} in case $\sgl_1 = \negweak{\sgl_2}$ or $\negweak{\sgl_1} = \sgl_2$.
\end{definition}

Occasionally the notation $\sgl = \bX v$ will be used to express that $\sgl$ is a literal of $v$ where $\bX \in \thrice$, i.e.~$\sgl$ is over the atom $v$, but the sign is not important.

Also, we will need to find the boolean signed literal for a given signed literal.

\begin{definition}
The \emph{boolean projection} of a signed literal $\sgl$, denoted $\bass(\sgl)$ translates a signed literal into a boolean signed literal and is defined as follows:

\begin{center}
\begin{tabular}{|c|c|}
\hline
$\sgl$&$\bass(\sgl)$\\
\hline
\hline
$\bT v$&$\bT v$\\
$\bM v$&$\bT v$\\
$\bF v$&$\bF v$\\
\hline
\end{tabular}
\end{center}
\end{definition}

We define assignments similar to \cite[Section 2, p.~3]{clasp}. However, here assignments contain not boolean signed literals, but signed literals, and the notation for expressing a partial assignment differs.

\begin{definition}
An \emph{assignment} $\ass$ is a sequence $(\sgl_1, \ldots, \sgl_n)$ of signed literals $\sgl_i = \bX v_i$ with $1 \leq i \leq n$, or the special sequence \emph{conflict}, indicating a conflict.
\end{definition}

%\begin{remark}
Below, assignments are sometimes also used as sets, in which case the set represented by some assignment is simply the set of all signed literals contained in the sequence.
%\end{remark}

For an assignment $\ass = (\sgl_1, \ldots, \sgl_i, \ldots, \sgl_j, \ldots, \sgl_n)$, we denote its size as $|\ass|$ with $|\ass| = n$ and $|conflict| = 0$, and a partial assignment, which is a sub-sequence constructed from an assignment, as $\ass[i,j] = (\sgl_i, \ldots, \sgl_j)$ where $1 \leq i < j \leq n$. Furthermore, we reference a single literal using $A[i] = \sgl_i$ for $1 \leq i \leq n$.

The assignment obtained by appending the literal $\sgl$ to $\ass = (\sgl_1, \ldots, \sgl_n)$ is denoted by $$\ass \circ \sgl = \left\{\begin{array}{ll}
        
        \emph{conflict} & \text{if } \{ \negstrong{\sgl}, \negweak{\sgl} \} \cap \ass \not = \emptyset \text{ or } \ass = \emph{conflict}\\
        %(\sgl_1, \ldots, \sgl_{n-1}, \sgl) & \text{if } \sgl = \bT v \text{ and } \bM v \in \ass \text{, i.e. appending } \bT v \text{ removes } \bM v\\
        (\sgl_1, \ldots, \sgl_{n}, \sgl) & \text{otherwise} \\
        \end{array}\right.$$

%Appending preserves that for any atom $v$ there is at most one literal in the assignment: With $\sgl = \bT v$ and $\bM v \in \ass$, for $\ass' = \ass \circ \sgl$ it holds that $\bM v \not \in \ass'$ (and $|\ass'| = |\ass|$).

%Furthermore $\emph{conflict} \circ \sgl = \emph{conflict}$ for any $\sgl$. 

For every assignment, we can also construct a corresponding boolean assignment, which is obtained by applying the boolean projection to all contained literals. We overload the function $\bass$ for assignments. Boolean assignments are just sets, and not sequences like assignments are, because we do not require any ordering in this work.

\begin{definition}
A \emph{boolean assignment} is a set of boolean signed literals derived from an assignment, denoted $\bass(\ass)$ and defined as $\bass(\ass) = \{ \bass(\sgl) \in \ass \}$, where $\bass$ applied to literals is the boolean projection.
\end{definition}

Relating assignments with literals and atoms, we say that an atom $v$ is \emph{assigned} under some assignment $\ass$ if any literal containing it is in $\ass$, i.e.~if $\ass \cap \{\bT v, \bM v, \bF v \} \not = \emptyset$. We say that an atom is unassigned under $A$ if it is not assigned under $A$.

%\begin{definition}
%An atom $v$ is \emph{unassigned} under some assignment $\ass$ iff $$\ass \cap \{\bT v, \bM v, \bF v \} = \emptyset$$
%\end{definition}

%\begin{definition}
%A signed literal $\bX v$ is \emph{assigned} under $\ass$ if $v$ is assigned under $\ass$.
%\end{definition}

%Intuitively, atoms and literals are \emph{unassigned} under $\ass$ iff the are not assigned under $\ass$.

\begin{definition}
A literal $\sgl_1$ is said to conflict with $\ass$ in case it conflicts with any $\sgl_2 \in \ass$.
\end{definition}

We extend Definition \ref{def:nogood}. For propagation with \emph{\mbt}, it is important to qualify literals in nogoods that correspond to heads of rules, as the head might only propagate to \emph{true} in case all positive literals in the body are \emph{true} as well (but none of them is \emph{\mbt}). %\todo{Longer introduction to nogoods with head woould be nice. Example maybe?}

\begin{definition}[{cf.~\cite{alpha-techniques}}]
The \emph{head} of a nogood $\delta$, is a single literal $\headf(\delta)$, for which $\headf(\delta) \in \delta$. Not every nogood must have a head.% and $|\headf(\delta)| \leq 1$.
\end{definition}

%Note that $\headf(\delta)$ is always of the form $\bF v$. \todo{Why?} Complementary we define the body, as all literals that are not in the head.

%\begin{definition}
%The \emph{body} of a nogood $\delta$ a set of literals $\bodyf(\delta)$ such that $\bodyf(\delta) \cap \headf(\delta) = \emptyset$ and $\delta = \bodyf(\delta) \cup \headf(\delta)$.
%\end{definition}

We need two variants of a nogood being unit. One that accounts for \emph{\mbt} and one that does not, i.e.~it treats $\bM v$ the same as $\bT v$.

\begin{definition}
A nogood $\delta$ is \emph{strongly unit} under an assignment $\ass$ if $\delta \setminus \ass = \headf(\delta)$. Only nogoods with a head can be strongly unit.
\end{definition}

Note that any nogood that is strongly unit under some assignment is also weakly unit, but not the other way round. Below, nogoods are sometimes referred to be \emph{unit} which amounts to stating that they are weakly unit. Also, when clear from context, reference to a particular assignment is omitted.

Violation of a nogood (signaling that the assignment under question violates a rule) does not distinguish between \emph{true} and \emph{\mbt}.

\begin{definition}
\label{def:vio}
A nogood $\delta$ is \emph{violated} under an assignment $\ass$ if $\delta \subseteq \bass(\ass)$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{satisfied} under an assignment $\ass$ if there is no $\ass' \supseteq \ass$ s.t.~$\delta$ is violated under $\ass'$.
\end{definition}

\begin{definition}
A nogood $\delta$ is \emph{weakly unit} under an assignment $\ass$ if $\delta \setminus \bass(\ass) = \{ \bsgl \}$
\end{definition}

\begin{example}
Consider the nogoods $\delta_1 = \{ \bT a_1, \bF a_2 \}, \delta_2 = \{ \bT a_3, \bF a_4 \}$ with the head of $\delta_2$ being $\headf(\delta_2) = \bF a_4$ and how they relate to the following assignments:
\begin{center}

\begin{tabular}{|l||c|c|}
\hline
Assignment & State of $\delta_1$ & State of $\delta_2$ \\
\hline\hline
$\ass_1 = \{ \bT a_1, \bT a_3 \}$ & weakly unit & strongly unit\\
$\ass_2 = \{ \bM a_1, \bM a_3 \}$ & weakly unit & weakly unit\\
$\ass_3 = \{ \bF a_1, \bF a_3 \}$ & satisfied & satisfied \\
$\ass_4 = \{ \bF a_2, \bF a_4 \}$ & weakly unit & weakly unit\\
$\ass_5 = \{ \bT a_1, \bF a_3 \}$ & violated & \\
$\ass_6 = \{ \bM a_1, \bF a_3 \}$ & violated & \\
$\ass_7 = \{ \bT a_3, \bF a_4 \}$ & & violated  \\
$\ass_8 = \{ \bM a_2, \bT a_4 \}$ & satisfied & satisfied \\
\hline
\end{tabular}
\end{center}
\end{example}

Note that for an assignment $\ass$, any nogood that is satisfied under $\ass$ will also never be unit, and never propagate, for any $\ass' \supseteq \ass$.

\begin{definition}
A nogood $\delta$ is \emph{silent} under some assignment $\ass$ if $\delta$ is not violated by $\ass$ and $\delta$ is not unit wrt.~$\ass$.
\end{definition}

Note the difference between some $\delta$ being silent vs.~satisfied under an assignment: With $\delta$ being silent under $\ass_1$, there might well be some $\ass_1' \supset \ass_1$ under which $\delta$ is unit or violated. However $\delta$ satisfied under $\ass_2$ is stronger and implies that there is no larger assignment $\ass_2' \supset \ass_2$ such that $\delta$ is not satisfied under $\ass_2'$. It follows that $\delta$ can neither be unit nor violated under $\ass_2'$.

\section{Watch Structures}

In Section \ref{sec:2wl} we did not detail how a data structure that stores which two literals are watched for each nogood might look like. References to the watched literals are illustrated in Figure \ref{fig:2wl} as pointers, and indeed we are suggesting some form of lookup table: As a new literal $\sgl$ is added to the assignment, the propagation algorithm will resolve the set of nogoods containing $\sgl$ as a watched literal. We define an abstract data structure for this lookup.

%suggesting some form of lookup table. Indeed, we suggest the 

%Without an efficient way of associating assigned atoms with the nogoods that they are \enquote{watching}, there is no benefit in using watched literals at all. We therefore define watch structures, abstract data structures that allow to store this information.

%Concrete implementations might use hash table lookups to implement watch structures as outlined below.

%Here, a watch structure is a function that maps atoms to to triples, as 

%When implementing propagation, na{\"i}vely obtaining checking a large set of nogoods that represents an ASP program for unity is infeasible. Sophisticated data structures are needed to make propagation sufficiently fast.

\begin{definition}
% ASK: Why not define watch structure as a function/relation mapping from atom to watch sets? Structure is irrelevant, and mapping function is closer to a map in code.
% ASK: How to omit irrelevant elements of a tuple?
A \emph{watch structure} is a function that maps an atom $a$ to a triple containing sets of nogoods, the so called \emph{watch sets} of $a$: $$\Delta(a) = \langle W^+, W^-, W^\alpha \rangle .$$

%For any watch set $W$ in $\Delta(v)$ and nogood $\delta \in W$ it follows that $\bX v \in \delta$.

For some signed literal $\sgl = \bX a$ let $$\dpm(\sgl) = \left\{\begin{array}{ll}
        W^+ & \text{if } \sgl = \bT a \ \text{or } \sgl = \bM a\\
        W^- & \text{if } \sgl = \bF a \\
        \end{array}\right\} \text{with } \Delta(a) = \langle W^+, W^-, W^\alpha \rangle .$$

For some signed literal $\sgl = \bX a$ or an atom $a$ let $$\dal(\sgl) = \dal(a) = W^\alpha \ \text{with } \Delta(a) = \langle W^+, W^-, W^\alpha \rangle .$$
\end{definition}

When we refer to the \enquote{nogoods in $\Delta$}, we mean all nogoods in all watch sets of all atoms that $\Delta$ is defined for. For the remainder of the work we further assume that all known nogoods, i.e.~all those generated by the grounder, are in $\Delta$ and only their membership in watch sets, i.e.~their watched literals, change.

The functions $\dpm(\sgl)$ and $\dal(\sgl)$ can for example be implemented through table lookups (visualized in Figure \ref{fig:watches}), which take constant time. When a literal $\bX a$ is appended to the assignment, all nogoods that might have become unit can be found in the sets $\dpm(\bX a)$ and $\dal(\bX a)$.

%Interpretation as a set $\Delta = \{(v_i, (W_i^+, W_i^-, W_i^\alpha)\}$ for $1 \leq i \leq n$ where $i \not = j \to v_i \not = v_j$ for $1 \leq j \leq n$ reveals how such a mapping can be stored or visualized (see figure~\ref{fig:watches}).

\begin{figure}
  \centering
\begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, anchor=center},->]
\node(s)[stack=4]  {
                 Atom     % text
\nodepart{two}   $v_1$     % two
\nodepart{three} $v_2$      % three
\nodepart{four}  \vdots % four
};

\node(v1t)[stack=3, rectangle split horizontal, above right=2cm and 3cm of s.two] {
$\delta_1$     % two
\nodepart{two} $\delta_2$      % three
\nodepart{three}  \ldots % four
};

\node(v1m)[stack=3, rectangle split horizontal, above right=1cm and 3.5cm of s.two] {
$\delta_3$     % two
\nodepart{two} $\delta_4$      % three
\nodepart{three}  \ldots % four
};

\node(v1f)[stack=3, rectangle split horizontal, above right=0cm and 4cm of s.two] {
$\delta_5$     % two
\nodepart{two} $\delta_6$      % three
\nodepart{three}  \ldots % four
};

\path (s.two east)
edge [out=east,in=west, left] node {$+$} (v1t)
edge [out=east,in=west, above] node {$-$} (v1m)
edge [out=east,in=west, above] node {$\alpha$} (v1f)
;

\end{tikzpicture}
  \caption[Example layout of a watch structure]{Example layout of a watch structure.}
  \label{fig:watches} % \label has to be placed AFTER \caption (or \subcaption) to produce correct cross-references.
\end{figure}

A crucial part of this work is the relation between watch structures and assignments: In order to use lookups in watch structures for efficient propagation, we must define which atoms should be considered as watched literals. We first consider single nogoods, and then extend the definition to watch structures as sets of nogoods. Given a nogood $\delta$ and an assignment $\ass$ we call the subsets of literals in $\delta$ that might be watched the \emph{candidate sets}. For the case of 2WL, there is just one candidate set, which is the set of unassigned literals. For $\dpm$ we use the same definition. However, with \emph{\mbt}, we must also consider candidates for $\dal$.

%We call the set of literals that can be watched
%For 2WL, only unassigned literals can we \enquote{watched}. Again, suppose some new assignment $\bX v$ is made, and 

\begin{definition}
The \emph{candidate sets} of a nogood $\delta$ under an assignment $A$ are subsets of the nogood  and defined as follows:

$$\cdpm(\delta, A) = \{\bsgl \in \delta \ | \ \bsgl \not \in \bass(\ass) \}$$

$$\cdal(\delta, A) = \{ \bT v \in \bodyf(\delta) \ | \ \bT v \not \in \ass \}$$
\end{definition}

Intuitively, $C_\alpha(\delta, A)$ is the set of positive body literals in $\delta$ that are not assigned to be $\emph{true}$. Based on the definition of candidates, we say that a watch structure \emph{watches} an assignment if the watch sets of all nogoods contain candidates so that unit nogoods can be detected by checking the watch sets for newly assigned atoms.

\begin{definition}
A watch structure $\Delta$ \emph{\lowinv} an assignment $\ass$ if for every nogood $\delta \in \Delta$ holds:

\begin{enumerate}
\item $|\cdpm(\delta, A)| \geq 2$ implies there exist $\bsgl_1, \bsgl_2 \in \cdpm(\delta, A)$ such that $\bsgl_1 \not = \bsgl_2$ and $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$, and
%Older version: \item If $\delta$ is not satisfied under $\ass$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ unassigned under $\ass$, then $\delta$ is contained in exactly two distinct watch sets, e.g. $\delta \in \dpm(\bsgl_1)$ and $\delta \in \dpm(\bsgl_2)$ with $\bsgl_1 \not = \bsgl_2$.
\item $\cdal(\delta, A) \not = \emptyset$ implies that there is exactly one $\bsgl \in \cdal(\delta, A)$ with $\delta \in \dal(\bsgl)$.
\end{enumerate}
\end{definition}

Given $\Delta$ watching $\ass$ and a new assignment for some atom $\sgl$, the nogoods that are candidates for propagation are those in $\dpm(\sgl)$ (in case $\sgl \not \in A$, thus $\sgl$ changes from \emph{unassigned} to \emph{true}, \emph{\mbt} or \emph{false}) and $\dal(\sgl)$ (in case $\sgl \in A$, thus $\sgl$ changes from \emph{\mbt} to \emph{true}).

Note that with $\Delta$ watching $\ass$ and extending the assignment $\ass' = \ass \circ \sgl$, now $\Delta$ does not trivially watch $\ass'$.

Considering a set of nogoods and an assignment, one way to ensure that no nogood will propagate under the assignment is to require all nogoods being silent under the assignment. We combine this condition with a watch structure watching an assignment and use it as the goal state for 3WL.

\begin{definition}
A watch structure $\Delta$ \emph{silently watches} assignment $\ass$ in case all nogoods $\delta \in \Delta$ are silent under $\ass$ and $\Delta$ watches $\ass$.
\end{definition}

%In the next section, a closer look at propagation will reveal that when transitioning from an assignment to the next one, watch sets can be altered efficiently to obtain a well formed watch structure for the extended assignment.

\section{Unit Propagation}

In this section we detail Three Watched Literals (3WL). The process is split into four algorithms, varying in level of abstraction:
\begin{description}
	\item[Algorithm \ref{alg:up}]{is the most high-level algorithm. Given a new literal to append to an assignment, it first appends the literal and then applies Algorithm \ref{alg:upsingle} repeatedly, until no new assignments can be inferred. The input watch structure must be silently watching the assignment.}
	\item[Algorithm \ref{alg:upsingle}]{is concerned with processing a single assignment. Given an index in the assignment it calls \ref{alg:upu}, and in case the literal is of the form $\bT a$ also calls \ref{alg:upa}.}
	\item[Algorithm \ref{alg:upu}]{handles propagation or chooses a new watched literal for nogoods that are weakly unit, based on $\dpm$.}
	\item[Algorithm \ref{alg:upa}]{handles propagation or chooses a new watched literal for nogoods that are strongly unit, based on $\dal$.}
\end{description}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		a~signed~literal~$\sgl$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation with literal $A[j]$ and $\Delta$ with updated watches.}
  $\langle \ass_1, \Delta_1 \rangle \leftarrow \langle \ass \circ \sgl, \Delta \rangle$ \label{alg:up:circ}\\
  $i \leftarrow 1$ \label{alg:up:i}\\
  \While{$|\ass_i| \geq |A| + i$\label{alg:up:loop:begin}}{
  $\langle \ass_{i+1}, \Delta_{i+1} \rangle \leftarrow$ \textsc{UnitPropagate}($\ass_{i}$, $\Delta_{i}$, $|A| + i$) \label{alg:up:loop:prop}\\
    $i \leftarrow i + 1$ \label{alg:up:loop:incr}
  } \label{alg:up:loop:end}
  \Return{$\langle \ass_i, \Delta_i \rangle$} \label{alg:up:ret}
  \caption{\textsc{UnitPropagateAll}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:up}
\end{algorithm}

\begin{algorithm}
  \SetKw{BreakFor}{break for}
  \KwIn{An assignment $\ass$,
        a~watch~structure~$\Delta$,
		an~index~$j$.}
  \KwOut{The assignment $\ass$, extended by means of unit propagation and $\Delta$ with updated watches.}
%  \If{$|A| < j$}{\Return{$\langle \ass, \Delta \rangle$}}
  $\sgl \leftarrow \ass[j]$ \label{alg:up:loop:lit}\\
  $\langle \ass', \Delta' \rangle \leftarrow$ \textsc{UnitPropagateWeakly}($\ass$, $\Delta$, $\sgl$)\\
  \If{$\sgl$ is of the form $\bT a$}
  {
    $\langle \ass'', \Delta'' \rangle \leftarrow$ \textsc{UnitPropagateStrongly}($\ass'$, $\Delta'$, $\sgl$)\\
    \Return{$\langle \ass'', \Delta'' \rangle$}
  }
  \Return{$\langle \ass', \Delta' \rangle$}
  \caption{\textsc{UnitPropagate}($\ass$, $\Delta$, $j$)}
  \label{alg:upsingle}
\end{algorithm}

The solver component initially and after each decision expands its assignment by inferring new literals through unit propagation. We define Algorithm \ref{alg:up} \enquote{exhaustively}, i.e.~in such a way that it will only terminate when no new assignments can be inferred through unit propagation or a conflict was reached. It takes the current assignment $A$ and a watch structure $\Delta$ that silently watches $A$, and the next literal to be appended to the assignment $\sgl$. In the first line of the algorithm, $A_1$ is generated by appending $\sgl$ to $A$. However, $\Delta$, the input watch structure, equals $\Delta_1$. So while $\Delta$ silently watches $A$, this might not be the case for $\Delta_1$ and $A_1$, because $A_1$ contains one more literal that might lead to some nogood in $\Delta_1$ being unit. This triggers a domino effect of unit propagation.

The loop in lines 3 to 6 will then restore $\Delta_{i+1}$ to silently watch $\ass_{i+1}[1, |A| + 1]$. At the point where all all nogoods are silently watched again, the loop terminates because $|A_i| < |A| + i$. In case a conflict is reached in any iteration, the loop will break, because we carefully defined $|conflict| = 0$ and $i$ is at least one.

Before new assignments are resolved to the nogoods that must be checked, Algorithm \ref{alg:upsingle} is invoked. It serves the purpose to decide which propagation algorithm(s) should be called. Algorithm \ref{alg:upu} is always called, but it is sufficient to Algorithm \ref{alg:upa} only if an atom was assigned to be \emph{true}, i.e. $\sgl$ is of the form $\bT a$. This is because the relevant candidate set $\cdpm(\delta, \ass)$ changes only as atoms are assigned to \emph{true}.

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~set~of~watched~nogoods~$\Delta$,~and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation and $\Delta$ with updated watches.}
%  \ForEach{$\delta \in w_{=2}(\Delta, \sigma)$ of form $\{ \sigma, \sigma' \}$}
%  {
%    \If{$\sigma'$ is unassigned in $\mathbf{A}$}
%    {
%      $\mathbf{A} \leftarrow \mathbf{A} \circ \negweak{\sigma'}$
%    }
%  }
  \ForEach{$\delta \in \dpm(\sgl)$ \label{alg:upu:it}}
  {
    \uIf{$\delta$ is violated \label{alg:upu:vio}}
    {
      \Return{$\langle \emph{conflict}, \Delta \rangle$ \label{alg:upu:conflict}}
    }
    \uElseIf{$\delta$ is strongly unit \label{alg:upu:su}}
    {
      $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upu:su:circ}
    }
    \uElseIf{$\delta$ is weakly unit with $\bsgl$ unassigned \label{alg:upu:wu}}
    {
      $\ass \leftarrow \ass \circ \negweak{\bsgl}$ \label{alg:upu:wu:circ}
    }
    \Else%If{there is some unassigned $\sigma' \in \delta$}
    { \label{alg:upu:else}
      \ForEach{$\bsgl \in \delta$}
      {
      	$\dpm(\bsgl) \leftarrow \dpm(\bsgl) \setminus \{ \delta \}$ \label{alg:upu:rm}
 	  }\label{alg:upu:move:start}
      Let $\bsgl_1, \bsgl_2 \in C_\pm(\delta, A)$ be arbitrary\\
      $\dpm(\bsgl_1) \leftarrow \dpm(\bsgl_1) \cup \{ \delta \}$\\
      $\dpm(\bsgl_2) \leftarrow \dpm(\bsgl_2) \cup \{ \delta \}$ \label{alg:upu:move:end}\\
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateWeakly}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upu}
\end{algorithm}

Algorithm \ref{alg:upu} shows how unit propagation is used to infer assignments from watched nogoods. Its input is the current assignment $A$, a watch structure $\Delta$ and the literal $\sgl$ that has been newly assigned and should be processed. Tracing the invocation of the algorithm we notice that $\sgl$ in Algorithm \ref{alg:upu} corresponds with $\sgl$ in Algorithm \ref{alg:upsingle} and $A_i[|A| + i]$ in Algorithm \ref{alg:up}.

The set of nogoods that are touched by the algorithm is $\dpm(\sgl)$, i.e.~all nogoods $\delta$ where $\sgl$ is one of the watched literals. In lines 2 to 7 all cases that require no change of watched literals are handled:

\begin{itemize}
\item $\delta$ is violated (lines 2-3) and all propagation can be stopped because a conflict was reached.
\item $\delta$ is strongly unit (lines 4-5) and a new assignment for the head literal of $\delta$ is generated by taking its strong complement.
\item $\delta$ is weakly unit (lines 6-7) and a new assignment for some literal is generated based on the weak complement.
\end{itemize}

Note that these three cases are not mutually exclusive, e.g. a nogood might be strongly unit and weakly unit under the same assignment. In this case, the algorithm will run into the branch in lines (4-5), so that propagation to \emph{true} overrides propagation to \emph{\mbt}. Without checking for $\delta$ being strongly unit, cases where assignments to \emph{false} lead to $\delta$ being strongly unit would be overlooked, as Algorithm \ref{alg:upa} is only called for assignments to \emph{true}.

With the above cases handled, there must be at least two literals in the candidate set $\cdpm(\delta, A)$, but $\sgl$ is assigned, so a new watched literal has to be found for $\delta$ to be maintained. In lines 9 to 11 all watches are removed, or rather $\delta$ is removed from the watch sets of all its watched literals. Then, in lines 12 to 14, $\delta$ is again inserted into the watch sets for two arbitrary candidates.
 
% In line 1, the input literal $\sgl$ is transformed to its weak form as lookups in $\Delta$ are always made against the set of nogoods that might propagate in case the literal \mbt, even if $\sgl$ is of $\bT x$. % Why?
%In the loop spanning from line 2-13 all nogoods that are to be checked for propagation according to $\Delta$ are iterated. For any such nogood one of the following three cases holds true
%\begin{enumerate}
%\item it is violated, leading to the algorithm immediately returning the conflicting assignment, or
%\item it is weakly unit, in which case a new assignment can be inferred from the nogood, or
%\item in any other case, there must be at least two unassigned literals in $\delta$, which are to be watched for changes in assignments.
% TODO: Does not (1.) and not (2.) guarantee that there are two unassigned literals?! Nogood could be satisfied.
%\end{enumerate}

%In case (3.), $\Delta$ is modified in lines 8-11. As $\sgl$ is now assigned, it should not be watched for changes anymore. This is achieved by removing $\delta$ from the set of watches $\Delta(\sgl)$ and instead adding it to the set of watches for two unassigned literals in $\delta$.

\begin{algorithm}
  \KwIn{An~assignment~$\ass$,
        a~watch~structure~$\Delta$, and
        a~literal~$\sgl \in \ass$.}
  \KwOut{$\ass$ extended by means of nogood propagation.}
  \ForEach{$\delta \in \dal(\sgl)$}
  {
	\uIf{$\delta$ is strongly unit}
	{
	  $\ass \leftarrow \ass \circ \negstrong{\headf(\delta)}$ \label{alg:upa:su:circ}
	}
    \ElseIf{$C_\alpha(\delta, A) \not = \emptyset$}
    {
      \label{alg:upa:move:start}
      $\dal(\sgl) \leftarrow \dal(\sgl) \setminus \{ \delta \}$\\
      % Choose $\bsgl \in L$ s.t.~there is no $\bsgl' \in L$ with $\ass = (\ldots, \bsgl, \ldots, \bsgl', \ldots)$.\\
      Let $\sigma \in C_\alpha(\delta, A)$ be arbitrary\\
      $\dal(\bsgl) \leftarrow \dal(\bsgl) \cup \{ \delta \}$\\
      \label{alg:upa:move:end}
    }
  }
  \Return{$\langle \ass, \Delta \rangle$}
  \caption{\textsc{UnitPropagateStrongly}($\ass$, $\Delta$, $\sgl$)}
  \label{alg:upa}
\end{algorithm}

Algorithm \ref{alg:upa} works in a similar way but without the need to check for violations/conflicts and nogoods being weakly unit, as these cases are handled by Algorithm \ref{alg:upu}. Further, by the definition of a nogood $\delta$ being strongly unit, we know that all positive literals (except the head literal) of $\delta$ must be assigned to \emph{true}, and not only to \emph{\mbt} for propagation.

\begin{theorem}
Algorithm \ref{alg:up} is sound, i.e.~given an assignment $\ass$, a watch structure $\Delta$, a literal $\sgl$, and the following precondition, it results in a new assignment $\ass'$ and a new watch structure $\Delta'$ such that the following postconditions all hold:
\begin{enumerate}[label={\normalfont (\textsc{Pre})},ref=(\textsc{Pre})]
\item $\Delta$ silently watches $A$. \label{up:sound:pre}
\end{enumerate}
\begin{enumerate}[label={\normalfont (\textsc{Post}\arabic*)},ref=(\textsc{Post}\arabic*)]
\item If $\sgl$ does not conflict with $\ass$ and there are assignments that can be inferred by means of unit propagation without a conflict, then $\Delta'$ silently watches $\ass'$. \label{up:sound:post2}
\item If $\sgl$ does not conflict with $\ass$ but a literal inferred from $\Delta$ and $\ass \circ \sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$. \label{up:sound:post3}
\item If $\sgl$ conflicts with $\ass$, then $\ass' = \emph{conflict}$ and $\Delta' = \Delta$. \label{up:sound:post1}% Trivial case.
\end{enumerate}
\end{theorem}

\begin{proof-sketch}
%We show that:

%\begin{enumerate}
%\item in case $\sgl$ conflicts with $\ass$, the algorithm will return the assignment \emph{conflict} and $\Delta$ is not guaranteed to be well formed,
%\item otherwise, the resulting watch structure $\Delta$ will be well formed wrt. the resulting assignment $\ass$.
%\end{enumerate}

%In line 1 of algorithm \ref{alg:up}, $\ass$ is altered by appending the given signed literal $\sgl$. Now, $\Delta$ might not be well formed wrt.~the altered assignment $\ass'$ anymore, because there might be some nogood $\delta \in \dpm(\sgl)$. By executing algorithm \ref{alg:upu}, $\Delta$ is transformed into a well formed watch structure $\Delta'$.
Before establishing \ref{up:sound:post2} and \ref{up:sound:post3} observe the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} of Algorithm \ref{alg:up} closely:
\begin{description}
\item[Initialization] Construct $A_1$ by appending $\sgl$ to $\ass$ (line~\ref{alg:up:circ}). Initialize some loop counter $i = 1$ (line~\ref{alg:up:i}). It points at the next literal on which propagation should be performed, i.e.~initially $\sgl = \ass_1[|\ass| + 1]$. 

\item[Iteration] Let the pair $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle = \textsc{UnitPropagate}(\ass_i, \Delta_i, |A| + i)$ (line~\ref{alg:up:loop:prop}) denote the output of the $i$-th iteration which performs propagation on assignment $\ass_i$, watch structure $\Delta_i$ and literal $\ass_i[|A| + i]$ (line~\ref{alg:up:loop:lit}). Conversely $S_i$ can be interpreted as the input for the $(i+1)$-th iteration. Analysis of the difference between $\Delta_{i}$ and $\Delta_{i+1}$ is what resembles soundness below.

\item[Termination] Because the number of literals in all nogoods $\delta \in \Delta$ is finite, for some $i = k$ the loop invariant (line~\ref{alg:up:loop:begin}) is violated, i.e.~$|\ass_{k}| < |A| + k$. Intuitively, this is the case if no new assignment can be inferred ($S_{k-1} = \langle \ass_{k-1}, \Delta_{k-1} \rangle$ and $S_k = \langle \ass_k, \Delta_k \rangle$ with $\ass_{k-1} = \ass_k$) or a conflict is reached ($\ass_k = \emph{conflict}$). When the loop terminates, $\langle \ass', \Delta' \rangle = S_k$ is returned (line~\ref{alg:up:ret}).
\end{description}

We consider two subsequences of the assignment $A_n$: $\ass_n^L$ is the \enquote{left} subsequence, which contains all assignments that already are processed and will not cause propagation. Conversely, $\ass_n^R$ is the \enquote{right} subsequence, containing all literals that might still cause unit propagation. As expected, the two subsequences add up to the full sequence $A_n = A_n^L \cup A_n^R$.

Towards showing \ref{up:sound:post2} and \ref{up:sound:post3} from the preconditions, assume that $\sgl$ does not conflict with $\ass$ and let $\mathcal{P}(n) = \textrm{\ref{up:sound:ind:noconflict}} \vee \textrm{\ref{up:sound:ind:conflict}}$ where

\begin{enumerate}[label=(\Roman*)]
	\item Let $\ass_n^L = \ass_n[1, |A| + n - 1], \ass_n^R = \ass_n[|A| + n, |\ass_n|]$. \label{up:sound:ind:noconflict}
	    \begin{enumerate}[label=(\alph*),ref=\theenumi(\alph*)]
	     \item The structure $\Delta_n$ watches $\ass^L_n$ \label{up:sound:ind:watches}, and
	     \item for each nogood $\delta$ in $\Delta_n$:\label{up:sound:ind:lr}
		\begin{enumerate}[label=(\roman*),ref=\theenumii(\roman*)]
			\item If $\delta$ is weakly unit under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:wu}
			\item If $\delta$ is strongly unit under $\ass_n$, then $\exists {\bT v_1} \in A_n^R : \delta \in \Delta_n^\alpha(v_1)$ or $\exists {\bF v_2} \in A_n^R : \delta \in \Delta_n^\pm({\bF v_2})$. \label{up:sound:ind:su}
			\item If $\delta$ is violated under $\ass_n$, then $\exists \sgl \in A_n^R : \delta \in \Delta_n^\pm(\sgl)$. \label{up:sound:ind:vio}
		\end{enumerate}
	\end{enumerate}
	\item $\ass_n = \emph{conflict}$ \label{up:sound:ind:conflict}
\end{enumerate}

\paragraph{Overview and Intuition.} Using $\mathcal{P}(n)$ above, we show that \ref{up:sound:post2} and \ref{up:sound:post3} follow from the preconditions by induction, closely following the structure of Algorithm \ref{alg:up} as outlined above. Initially ($n = 0$, $\ass = \ass_0 = \ass_L^0$ and $\ass_R^0 = \emptyset$), we require the input nogoods $\Delta$ to all be silent through \ref{up:sound:pre} as a \enquote{stable} starting point. While new literals will be appended to the assignment on the \enquote{right} side, we will show that at termination for some $n = k$ as hinted above, $\ass_k^R = \emptyset$ again. From there we establish the postconditions. For the induction step deriving $\mathcal{P}(i + 1)$ from $\mathcal{P}(i)$ we will \enquote{move} exactly one literal $\sgl_i$ from right to left ($\sgl_i \not \in \ass_i^L$, $\sgl_i \in \ass_i^R$ and $\sgl_i \in \ass_{i+1}^L$, $\sgl_i \not \in \ass_{i+1}^R$ as well as $\ass_{i+1}^L = \ass_{i}^L \cup \{ \sgl_i \}$). Here, properties \ref{up:sound:ind:lr} are crucial, as they establish the connection between $A_i^R$ and $A_i^L$ and cover the propagation scenarios for $\sgl_i$. Note that the \enquote{right} subsequence \enquote{grows} (with the exception of $\sgl_i$), i.e.~$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$ because of new literals inferred by propagation.

\paragraph{Base Case.} Concerning the input assignment $\ass_0 = \ass$ and $\Delta_0 = \Delta$, $\mathcal{P}(0)$ directly follows, because \ref{up:sound:ind:watches} is given by \ref{up:sound:pre}, and all nogoods being silent (also given by \ref{up:sound:pre}) implies that the antecedents of \ref{up:sound:ind:wu}, \ref{up:sound:ind:su}, \ref{up:sound:ind:vio} are false.

%The induction step now consists of observing that the loop in lines 3-10 \enquote{preserves} properties (1.) and (2.) of soundness, i.e.~it argues the transitivity of those properties for iteration steps $S_{i}$ to $S_{i+1}$.

%We show that every nogood $\delta \in \Delta'$ is \welf wrt.~$\Delta'$ and $\ass'$, i.e.~$\Delta'$ is \welf wrt.~$\ass'$, by using that $\Delta$ is \welf wrt.~$\ass$ and the definition of the algorithm.

\paragraph{Induction Hypothesis.} $\mathcal{P}(i)$ holds for some $i$.

\paragraph{Induction Step.} For two consecutive iteration steps of the loop $S_{i} = \langle \ass_{i}, \Delta_{i} \rangle$ and $S_{i+1} = \langle \ass_{i+1}, \Delta_{i+1} \rangle$, assume $\mathcal{P}(i)$. Then show $\mathcal{P}(i) \to \mathcal{P}(i + 1)$ as follows:%For readability, let $j = |A| + i$, $\ass_i^L = \ass_i[1, j - 1]$, $\ass_i^R = \ass_i[j, |\ass_i|]$, $\ass_{i+1}^L = \ass_i[1, j]$, $\ass_{i+1}^R = \ass_i[j + 1,|\ass_{i+1}|]$, $\sgl_i = A_i[j]$. 

\begin{enumerate}
\item To show \ref{up:sound:ind:watches} let $\delta \in \Delta$: %$A_i^L$ differs from $A_{i+i}^L$ only by $\sgl_i$, which is processed by Algorithm \ref{alg:up}. Note that for all $\delta$ in $\Delta$, the candidate sets wrt.~$\ass_i^L$ are at most the size of those wrt.~$\ass_{i+1}^L$, i.e.~candidate sets are monotonically decreasing with growing $A^L$.
If $\bpro(\sgl_i) \not \in \delta$, then $\delta$ stays silent and watched. For $\bpro(\sgl_i) \in \delta$, consider the following two cases:
\begin{enumerate}
	\item Assume $\sgl_i \not = \bT v$. Then Algorithm \ref{alg:upu} is invoked and processes all nogoods $\delta \in \dpm(\sgl)$. For any $\delta$, if $|\cdpm(\delta, A)| \geq 2$, then $\delta$ is inserted into the watch sets for exactly two candidates in lines \ref{alg:upu:move:start}-\ref{alg:upu:move:end}.
	\item Assume $\sgl_i = \bT v$. Then Algorithm \ref{alg:upu} is invoked and behaves like for the case where $\sgl_i \not = \bT v$, i.e.~if $\cdpm(\delta,\ass) \geq 2$ then $\delta$ is watched. Additionally, Algorithm \ref{alg:upa} is invoked and processes all nogoods $\delta \in \dal(\sgl)$. For any $\delta$, if $|\cdal(\delta, A)| \not = \emptyset$, then $\delta$ is inserted into the watch set of exactly one candidate in lines \ref{alg:upa:move:start}-\ref{alg:upa:move:end}. 
\end{enumerate}

If $\sgl_i \in \Delta$ then the premises of the \enquote{watch} property regarding candidate sets are false, or pointers were moved such that $\sgl_i$ does not watch $\delta$ anymore.

\item To show \ref{up:sound:ind:wu}, let $\delta \in \Delta$ and assume $\delta$ is weakly unit under $\ass_{i+1}$ (else, \ref{up:sound:ind:wu} trivially holds):
\begin{enumerate}[label=\alph*),ref=\theenumi.\alph*]
	\item Assume $\delta$ is weakly unit under $\ass_i$. \label{pr:corr:wu:wu}
	
	Then $\exists \sgl \in \ass_i^R : \delta \in \Delta_i^\pm(\sgl)$ by the induction hypothesis. 
	
	Assume towards contradiction that $\sgl = \sgl_i$. As $\delta \in \dpm_i(\sgl)$, the weak complement of $\sgl$ is appended to the assignment (Algorithm \ref{alg:upu}, line \ref{alg:upu:wu:circ}), thus $\negweak{\sgl} \in A_{i+1}$. Then $\delta$ is not weakly unit under $A_{i+1}$ contradicting our assumption.
	
	Therefore, $\sgl \not = \sgl_i$. From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$. Further, we see that $\delta \in \dpm_{i}(\sgl)$ implies $\delta \in \Delta_{i+1}^\pm(\sgl)$ because of the behavior of Algorithm \ref{alg:upu} in case $\sgl \not = \sgl_i$ and $\delta$ being weakly unit: The set of nogoods that are considered for processing is indicated in line \ref{alg:upu:it} and consists of exactly those nogoods that are element of $\dpm_{i}(\sgl)$. From $\sgl \not = \sgl_i$ we know that the algorithm will not consider $\delta$ and specifically not add or remove it from any watch set $\dpm$. Thus we have $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:wu} holds.
%\end{enumerate}
	\item Assume $\delta$ is not weakly unit under $A_i$.
	
	Then $\cdpm(\delta, \ass_{i}) \geq 2$ and because $\Delta_i$ watches $A_i$ (ind.~hyp.), we have $\exists \bsgl_1, \bsgl_2 \in \delta : \bsgl_1 \not = \bsgl_2 \wedge \delta \in \Delta_i^\pm(\bsgl_1) \wedge \delta \in \Delta_i^\pm(\bsgl_2)$. We distinguish on whether $\sgl_i$ coincides with one of the watched literals:

	\begin{enumerate}[label=\roman*.,ref=\theenumii.\roman*]
		%\item Assume $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$ towards a contradiction. As $\bsgl_1, \bsgl_2 \in \cdpm(\delta, \ass_i)$, both $\bsgl_1, \bsgl_2$ are unassigned under $\ass_i$ by definition of $\cdpm$. For $\delta$ to be weakly unit under $\ass_{i+1}$, there must be exactly one $\bsgl' \in \delta$ unassigned under $\ass_{i+1}$.
		\item Case $\sgl_i \not = \bsgl_1 \wedge \sgl_i \not = \bsgl_2$.
		
		$\Delta_i^\pm(\bsgl_1) = \Delta_{i+1}^\pm(\bsgl_1)$ and $\Delta_i^\pm(\bsgl_2) = \Delta_{i+1}^\pm(\bsgl_2)$, as watch sets are only modified in case $\bsgl_1 = \sgl_i$ and respectively $\bsgl_2 = \sgl_i$ (see Algorithm \ref{alg:upu}: Only nogoods that are being iterated over in line \ref{alg:upu:it} are being removed from any watch sets in line \ref{alg:upu:rm}). Both $\bsgl_1$ and $\bsgl_2$ are in $A_{i+1}^R$, because $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, thus we have \ref{up:sound:ind:wu}.
		
		\item Case either $\sgl_i = \bsgl_1$ or $\sgl_i = \bsgl_2$.
		\label{sigmaprimes}		
		
		This means, processing of $\sgl_i$ makes $\delta$ become unit but while $\delta$ is processed by Algorithm \ref{alg:upu} it is not unit yet, i.e., another nogood processed after $\delta$ is unit and the assignment done there leads to $\delta$ being unit.
		Without loss of generality ($\bsgl_1$ and $\bsgl_2$ arbitrary in $\cdpm(\delta, \ass_i)$), let $\sgl_i = \bsgl_1$. Therefore, $\bsgl_1 \not \in A_{i+1}^R$. While processing $\delta$, in Algorithm \ref{alg:upu} the branch in line \ref{alg:upu:else} is taken (otherwise $\delta$ cannot be unit under $\ass_{i+1}$). All candidates $\cdpm(\delta, \ass_i)$ except $\bsgl_1$, and therefore any literals $\bsgl_1', \bsgl_2'$ (arbitrarily) chosen in the algorithm, are either unassigned under $\ass_{i+1}$ or in $\ass_{i+1}^R$. As $\delta$ is unit under $\ass_{i+1}$, exactly one of these must be unassigned.
		Assume (w.l.o.g., symmetric) $\bsgl_1'$ unassigned under $A_{i+1}$ and $\bsgl_2' \in \ass_{i+1}^R$. Then \ref{up:sound:ind:wu} holds for $\bsgl_2'$.
		
		\item Case $\bsgl_1 = \sgl_i \wedge \bsgl_2 = \sgl_i$ is impossible because $\bsgl_1 \not = \bsgl_2$.
		\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:su}, let $\delta \in \Delta$ and assume $\delta$ is strongly unit (and therefore also weakly unit, i.e.~$\headf(\delta) = \bT v$ and $\bM v \in \ass_{i+1}$) under $\ass_{i+1}$ (else, \ref{up:sound:ind:su} trivially holds): we distinguish whether $\bpro(\sgl_i) \in \delta$, i.e.~whether the literal being processed is a watch for $\delta$.
\begin{enumerate}
	\item Case $\delta$ is strongly unit under $\ass_i$.
	\begin{enumerate}
		\item Case $\bpro(\sgl_i) \in \delta$, then Algorithm \ref{alg:upu} (line \ref{alg:upu:su:circ}) assigns $\headf(\delta)$, i.e. $\negstrong{\headf(\delta)} \in \ass_{i+1}^R$, and therefore $\delta$ cannot be strongly unit under $\ass_{i+1}$ which contradicts the assumption that $\delta$ is weakly unit under $\ass_{i+1}$.
		\item Case $\bpro(\sgl_i) \not \in \delta$. Because $\delta$ is strongly unit under $\ass_i$ and by the induction hypothesis we have $\exists {\bT v_1} \in \ass_i^R : \delta \in \dal_i(v_1)$ or $\exists {\bF v_2} \in \ass_i^R : \delta \in \dpm_i({\bF v_2})$.
		From $\bpro(\sgl_i) \not \in \delta$ it follows that $\sgl_i \not = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$.	
%		\item Case $\sgl_i = {\bT v_1}$. Then Algorithm \ref{alg:upa} appends the strong complement of the head (line \ref{alg:upa:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
%		\item Case $\sgl_i = {\bF v_2}$. Then Algorithm \ref{alg:upu} appends the strong complement of the head (line \ref{alg:upu:su:circ}), thus $\negstrong{\headf(\delta)} \in A_{i+1}^R$ and therefore $\delta$ is not strongly unit under $A_{i+1}$. \contradiction
			%\item Case $\sgl_i = {\bT v_1} \wedge \sgl_i = {\bF v_2}$ is contradictory. \contradiction % Amounts to the case where $\sgl_i = {\bT v_1} \wedge \sgl_i \not = {\bF v_2}$ because algorithm \ref{alg:upu} is executed before algorithm \ref{alg:upa}, which degrades to a no-operation, because $\delta$ is neither strongly unit, nor is $C_\alpha(\delta, A)$ (where $A$ is defined in the scope of the algorithm, a hybrid state between $A_i$ and $A_{i+1}$) non-empty when it is executed.

		From $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that if ${\bT v_1}, {\bF v_2}$ exist, they are in $\ass_{i+1}^R$. Also, $\delta \in \dal_i(v_1)$ implies $\delta \in \dal_{i+1}(v_1)$ and $\delta \in \dpm_i({\bF v_2})$ implies $\delta \in \dpm_{i+1}({\bF v_2})$ because $\delta$ is strongly unit and $\bpro(\sgl_i) \not \in \delta$, i.e. no algorithm will change the watches that contain $\delta$. So we have $\exists {\bT v_1} \in \ass_{i+1}^R : \delta \in \dal_{i+1}(v_1)$ or $\exists {\bF v_2} \in \ass_{i+1}^R : \delta \in \dpm_{i+1}({\bF v_2})$, i.e.~\ref{up:sound:ind:su}. % TODO: \sgl might actually change (pointer move) which is not mentioned here. If this does not get mentioned in the watches section of the proof, add a remark here explaining that \sgl might change in the course of algorithm 3.3 but only in a way that fulfills above criteria.
	\end{enumerate}
	
	
	\item Case $\delta$ is not strongly unit under $A_i$. Then, $\bass(\ass_i) \setminus \delta \not = \emptyset$.


	\begin{enumerate}
		\item Case $\bpro(\sgl_i) \not \in \bass(A_i)$, i.e., none of the literals of $\delta$ is processed in this step. Since $\delta$ is strongly unit under $\ass_{i+1}$ and not strongly unit under $A_i$ it holds that $\delta \setminus \ass_{i+1}^R \not = \emptyset$.
		
		Since $\delta$ is strongly unit under $\ass_{i+1}$, it is also weakly unit under $\ass_{i+1}$. Therefore there exists $\sgl' \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl')$.
		
		\begin{itemize}
			\item If $\sgl' = \bF v'$, then $\exists \bF v' \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\bF v')$ and \ref{up:sound:ind:su} holds.
			\item If $\sgl' = \bT v'$, then $\bT v' \not \in \ass_{i+1}^L$ and hence $\bT v' \not \in \ass_i$, which implies that $\cdal(\delta, \ass_i) \supset \{ \bT v' \} \not = \emptyset$. By induction hypothesis it therefore follows that there exists $\bsgl \in \cdal(\delta, \ass_i) : \delta \in \dal(\bsgl)$. By $\cdal(\delta, \ass_i)$ only containing literals of form $\bT v \in \delta$ it follows that $\exists \bT v \in \ass_i^R : \delta \in \dal_i(v)$. Since none of the literals of $\delta$ is processed, it follows that $\delta \in \dal_{i+1}(v)$. Consequently \ref{up:sound:ind:su} holds.
			\item If $\sgl' = \bM v'$, then it follows that $\bT v' \not \in \ass_{i+1}^L$, because $\bM v'$ can only be added to an assignment in Algorithm \ref{alg:upu} by line \ref{alg:upu:wu:circ}, which is only executed if $v'$ is not assigned false, i.e.~$\bF v'$. From $\bT v' \not \in \ass_{i+1}^L$ the same reasoning as in the previous case applies and it follows that \ref{up:sound:ind:su} holds.
		\end{itemize}
	
	\item 	$\bpro(\sgl_i) \in \delta \setminus \bass(\ass_i)$, i.e. some literal in $\delta$ is processed. If $\delta$ is strongly unit while $\delta$ is processed by Algorithm \ref{alg:upu}, then $\negstrong{\headf(\delta)} \in \ass_{i+1}$ due to line \ref{alg:upu:su:circ} of Algorithm \ref{alg:upu}, which contradicts $\delta$ being strongly unit under $\ass_{i+1}$. Therefore $\delta$ is not yet strongly unit when Algorithm \ref{alg:upu} processes $\delta$.
	

	\begin{enumerate}
		\item Case $\delta$ is weakly unit with $\sgl_i$ unassigned: since $\delta$ is strongly unit under $\ass_i$ it must be the case that $\delta$ is weakly unit on $\headf(\delta)$, i.e., $\bsgl$ of line \ref{alg:upu:wu:circ} in Algorithm \ref{alg:upu} is such that $\bsgl = \headf(\delta)$. From $\delta$ not being strongly unit under $\ass_i$  then follows that some $\bT v' \in \delta$ is assigned \emph{\mbt}, i.e.~$\bM v' \in \ass_i^L$.
	
	Let $M = \{ \bT v \in \delta \setminus \headf(\delta) \mid \bM v \in \ass_i \}$ be the set of all such \emph{\mbt} assigned literals of $\delta$ except its head. Let $\bT v'$ in the following be the literal of $M$ that is assigned last under $\ass_{i+1}$. Intuitively, $\bT v'$ triggers $\delta$ to be unit.
	
	Since $\bT v'$ is the \enquote{last} of $M$ that is assigned, it cannot be the case that $\bT v' = \sgl_i$, as otherwise $\delta$ would be strongly unit while processing $\sgl_i$.
	
	We distinguish whether $\sgl_i = \bT w$ for one atom $w$.
	
	\begin{itemize}
		\item If $\sgl_i = \bT w$, then Algorithm \ref{alg:upsingle} is executed and calls Algorithm \ref{alg:upa}. Since $\delta$ is not strongly unit under $\ass_i$ and $\cdal(\delta, \ass_i) \not = \emptyset$ because $\{ \bT v' \} \in \cdal(\delta, \ass_i)$ lines \ref{alg:upa:move:start}-\ref{alg:upa:move:end} are executed and it holds that $\exists \bT v_1 \in \ass_{i+1}^R : \delta \in \dal_{i+1}(v_1)$, i.e.~\ref{up:sound:ind:su} holds.
	
		\item If $\sgl_i \not = \bT w$, then Algorithm \ref{alg:upa} is not executed and from $\bT v' \not \in \ass_{i+1}^L$ it follows that $\bT v' \not \in \ass_i$ and $\cdal(\delta, \ass_i) \not = \emptyset$, hence by induction hypothesis $\exists \bsgl \in \cdal(\delta, \ass_i) : \delta \in \dal_i(\bsgl)$ with $\bsgl = \bT v_1$ for some atom $v_1$. Since Algorithm \ref{alg:upa} is not executed, $\delta \in \dal_{i+1}(\bT v_1)$ and $\bT v_1 \in \ass_{i+1}^R$, i.e.~\ref{up:sound:ind:su} holds.
	
	\end{itemize}
	
	\item Case $\delta$ is not weakly unit with $\sgl_i$ unassigned, then in Algorithm \ref{alg:upu} line \ref{alg:upu:move:start}-\ref{alg:upu:move:end} are executed and there exist $\bsgl_1, \bsgl_2$ with $\bsgl_1, \bsgl_2 \not \in \ass_i : \delta \in \dpm(\bsgl_1) \text{ and } \delta \in \dpm(\bsgl_2)$ to establish that $\delta$ is watched. Similar to the reasoning in \ref{sigmaprimes}, we see that the watches condition ensures that the assignment that leads to $\delta$ being strongly unit will be processed.% If $\bsgl_1 = \bF v$ for some atom $v$, then $\exists \bF \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\bF v)$, i.e., \ref{up:sound:ind:su} holds. If $\bsgl = \bT v$ then $\cdal(\delta, \ass_i) \not = \emptyset$ and by induction hypothesis it follows that $\exists \bT v' \in \ass_{i+1}^R : \delta \in \dal_{i+1}(v')$. Thus \ref{up:sound:ind:su} holds in every case.
	
	\end{enumerate}
	
%		\item Case ${\bT v} \in \bodyf(\delta) \setminus A_i$.
		
%		Then, $C^\alpha(\delta, A_{i}) \not = \emptyset$. Because $\Delta_i$ watches $\ass_i$ it follows that $\exists \bsgl \in C_\alpha(\delta, A_i): \delta \in \dal(\sigma)$.
		
%		\begin{enumerate}
%			\item Case $\sgl_i = \bsgl$.
			
%			leads to a contradiction ($\delta$ not strongly unit under $A_{i+1}$)
			
%			\item Case $\sgl_i \not = \bsgl$.
			
%			$\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, we have $\bsgl \in \ass_{i+1}^R$, thus $\exists \bsgl \in \ass_{i+1}^R : \delta \in \dal_{i+1}(\bsgl)$, i.e.~\ref{up:sound:ind:su}. \todo{Why $\delta \in \dal_{i+1}(\bsgl)$?}
%		\end{enumerate}			
			
%		\item Case ${\bT v} \not \in \bodyf(\delta) \setminus A_i$.
%			\begin{enumerate}
%				\item Case $\negweak{\headf(\delta)} \not \in A_{i} \wedge \negstrong{\headf(\delta)} \not \in A_{i}$, i.e.~the head is unassigned. Then there are at least two literals in $\delta$ unassigned under $A_i$ (one in the body and the head). From \ref{up:sound:ind:watches} we have $\bsgl_1, \bsgl $
%				\item Case $\negweak{\headf(\delta)} \in A_{i}$.
%				If $|\bodyf(\delta) \setminus A_i| \geq 2$, then there are at least two unassigned literals. Else if $\bodyf(\delta) \setminus A_i = \{ {\bF v} \}$, then $\delta$ is weakly unit.
%			\end{enumerate}
%	\end{enumerate}


%	\begin{enumerate}
%		\item Case $\bT v \in \bodyf(\delta) \setminus A_i$. If $\headf(\delta) \not \in A_i$ then there are at least two distinct literals $\bsgl_1, \bsgl_2 \in \delta$ (one in the body, and the head) that are unassigned unter  $A_i$ and \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$. Else, i.e.~$\headf(\delta) \in A_i$, then $|\bodyf(\delta) \setminus A_i| \geq 2$, thus \ref{up:sound:ind:su} holds for $A_{i+1}$ according to \ref{up:sound:ind:watches} for $A_i$.
%	\item Case $\bodyf(\delta) \setminus A_i = \{ \bF v' \}$, i.e.~$\delta$ is weakly unit under $A_i$, then according to \ref{up:sound:ind:wu}, $\exists \ \bsgl \in \bass(A_i^R) : \delta \in \Delta_i^\pm(\bsgl)$. From $A_i^R \cap \delta \subseteq \{ \bF v' \}$ follows that $v = v'$ and thus \ref{up:sound:ind:su}.
	\end{enumerate}
\end{enumerate}

\item To show \ref{up:sound:ind:vio}, let $\delta \in \Delta$ and assume $\delta$ is violated under $A_{i+1}$ (else \ref{up:sound:ind:vio} trivially holds).
\begin{enumerate}
\item Assume $\delta$ is violated under $A_i$.

Then $\exists \sgl \in \ass_i^R : \delta \in \dpm_i(\sgl)$ via induction hypothesis.
\begin{enumerate}
\item Case $\sgl = \sgl_i$.

Then, according to Algorithm \ref{alg:upu} (line \ref{alg:upu:conflict}) $A_{i+1} = \emph{conflict}$, so \ref{up:sound:ind:conflict} holds.

\item Case $\sgl \not = \sgl_i$.

Then, from $\ass_{i}^R \setminus \{ \sgl_i \} \subseteq \ass_{i+1}^R$, it follows that $\sgl \in \ass_{i+1}^R$, thus $\exists \sgl \in \ass_{i+1}^R : \delta \in \dpm_{i+1}(\sgl)$, because $\delta \in \dpm_i(\sgl)$ implies $\delta \in \dpm_{i+1}(\sgl)$, as watch sets are only modified for nogoods that are watched by $\sgl_i$. So we have $\exists \sgl \in \ass_i^R : \delta \in \dpm_{i+1}(\sgl)$, i.e.~\ref{up:sound:ind:vio} holds.
\end{enumerate}
\item Assume $\delta$ is not violated under $A_i$. Then $|\bass(A_i) \setminus \delta| \geq 1$  holds by Definition \ref{def:vio}.

\begin{enumerate}
\item Assume $|\delta \setminus \bass(\ass_i)| \geq 2$. This means that at least on literal in $\delta$ is unassigned. Then because $\Delta_i$ watches $A_i$ it follows that $\exists \bsgl_1, \bsgl_2 : \delta \in \Delta_i^\pm(\bsgl_1), \Delta_i^\pm(\bsgl_2)$. Further $\bsgl_1 \not = \sgl_i$ or $\bsgl_2 \not = \sgl_i$, so w.l.o.g.~$\bsgl_1 \not = \sgl_i$, so $\exists \ {\bX v} \in X : \delta \in \Delta_{i+1}^\pm(v)$ with a reasoning similar to \ref{sigmaprimes}.

\item Assume $|\delta \setminus \bass(\ass_i)| = 1$. Then $\delta$ is weakly unit under $A_i$, and with reasoning similar to \ref{pr:corr:wu:wu} one can show that $\exists \sgl \in \ass^R_{i+1}$ with $\delta \in \dpm_{i+1}(\sgl)$.
\end{enumerate}

\end{enumerate}

\end{enumerate}

\begin{comment}
\begin{enumerate}
\item If $\sgl_i \not \in \delta$, then: % A nogood only contains boolean signed literals, so dies this even make sense? \sgl is a signed literal, not a boolean signed literal, so how can it be element of delta? Needs clarification.
\begin{enumerate}
\item $\delta$ is not violated under $\abef$ (inv1). Therefore, $\delta$ is not violated under $\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item $\delta$ is not unit wrt.~$\abef$ (inv2). Therefore, $\delta$ is not unit wrt.~$\aaf = \abef \circ \sgl_i$ because $\sgl_i \not \in \delta$.
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned wrt.~$\aaf$. Then $\bsgl_1$ and $\bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied under $\abef$, because $\abef \subset \aaf = \abef \circ \sgl_i$ and $\sgl_i \not \in \delta$. Therefore, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ must hold (inv3). For the same two literals, $\delta \in \daf^\pm(\bsgl_1)$ and $\delta \in \daf^\pm(\bsgl_2)$ holds. % Needs clarification. Reference the loop that the nogood is certainly not part of.
\item Analogous to (c), if $\delta$ has any triggers, their assignment does not change, as $\sgl_i \not \in \delta$, and no watches $\delta \in \dbef^\alpha(\bsgl)$ are changed. The same $\bsgl$ will satisfy $\delta \in \dbef^\alpha(\bsgl)$ for $\abef$ and $\aaf$.
\end{enumerate}
\item Else ($\sgl_i \in \delta$):
\begin{enumerate}
\item If $\delta \not \in \dbef^\pm(\sgl_i)$, i.e.~$\delta$ was not watched on $\sgl_i$, then
\begin{enumerate}
\item To show that $\delta$ is not violated by $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not violated under $\aaf$ as $\delta$ is not violated by $\abef$ (inv1) and $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals in $\delta$ unassigned wrt.~$\abef$ as $\delta$ is not unit wrt.~$\abef$ (inv2). From $|\aaf| = |\abef| + 1$ if follows that there must be at least one literal in $\delta$ which is unassigned wrt.~$\aaf$, therefore $\delta$ cannot be violated under $\aaf$.
\end{enumerate}
\item To show that $\delta$ is not unit under $\aaf$:
\begin{enumerate}
\item Assume $\delta$ is satisfied under $\abef$. Then $\delta$ is not unit under $\aaf$ because $\abef \subset \aaf$.
\item Assume $\delta$ is not satisfied under $\abef$. Then there are at least two literals $\bsgl_1, \bsgl_2, \ldots \in \delta$ that are unassigned wrt.~$\abef$, as $\delta$ is not unit under $\abef$ (inv2). Further, $\delta \in \dbef^\pm(\bsgl_1)$ and $\delta \in \dbef^\pm(\bsgl_2)$ (inv3). From $\delta \not \in \dbef^\pm(\sgl_i)$ it follows that $\sgl_i \not = \bsgl_1$ and $\sgl_i \not = \bsgl_2$. % How are binary signed literals and signed literals compared?
Therefore $\delta$ is not unit, because $\bsgl_1, \bsgl_2 \in \delta$ are unassigned wrt.~$\aaf$.
\end{enumerate}
\item Assume $\delta$ is not satisfied under $\aaf$ and contains at least two literals $\bsgl_1, \bsgl_2, \ldots$ unassigned under $\aaf$. Then $\bsgl_1, \bsgl_2$ are unassigned wrt.~$\abef$ and $\delta$ is not satisfied wrt.~$\abef$ because $\abef \subset \aaf$ and $\delta \not \in \dbef^\pm(\sgl_i)$ and $\delta$ is not unit wrt.~$\abef$.
\item Same as 1.d ...
\end{enumerate}
\item Else ($\delta \in \dbef^\pm(\sgl_i)$), i.e.~$\delta$ was watched on $\sgl_i$.
\begin{enumerate}
\item If $\delta$ is weakly unit under $\aaf$ with $\bsgl$ unassigned, then the algorithm generates the assignment $\negweak{\bsgl}$.
\item Else
\item If there are two unassigned pointer move $\to$ two unassigned literals
\item pointer move $\to$ two unassigned literals
\item violated $\to$ conflict
\item weakly unit $\to$ satisfied
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{comment}

Above induction step serves as an explanation on how execution of the loop affects the assignment and especially the watch structure. By using induction, $\mathcal{P}(i)$ was shown for any $i \geq 0$, and therefore for any iteration of the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} as well. Specifically $\mathcal{P}(i)$ holds for the last iteration $i = k$ represented by $S_k = \langle \ass_k, \Delta_k \rangle$.

For cases without conflict and the loop terminating at $S_k$, the outcome that $\Delta'$ watches $A'$ directly follows from \ref{up:sound:ind:watches} as $\ass' = \ass_k$ and $\Delta' = \Delta_k$. From termination follows $A_k^R = \emptyset$, i.e.~there are no nogoods $\delta \in \Delta'$ that are weakly unit, strongly unit or violated under $\ass'$, thus all $\delta$ are silent under $\ass'$. Together, this amounts to \ref{up:sound:post2}.

Cases in the induction step leading to \ref{up:sound:ind:conflict} map to \ref{up:sound:post3}.

To show \ref{up:sound:post1} assume $\sgl$ conflicts with $\ass$. Then, on line~\ref{alg:up:circ} of Algorithm \ref{alg:up}, the assignment $A_1$ will be assigned \emph{conflict}. Consequently, the loop in lines~\ref{alg:up:loop:begin}-\ref{alg:up:loop:end} is not executed as $|\emph{conflict}| = 0$ and $i$ must be at least 1, as it is assigned 1 on line \ref{alg:up:i}. $\langle \emph{conflict}, \Delta \rangle$ is returned.
\end{proof-sketch}

%\begin{theorem}
%Algorithm \ref{alg:up} is complete.
%\end{theorem}

%\begin{proof}
%Indirect proof, showing that if there is an assignment that results from propagation it %will be generated.
%\end{proof}

%\begin{theorem}
%Algorithm \ref{alg:up} is sound and complete.
%\end{theorem}
%\begin{proof}
%\end{proof}

\chapter{Evaluation}
\label{chap:eval}

To support our results of performance improvement with 3WL compared to naive propagation, and in order to showcase the Alpha system as the first ASP system to combine 3WL with lazy grounding, we evaluated the run time performance for the publicly available\footnote{Concrete instances are available via \url{http://www.kr.tuwien.ac.at/research/systems/alpha/instances.zip}, whereas Java code to generate new instances can be obtained from \url{https://github.com/alpha-asp/benchmarks}.} set of problem instances used in \cite{alpha-techniques}.

\paragraph{Setup.} The benchmarks were run with Alpha \texttt{v0.2.0}\footnote{Download freely available at \url{http://github.com/alpha-asp/alpha/releases/v0.2.0}.} on a machine with an Intel$^{\text{\tiny{\textregistered}}}$ Core$^{\text{\tiny{TM}}}$ i7-7500U CPU @ 2.7GHz, 16GB main memory, Linux kernel 4.12.5 and Oracle Java$^{\text{\tiny{TM}}}$ SE Runtime Environment (build \texttt{1.8.0\_144-b01}).

\paragraph{Method.} All measured timings are times until the first 10 (or all, if less than 10) answer sets were found, and the solver used a fixed randomization seed of 0 (via the \texttt{-{}-deterministic} command line switch). The Java virtual machine was instructed to limit memory usage to approximately 8GB (flags \texttt{-XX:MaxRAM=8000M -Xmx3500M}) and the process running the JVM was terminated for time-out after 300 seconds (wall time).

In the following four paragraphs we discuss the properties of the input problems and briefly comment on the benchmark results.

\begin{description}
\item{\bfseries Grounding Explosion} is a benchmark modeled after the program shown in Example \ref{ex:explosion} and aims to exhibit the grounding bottleneck. Given a domain of size $n$, the problem is selecting at most one element from a domain of size $n$ and deriving an atom $p(X_1, \ldots , X_6)$ where all $X_1, \ldots , X_6$ are the selected element.
As reported in \cite{alpha-techniques}, significant differences in the results for this benchmark arise from the comparison of ground-and-solve vs.~lazy-grounding systems. Because the difficulty in this benchmark lies in grounding, not in search and propagation, there is no relevant difference in run time expected, which aligns with our results as presented in Table \ref{tbl:gex}.

\item{\bfseries Cutedge} is taken from \cite[Example 1]{omiga}. This problem consists of computing reachability from a graph with exactly one edge removed.
Our results (see Table \ref{tbl:cut}) show that na\"{i}ve propagation outperforms 3WL, which runs into memory issues: Because of the combinatorial nature of the problem (5.4 million nogoods for 500 vertices and adjacency-probability of 30\%) and the more complex memory layout required by 3WL, it uses up all available memory. Na\"{i}ve propagation performs well, because the search space is quite dense: For many calls to the propagation routine, 83\% to 21\% of nogoods are reported unit (some might be counted twice, as strongly and weakly unit counts were added up during analysis). With that many nogoods being unit, the na\"{i}ve approach is faster because it does not have to do any bookkeeping operations to adjust references to watched literals.

\item{\bfseries Graph 5-Colorability} is the problem of assigning one out of five possible colors to each vertex in a graph such that no connected vertices have the same color. Our results (shown in Table \ref{tbl:5col}) clearly show an improvement when using 3WL compared to na\"{i}ve propagation. We see many propagation cycles with just two to six nogoods (out of tens of thousands) being unit. While the na\"{i}ve approach must check all nogoods, 3WL enables targeted propagation.

\item{\bfseries Reachability} instances are positive programs that compute pairwise reachability of nodes in a graph. Again, sometimes as many as 10\% to 20\% of all nogoods are unit (with possible duplicates; nogoods that are strongly and weakly unit in one run are counted twice). This makes na\"{i}ve propagation slightly faster than the 3WL approach.
For positive programs, which contain no default negated literals, search is not necessary. Other systems such as \texttt{clingo} use \emph{intelligent grounding} for this class of programs which could also be done for Alpha. We therefore include the results for this benchmark (Table \ref{tbl:reach}) primarily for the sake of completeness, as it is not relevant for directly comparing na\"{i}ve propagation with 3WL.
\end{description}

\begin{table}
\begin{center}
\begin{tabular}{|c||r|r|}
\hline
Size & \multicolumn{1}{c|}{3WL} & \multicolumn{1}{c|}{na\"{i}ve} \\ 
\hline
$n$ & $\langle t_{1, \ldots, 10} \rangle$~[s]& $\langle t_{1, \ldots, 10} \rangle$~[s]\\
\hline
\hline
   8 & 	  0.703 &	  0.707 \\
  10 & 	  0.763 &	  0.756 \\
  12 & 	  0.752 &	  0.783 \\
  14 & 	  0.741 &	  0.764 \\
  16 & 	  0.728 &	  0.774 \\
  18 & 	  0.736 &	  0.769 \\
  20 & 	  0.736 &	  0.762 \\
  22 & 	  0.757 &	  0.772 \\
  24 & 	  0.757 &	  0.794 \\
  26 & 	  0.775 &	  0.779 \\
  28 & 	  0.747 &	  0.767 \\
  30 & 	  0.770 &	  0.806 \\
  50 & 	  0.776 &	  0.827 \\
 100 & 	  0.813 &	  0.855 \\
 300 & 	  0.987 &	  1.049 \\
 500 & 	  1.097 &	  1.218 \\
1000 & 	  1.452 &	  1.626 \\
\hline
\end{tabular}
%\hspace{3mm}
%10 answer sets, all runs in less than 300s and 8GB
\end{center}
\caption[Results for grounding explosion benchmark]{Results for grounding explosion benchmark: Time in seconds taken to compute 10 answer sets, averaged over 10 runs. Size corresponds to size of the domain.}
\label{tbl:gex}
\end{table}

\begin{table}
\begin{center}
	\begin{tabular}{|cc||rcc|rcc|}
\hline
\multicolumn{2}{|c||}{Size} & \multicolumn{3}{c|}{3WL} & \multicolumn{3}{c|}{na\"{i}ve} \\
\hline
$|V|$ & $p(e)$& $\langle t_{1, \ldots, 10} \rangle$~[s]&t/o&m/o& $\langle t_{1, \ldots, 10} \rangle$~[s]&t/o&m/o\\
\hline
\hline
100 & 0.3 & 	  6.158 & 0 &  0 &	  4.955 & 0 & 0 \\
100 & 0.5 & 	  6.082 & 0 &  0 &	  6.176 & 0 & 0 \\
200 & 0.3 & 	 15.594 & 0 &  0 &	 14.873 & 0 & 0 \\
200 & 0.5 & 	 28.956 & 0 &  0 &	 23.695 & 0 & 0 \\
300 & 0.1 & 	 12.396 & 0 &  0 &	 11.116 & 0 & 0 \\
300 & 0.3 & 	 38.320 & 0 &  0 &	 34.439 & 0 & 0 \\
300 & 0.5 & 	    n/a & 3 &  7 &	 79.843 & 0 & 0 \\
400 & 0.1 & 	 23.740 & 0 &  0 &	 18.643 & 0 & 0 \\
400 & 0.3 & 	    n/a & 3 &  7 &	 84.185 & 0 & 0 \\
400 & 0.5 & 	    n/a & 3 &  7 &	134.273 & 0 & 0 \\
500 & 0.1 & 	 35.609 & 0 &  0 &	 31.080 & 0 & 0 \\
500 & 0.3 & 	    n/a & 0 & 10 &	106.703 & 0 & 0 \\
500 & 0.5 & 	    n/a & 7 &  3 &	    n/a & 5 & 5 \\
\hline
	\end{tabular}
%\hspace{3mm}
%10 answer sets, time-out at 300s, memory-out at 8GB	
	\end{center}
	
	\caption[Results for cutedge benchmark]{Results for cutedge benchmark: Time in seconds taken to compute 10 answer sets, averaged over successful single runs on 10 randomly generated instances. Size is number of vertices combined with probability of any two vertices being connected. Number of timeouts and memory-outs is indicated in columns t/o and m/o, respectively.}
	\label{tbl:cut}
\end{table}

\begin{table}
\begin{center}
	\begin{tabular}{|cc||rcc|rcc|}
\hline
\multicolumn{2}{|c||}{Size} & \multicolumn{3}{c|}{3WL} & \multicolumn{3}{c|}{na\"{i}ve} \\
\hline
$|V|$ & $\sfrac{|E|}{|V|}$& $\langle t_{1, \ldots, 10} \rangle$~[s]&t/o&m/o& $\langle t_{1, \ldots, 10} \rangle$~[s]&t/o&m/o\\
\hline
\hline
  10 &   4 & 	  1.374 & 0 & 0 &	  0.916 &  0 & 0 \\
  20 &   4 & 	  0.845 & 0 & 0 &	  1.373 &  0 & 0 \\
  30 &   4 & 	  1.025 & 0 & 0 &	  2.077 &  0 & 0 \\
  40 &   4 & 	  1.161 & 0 & 0 &	  2.938 &  0 & 0 \\
  50 &   1 & 	  0.910 & 0 & 0 &	  2.205 &  0 & 0 \\
  50 &   2 & 	  1.032 & 0 & 0 &	  2.626 &  0 & 0 \\
  50 &   4 & 	  1.290 & 0 & 0 &	  4.461 &  0 & 0 \\
  50 &   6 & 	  8.494 & 2 & 0 &	 23.105 &  4 & 0 \\
  50 &   8 & 	 61.043 & 7 & 0 &	    n/a & 10 & 0 \\
  50 &  10 & 	 41.317 & 3 & 0 &	    n/a & 10 & 0 \\
  75 &   4 & 	  1.682 & 0 & 0 &	  8.983 &  0 & 0 \\
 100 &   4 & 	  2.305 & 0 & 0 &	 16.840 &  0 & 0 \\
 200 &   4 & 	  4.940 & 0 & 0 &	115.977 &  0 & 0 \\
 300 &   4 & 	  7.017 & 0 & 0 &	    n/a & 10 & 0 \\
 400 &   4 & 	 10.375 & 0 & 0 &	    n/a & 10 & 0 \\
 500 &   4 & 	 12.979 & 0 & 0 &	    n/a & 10 & 0 \\
 750 &   4 & 	 25.820 & 0 & 0 &	    n/a & 10 & 0 \\
1000 &   4 & 	 39.961 & 0 & 0 &	    n/a & 10 & 0 \\
\hline
	\end{tabular}
%\hspace{3mm}
%10 answer sets, time-out at 300s, memory-out at 8GB
	\end{center}
	\caption[Results for graph 5-colorability benchmark]{Results for graph 5-colorability benchmark: Time taken in seconds to compute 10 answer sets, averaged over successful single runs on 10 randomly generated instances. Size is number of vertices combined with number of edges in relation to the number of vertices. Number of timeouts and memory-outs is indicated in columns t/o and m/o, respectively.}
	\label{tbl:5col}
\end{table}
\begin{table}
	\begin{center}
	\begin{tabular}{|cc||r|r|}
\hline
\multicolumn{2}{|c||}{Size} & \multicolumn{1}{c|}{3WL} & \multicolumn{1}{c|}{na\"{i}ve} \\ 
\hline
$|V|$ & $\sfrac{|E|}{|V|}$& $\langle t_{1, \ldots, 10} \rangle$~[s]& $\langle t_{1, \ldots, 10} \rangle$~[s]\\
\hline
\hline
 1000 & 4 & 	  1.085 &	  1.102 \\
 1000 & 8 & 	  1.737 &	  1.607 \\
10000 & 2 & 	  3.309 &	  3.666 \\
10000 & 4 & 	  6.779 &	  5.416 \\
10000 & 8 & 	 10.116 &	  8.874 \\
\hline
	\end{tabular}
%\hspace{3mm}
%all runs in less than 300s and 8GB
	\end{center}
	\caption[Results for reachability benchmark]{Results for reachability benchmark: Time taken compute 10 answer sets, averaged over single runs on 10 randomly generated instances. Size is number of vertices combined with number of edges in relation to the number of vertices.}
	\label{tbl:reach}
\end{table}

\paragraph{Summary.} Evaluation of 3WL as implemented in the Alpha system has shown that the approach is especially effective when the number of nogoods that are not unit throughout search is low compared to the total set of nogoods. For these instances, speedups of several orders of magnitude were measured (Table \ref{tbl:5col}). In cases where many nogoods propagate, bookkeeping operations (adjustment of watched literals) nullify gains in run time. Concerning memory usage, there is some overhead for 3WL, so the method generally runs into memory limits faster (i.e.,~for smaller instances) than the na\"{i}ve approach.

\chapter{Conclusion}
\label{chap:conc}

We have presented a new method for unit propagation, tailored for lazy-grounding ASP solvers called Three Watched Literals (3WL). It is an extension of the Two Watched Literals scheme (2WL), prominent in SAT solvers. We extended 2WL for a third truth value \emph{\mbt}, which was found to greatly improve search performance for lazy-grounding in previous works. We introduced watch structures that can be easily implemented as the core data structure to perform 3WL.

Soundness of the new approach was analyzed in great detail and describes how assigning one atom initiates a series of propagation that restore coherence between assignment and watch structure at the point of termination.

Our evaluation shows that 3WL does not strictly perform better than a na\"{i}ve approach, but yields considerable improvements when the portion of unit nogoods during search is small, which often happens for search intense problems. Here, a run-time improvement of several orders of mangnitude can be expected.

\section{Related Work}

This work heavily relies on previous results as cited. Most notably \citet{effsat,questsat} described 2WL and \citet{dlv-mbt} introduced \emph{\mbt} to ASP solvers.

\section{Open Questions and Further Work}

The algorithm presented in Chapter \ref{chap:prop} does not consider guessing of assignments for atoms and backtracking in case of guesses leading to conflicts. One possibility for future work therefore is formalization of the behavior of 3WL including backtracking. Note that the implementation in the Alpha system, which was evaluated in Chapter \ref{chap:eval} implements backtracking, so there is some discrepancy between what was described and analysed here, and the concrete implementation. Based on this work, 3WL supporting backtracking was developed and is presented at \cite{alpha-techniques}.

Showing the completeness of 3WL remains open.

Evaluation results show that 3WL is not effective for instances where a \enquote{large} subset of nogoods propagates. Future work might address this issue and attempt to approximate threshold levels for the effectiveness of 3WL based on parameters of the input program. This line of research might lead to adaptive implementations that use heuristics to decide which method of propagation should be used. This proposes interesting challenges in the engineering aspects of solver systems, e.g.~interfacing with different unit propagation modules within the same solver system.

\cite{effstructs} surveys propagation schemes in SAT solvers. An extension for \emph{\mbt} similar to the one in this work could be done to find out whether the results also hold for three truth values.

One issue that is not directly connected to 3WL, but to addressing the grounding bottleneck more generally, is dynamic deletion of nogoods. By deleting \enquote{inactive} nogoods during search, additional memory might be freed, allowing solvers to work with larger search spaces. As the watch structure holds all nogoods, integrating nogood deletion might well be tightly coupled with propagation.

\backmatter
\listoffigures*
\listoftables*
\listofalgorithms

\bibliographystyle{plainnat}
\begingroup
\renewcommand{\addcontentsline}[3]{}% Remove functionality of \addcontentsline
\bibliography{thesis}
\endgroup

\end{document}